<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="[TOC] BlueStore 的主要任务是快速、安全地完成OSD的数据读写请求  快速： 尽可能简化数据读写过程中的操作 能适应近年出现的SSD、NVMe SSD、NVRAM等更快速的存储介质   安全 满足ACID定义的数据存储可靠性和一致性的要求，当意外情况发生，可将未完成的写事务完全写入或者完全撤销    BlueStore承载OSD发送过来的数据读写事务，可处理的事务由数据的读写操作与相"><meta property="og:type" content="article"><meta property="og:title" content="5.BlueStore"><meta property="og:url" content="https://amostian.github.io/posts/181607087/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="[TOC] BlueStore 的主要任务是快速、安全地完成OSD的数据读写请求  快速： 尽可能简化数据读写过程中的操作 能适应近年出现的SSD、NVMe SSD、NVRAM等更快速的存储介质   安全 满足ACID定义的数据存储可靠性和一致性的要求，当意外情况发生，可将未完成的写事务完全写入或者完全撤销    BlueStore承载OSD发送过来的数据读写事务，可处理的事务由数据的读写操作与相"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/181607087/%E5%AF%B9%E8%B1%A1%E5%9C%A8BlueStore%E4%B8%AD%E7%9A%84%E6%8F%8F%E8%BF%B0.svg"><meta property="og:image" content="https://amostian.github.io/posts/181607087/ceph-bluestore-arch.png"><meta property="og:image" content="https://amostian.github.io/posts/181607087/image-20241116202733750.png"><meta property="og:image" content="https://amostian.github.io/posts/181607087/image-20241116214142224.png"><meta property="og:image" content="https://amostian.github.io/posts/181607087/BlueStore%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.svg"><meta property="og:image" content="https://amostian.github.io/posts/181607087/bluestore-object-blob-disk-arch.jpg"><meta property="og:image" content="https://amostian.github.io/posts/181607087/BlockDevice.svg"><meta property="og:image" content="https://amostian.github.io/posts/181607087/image-20241115221007664.png"><meta property="og:image" content="https://amostian.github.io/posts/181607087/image-20241117173610808.png"><meta property="og:image" content="https://amostian.github.io/posts/181607087/image-20241117155101062.png"><meta property="og:image" content="https://amostian.github.io/posts/181607087/bluestore-dd-tst-extentmap-17321749615501.jpg"><meta property="article:published_time" content="2024-11-15T07:07:40.000Z"><meta property="article:modified_time" content="2025-02-27T02:15:34.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="存储"><meta property="article:tag" content="分布式存储"><meta property="article:tag" content="Ceph"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/181607087/%E5%AF%B9%E8%B1%A1%E5%9C%A8BlueStore%E4%B8%AD%E7%9A%84%E6%8F%8F%E8%BF%B0.svg"><link rel="canonical" href="https://amostian.github.io/posts/181607087/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>5.BlueStore | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">68</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">84</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">236</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/181607087/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">5.BlueStore</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-11-15 15:07:40" itemprop="dateCreated datePublished" datetime="2024-11-15T15:07:40+08:00">2024-11-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2025-02-27 10:15:34" itemprop="dateModified" datetime="2025-02-27T10:15:34+08:00">2025-02-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/" itemprop="url" rel="index"><span itemprop="name">Ceph</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">10.4k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>[TOC]</p><p>BlueStore 的主要任务是快速、安全地完成OSD的数据读写请求</p><ul><li>快速：<ul><li>尽可能简化数据读写过程中的操作</li><li>能适应近年出现的SSD、NVMe SSD、NVRAM等更快速的存储介质</li></ul></li><li>安全<ul><li>满足ACID定义的数据存储可靠性和一致性的要求，当意外情况发生，可将未完成的写事务完全写入或者完全撤销</li></ul></li></ul><p>BlueStore<strong>承载OSD发送过来的数据读写事务</strong>，可处理的事务由数据的读写操作与相关联的一些执行单元组成。BlueStore将事务中的操作解析出来，分解为：元数据操作、数据操作和日志操作，并按照一定的规则和顺序组织起来，确保事务的ACID特性</p><p>本质上，BlueStore是一种用户态、日志型与结构化相混合的文件系统，实现了数据结构定义、磁盘空间的划分与管理、数据缓存和元数据的管理功能。</p><p>一个最显著的特性是：BlueStore中元数据的数量大，对数据一致性和读写速度要求高</p><p>不作为单独的线程运行，运行在OSD线程内部。所以，数据传递、函数调用均在进程内完成，不涉及网络通信</p><span id="more"></span><h2 id="5-1-BlueStore对外接口"><a href="#5-1-BlueStore对外接口" class="headerlink" title="5.1 BlueStore对外接口"></a>5.1 BlueStore对外接口</h2><p>Ceph实现了诸如FileStore、Kstore和BlueStore等多种本地对象存储方案，这些后端存储均以 <code>ObjectStore</code> 为基类。通过 <code>ObjectStore</code> 类，对内适配不同的后端本地存储，对外提供统一的调用接口，屏蔽不同存储后端的差异。</p><p>不同存储后端的对外接口大多是重写 <code>ObjectStore</code> 中的函数。</p><p>接口功能分为 <strong>连接与设备管理</strong> 与 <strong>数据读写</strong> 两类</p><ul><li>连接与设备管理<ul><li><code>BlueStore::mount</code> ：设备挂载，在OSD启动时被调用</li><li><code>BlueStore::get_type</code> ：获得设备类型，OSD上层调用时，会返回 <code>&quot;bluestore&quot;</code> 字符串</li><li><code>BlueStore::exists</code> ：获得设备的存在状态</li><li><code>BlueStore::stat</code> ：获得设备状态</li><li><code>BlueStore::get_fsid</code> ：获得设备的fsid</li></ul></li><li>数据读写：<ul><li><code>BlueStore::queue_transactions</code> ：主要功能接口，统一的写入口，写操作均通过该接口将事务传递给本地存储</li><li><code>BlueStore::read</code> ：纯粹读操作不会被封装为事务，OSD上层直接调用该函数进行数据读操作</li><li><code>BlueStore::getattr</code> ：获取对象的属性，不会被封装为事务，OSD上层直接调用该函数</li><li><code>BlueStore::omap_get</code>：获取对象的OMAP</li></ul></li></ul><p>此外，在ObjectStore类中实现了向事务中添加事务执行单元的函数</p><h3 id="BlueStore中的对象"><a href="#BlueStore中的对象" class="headerlink" title="BlueStore中的对象"></a>BlueStore中的对象</h3><h4 id="对象在BlueStore中的表示与存储"><a href="#对象在BlueStore中的表示与存储" class="headerlink" title="对象在BlueStore中的表示与存储"></a>对象在BlueStore中的表示与存储</h4><blockquote><p>文件系统中，文件的元数据保存在 <strong>inode</strong>，内容数据存储在 <strong>磁盘块</strong></p></blockquote><p>在BlueStore中，RADOS对象的元数据表示为 <strong>onode</strong> ，对象实际数据存储在 <strong>磁盘块</strong></p><ul><li>元数据（包括OMAP）：实际存储在RocksDB数据库中，在程序运行时将其缓存在内存中</li><li>对象实际数据：存储在磁盘块中</li></ul><p>对象的 <code>onode</code> 信息和 <code>key</code> 保存在RocksDB数据库中，BlueStore通过 <code>key</code> 检索出 <code>onode</code> ，进而通过 <code>onode</code> 中记录的磁盘块地址信息和对象OMAP信息找到目标信息。</p><p><img src="/posts/181607087/对象在BlueStore中的描述.svg" alt="对象在BlueStore中的描述"></p><ul><li><p><code>onode</code> 中存储对象的元数据信息：包括对象大小、数据磁盘块地址信息、扩展属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Onode</span> &#123;</span><br><span class="line">    Collection *c;              <span class="comment">// 对应的Collection，对应PG</span></span><br><span class="line">    <span class="type">ghobject_t</span> oid;             <span class="comment">// Object id</span></span><br><span class="line">    <span class="type">bluestore_onode_t</span> onode;    <span class="comment">// (元数据)Object存到kv DB的元数据信息</span></span><br><span class="line">    ExtentMap extent_map;       <span class="comment">// (数据)映射pextents到blobs</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># src/os/bluestore/bluestore_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bluestore_onode_t</span> &#123;</span><br><span class="line">  <span class="type">uint64_t</span> nid = <span class="number">0</span>;                    <span class="comment">///&lt; numeric id (locally unique)</span></span><br><span class="line">  <span class="type">uint64_t</span> size = <span class="number">0</span>;                   <span class="comment">///&lt; 对象大小</span></span><br><span class="line">  map&lt;mempool::bluestore_cache_other::string, bufferptr&gt; attrs;        <span class="comment">///&lt; 扩展属性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">shard_info</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> offset = <span class="number">0</span>;  <span class="comment">///&lt; logical offset for start of shard</span></span><br><span class="line">    <span class="type">uint32_t</span> bytes = <span class="number">0</span>;   <span class="comment">///&lt; encoded bytes</span></span><br><span class="line">    <span class="built_in">DENC</span>(shard_info, v, p) &#123;</span><br><span class="line">      <span class="built_in">denc_varint</span>(v.offset, p);</span><br><span class="line">      <span class="built_in">denc_varint</span>(v.bytes, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dump</span><span class="params">(Formatter *f)</span> <span class="type">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  vector&lt;shard_info&gt; extent_map_shards; <span class="comment">///&lt; 数据磁盘块地址信息</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> expected_object_size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> expected_write_size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> alloc_hint_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> flags = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>BlueStore使用 <code>key</code> 访问 <code>onode</code> 中的信息</p><ul><li><p><code>key</code> 的形成：使用纠删码标识需要、所属池ID二进制翻转后的对象名hash值、命名空间（普通对象一般为空）等信息编码为 <code>key</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * object name key structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * encoded u8: shard + 2^7 (so that it sorts properly)</span></span><br><span class="line"><span class="comment"> * encoded u64: poolid + 2^63 (so that it sorts properly)</span></span><br><span class="line"><span class="comment"> * encoded u32: hash (bit reversed)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * escaped string: namespace</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * escaped string: key or object name</span></span><br><span class="line"><span class="comment"> * 1 char: &#x27;&lt;&#x27;, &#x27;=&#x27;, or &#x27;&gt;&#x27;.  if =, then object key == object name, and</span></span><br><span class="line"><span class="comment"> *         we are done.  otherwise, we are followed by the object name.</span></span><br><span class="line"><span class="comment"> * escaped string: object name (unless &#x27;=&#x27; above)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * encoded u64: snap</span></span><br><span class="line"><span class="comment"> * encoded u64: generation</span></span><br><span class="line"><span class="comment"> * &#x27;o&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>key</code> 可以解码出对象的 <code>ghobject_t</code> 结构信息</p></li></ul></li></ul><h4 id="对象在BlueStore中的组织方式"><a href="#对象在BlueStore中的组织方式" class="headerlink" title="对象在BlueStore中的组织方式"></a>对象在BlueStore中的组织方式</h4><p>对象在BLuyeStore中没有目录层级改变，所有对象平铺在BlueStore中，</p><p><code>key</code> 中编码了对象名的 hash信息，所以同一个存储池内的所有对象，可以按 <code>key</code> 值进行排序</p><p>通过对象的hash信息可以计算出对象所属的 PG ，可以很方便地遍历同一PG内的所有对象</p><ul><li>对象遍历用于数据恢复的BackFill操作、OSD启动检查等情形</li></ul><h2 id="5-2-BlueStore组件"><a href="#5-2-BlueStore组件" class="headerlink" title="5.2 BlueStore组件"></a>5.2 BlueStore组件</h2><blockquote><p>BlueStore承载的数据大体上分为数据和元数据两种</p><ul><li>元数据：对象的属性、扩展OMAP属性、日志数据、BlueStore的元数据</li></ul><p>其中，元数据使用KV数据库——RocksDB存储，内容数据以DIO模式通过BlockDevice组件在用户态直接存储在硬盘上</p></blockquote><p>查看BlueStore的关键组件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlueStore</span> : <span class="keyword">public</span> ObjectStore, <span class="keyword">public</span> <span class="type">md_config_obs_t</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// --------------------------------------------------------</span></span><br><span class="line">  	<span class="comment">// members</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">  		BlueFS *bluefs = <span class="literal">nullptr</span>;</span><br><span class="line">  		<span class="type">unsigned</span> bluefs_shared_bdev = <span class="number">0</span>;  <span class="comment">///&lt; which bluefs bdev we are sharing</span></span><br><span class="line">  		<span class="type">bool</span> bluefs_single_shared_device = <span class="literal">true</span>;</span><br><span class="line">  		<span class="type">utime_t</span> bluefs_last_balance;</span><br><span class="line">  		<span class="type">utime_t</span> next_dump_on_bluefs_balance_failure;</span><br><span class="line"></span><br><span class="line">  		KeyValueDB *db = <span class="literal">nullptr</span>;</span><br><span class="line">  		BlockDevice *bdev = <span class="literal">nullptr</span>;</span><br><span class="line">  		std::string freelist_type;</span><br><span class="line">  		FreelistManager *fm = <span class="literal">nullptr</span>;</span><br><span class="line">  		Allocator *alloc = <span class="literal">nullptr</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> BlueStore::_open_db(<span class="type">bool</span> create)&#123;</span><br><span class="line">        ...</span><br><span class="line">        rocksdb::Env *a = <span class="keyword">new</span> <span class="built_in">BlueRocksEnv</span>(bluefs);</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/181607087/ceph-bluestore-arch.png" alt="ceph-bluestore-arch"></p><ul><li>Ceph为提高效率，为RocksDB设计了日志型文件系统BlueFS，支撑RocksDB数据库文件的管理功能，BlueFS通过BlockDevice以DIO模式访问磁盘</li></ul><h3 id="5-2-1-RocksDB——BlueStore的元数据的管理"><a href="#5-2-1-RocksDB——BlueStore的元数据的管理" class="headerlink" title="5.2.1 RocksDB——BlueStore的元数据的管理"></a>5.2.1 RocksDB——BlueStore的元数据的管理</h3><p>RocksDB功能：</p><ul><li><strong>承载了BlueStore的所有元数据</strong>，对BlueStore性能有关键影响</li><li><strong>BlueStore事务特性的实现</strong>构建在RocksDB基础上</li></ul><blockquote><p>RocksDB基于LevelDB开发，兼容后者，是KV键值数据库</p></blockquote><p>RocksDB是<strong>键值数据库</strong>，以 <code>key-value</code> 键值对的方式存储数据</p><ul><li>每个key对应唯一的value</li><li>键值可以是任意字节流，但太大会影响性能</li><li>常见操作包括 <code>Get(key)</code> 、<code>put(key)</code> 、<code>delete(key)</code> 、<code>scan(key)</code></li></ul><h4 id="RocksDB的元数据组织方式"><a href="#RocksDB的元数据组织方式" class="headerlink" title="RocksDB的元数据组织方式"></a>RocksDB的元数据组织方式</h4><p>为提高元数据检索速度，BlueStore使用RocksDB的前缀模式</p><blockquote><p>前缀模式：在 <code>key</code> 前假一个前缀，实现 <code>key</code> 的分类和快速定位</p><p>BlueStore定义的前缀包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.cc</span></span><br><span class="line"><span class="comment">// kv store prefixes</span></span><br><span class="line"><span class="type">const</span> string PREFIX_SUPER = <span class="string">&quot;S&quot;</span>;   <span class="comment">// 表示超块信息的key field -&gt; value</span></span><br><span class="line"><span class="type">const</span> string PREFIX_STAT = <span class="string">&quot;T&quot;</span>;    <span class="comment">// field -&gt; value(int64 array)</span></span><br><span class="line"><span class="type">const</span> string PREFIX_COLL = <span class="string">&quot;C&quot;</span>;    <span class="comment">// collection name -&gt; cnode_t</span></span><br><span class="line"><span class="type">const</span> string PREFIX_OBJ = <span class="string">&quot;O&quot;</span>;     <span class="comment">// 表示对象名的key object name -&gt; onode_t</span></span><br><span class="line"><span class="type">const</span> string PREFIX_OMAP = <span class="string">&quot;M&quot;</span>;    <span class="comment">// 表示元数据OMAP的ket u64 + keyname -&gt; value</span></span><br><span class="line"><span class="type">const</span> string PREFIX_DEFERRED = <span class="string">&quot;L&quot;</span>;  <span class="comment">// 表示延迟写日志的key  id -&gt; deferred_transaction_t</span></span><br><span class="line"><span class="type">const</span> string PREFIX_ALLOC = <span class="string">&quot;B&quot;</span>;   <span class="comment">// 表示块分配的信息 u64 offset -&gt; u64 length (freelist)</span></span><br><span class="line"><span class="type">const</span> string PREFIX_SHARED_BLOB = <span class="string">&quot;X&quot;</span>; <span class="comment">// u64 offset -&gt; shared_blob_t</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="RocksDB的写"><a href="#RocksDB的写" class="headerlink" title="RocksDB的写"></a>RocksDB的写</h4><blockquote><p>RocksDB采用 <strong>预写日志</strong> 的方式保存数据：先将数据存放在以 <code>.log</code> 为扩展名的日志文件中，后续再将数据行按格式写入以 <code>.sst</code> 为扩展名的数据文件。</p><ul><li>因此，日志文件的I/O速率对RocksDB的效能有直接影响，所以BlueStore为RocksDB配置专门的高速存储介质</li></ul></blockquote><p>RocksDB支持原子读和写，用于支持事务的ACID特性，元数据的写入也采用了原子写</p><p>写数据分三种模式：普通写，原子写和事务写</p><p>BlueStore在处理事务时使用了RocksDB的原子写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RocksDB_Transaction_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	DB *db;</span><br><span class="line">    std::string DbPath = <span class="string">&quot;/tmp/rocksdb&quot;</span>;</span><br><span class="line">    Options options;</span><br><span class="line">    Status s = DB::<span class="built_in">Open</span>(options, DbPath, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(s.<span class="built_in">ok</span>());</span><br><span class="line">    </span><br><span class="line">    rocksdb::WriteBatch batch;	<span class="comment">//定义批处理</span></span><br><span class="line">    batch.<span class="built_in">Put</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);	<span class="comment">//向批处理中添加数据</span></span><br><span class="line">    batch.<span class="built_in">Put</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);	<span class="comment">//向批处理中添加数据</span></span><br><span class="line">    s = db-&gt;<span class="built_in">Write</span>(rocksdb::WriteOptions, &amp;batch);	<span class="comment">//提交批处理任务</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert</span>(s.<span class="built_in">ok</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原子写批处理先将相关操作请求填入 RocksDB批处理变量，再提交批处理以向RocksDB进行原子写入，并根据返回的结果判断是否成功完成。</p><h4 id="RocksDB的创建"><a href="#RocksDB的创建" class="headerlink" title="RocksDB的创建"></a>RocksDB的创建</h4><p>由于RocksDB的运行数据与内容数据均以文件形式保存，所以RocksDB需要由文件系统支撑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.cc</span></span><br><span class="line"><span class="type">int</span> BlueStore::_open_db(<span class="type">bool</span> create)&#123;</span><br><span class="line">    <span class="comment">// 获取kv的后端设备</span></span><br><span class="line">    string kv_backend;</span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        kv_backend = cct-&gt;_conf-&gt;bluestore_kvbackend;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = <span class="built_in">read_meta</span>(<span class="string">&quot;kv_backend&quot;</span>, &amp;kv_backend);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mkfs也会调用这里，create时候根据配置做bluefs的创建</span></span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        do_bluefs = cct-&gt;_conf-&gt;bluestore_bluefs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        string s;</span><br><span class="line">        r = <span class="built_in">read_meta</span>(<span class="string">&quot;bluefs&quot;</span>, &amp;s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rocksdb::Env *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 创建bluefs</span></span><br><span class="line">    <span class="keyword">if</span> (do_bluefs) &#123;</span><br><span class="line">        bluefs = <span class="keyword">new</span> <span class="built_in">BlueFS</span>(cct);</span><br><span class="line">        bfn = path + <span class="string">&quot;/block.db&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (::<span class="built_in">stat</span>(bfn.<span class="built_in">c_str</span>(), &amp;st) == <span class="number">0</span>) &#123;</span><br><span class="line">        	r = bluefs-&gt;<span class="built_in">add_block_device</span>(BlueFS::BDEV_DB, bfn);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// shared device</span></span><br><span class="line">        bfn = path + <span class="string">&quot;/block&quot;</span>;</span><br><span class="line">        r = bluefs-&gt;<span class="built_in">add_block_device</span>(bluefs_shared_bdev, bfn);</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        bfn = path + <span class="string">&quot;/block.wal&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (::<span class="built_in">stat</span>(bfn.<span class="built_in">c_str</span>(), &amp;st) == <span class="number">0</span>) &#123;</span><br><span class="line">      		r = bluefs-&gt;<span class="built_in">add_block_device</span>(BlueFS::BDEV_WAL, bfn);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建RocksDB</span></span><br><span class="line">    db = KeyValueDB::<span class="built_in">create</span>(cct,</span><br><span class="line">			  kv_backend,</span><br><span class="line">			  fn,</span><br><span class="line">			  <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(env));</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RocksDB的文件"><a href="#RocksDB的文件" class="headerlink" title="RocksDB的文件"></a>RocksDB的文件</h4><ul><li><p>以 <code>.log</code> 、<code>.sst</code> 、<code>.dbtmp</code> 为扩展名的文件</p><p>其中，log文件存放预写数据的日志，sst存放落盘的数据</p></li><li><p>以 <code>MANIFEST</code> 、<code>OPTIONS</code> 为前缀的文件</p></li><li><p>以 <code>CURRENT</code> 、<code>IDENTITY</code> 、<code>LOCK</code> 为名的文件</p></li></ul><h3 id="5-2-2-BlueFS"><a href="#5-2-2-BlueFS" class="headerlink" title="5.2.2 BlueFS"></a>5.2.2 BlueFS</h3><p>BlueStore为RocksDB定制的文件系统，提供其所需的文件数据存储、目录操作等基本功能，只实现了 <code>BlueRocksEnv</code> 需要的API接口</p><ul><li>RocksDB对文件写采用追加写方式，因此只需要BlueFS提供追加写并不需要随机写接口</li></ul><p>BlueFS与BlueStore通过 <code>BlockDevice</code> 模块对硬盘进行操作</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>日志型文件系统</strong></p><p>元数据操作以日志形式存入硬盘特定位置</p><p>磁盘空间信息、文件索引节点等文件系统元数据信息在启动时回放日志得到</p><p><strong>具有跨设备构建自身文件系统的能力</strong></p><p>BlueFS可单独构建在速度较快的SSD设备上</p><p>BlueFS仅用以支撑RocksDB，大多数情况BlueStore是不可见的，但当其磁盘空间不足时，可以向BlueStore借用部分存储空间。即使二者不在同一硬盘，BlueFS也可以跨设备借用（BlueFS的磁盘地址结构引入了设备标号，不同设备的磁盘块组成统一的逻辑地址空间）</p><ul><li>在L版，BlueFS与BlueStore空间使用情况的检测是周期性的，后续版本中，实时监控二者空间的使用情况</li></ul><h4 id="文件索引与磁盘地址结构"><a href="#文件索引与磁盘地址结构" class="headerlink" title="文件索引与磁盘地址结构"></a>文件索引与磁盘地址结构</h4><p>在BlueFS中，从文件索引可以直接磁盘寻址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/bluefs_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bluefs_fnode_t</span> &#123;</span><br><span class="line">  <span class="type">uint64_t</span> ino;		<span class="comment">//文件标识</span></span><br><span class="line">  <span class="type">uint64_t</span> size;	<span class="comment">//文件大小</span></span><br><span class="line">  <span class="type">utime_t</span> mtime;	<span class="comment">//文件修改时间 </span></span><br><span class="line">  <span class="type">uint8_t</span> prefer_bdev;	<span class="comment">//文件优先使用的设备，WAL-&gt;DB-&gt;DATA</span></span><br><span class="line">  mempool::bluefs::vector&lt;<span class="type">bluefs_extent_t</span>&gt; extents;	<span class="comment">//	磁盘地址集合</span></span><br><span class="line">  <span class="type">uint64_t</span> allocated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bluefs_extent_t</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">uint8_t</span> bdev;		<span class="comment">//地址段所在的设备</span></span><br><span class="line">  <span class="type">uint64_t</span> offset = <span class="number">0</span>;	<span class="comment">//设备上的物理地址</span></span><br><span class="line">  <span class="type">uint32_t</span> length = <span class="number">0</span>;	<span class="comment">// 数据空间长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>bdev</code> 的取值：</p><p>BLueStore整体上可以使用3块硬盘设备，超高速设备存储 RocksDB的 <code>.log</code> 文件，高速设备优先存储RocksDB的其他数据</p><p>这些功能的实现与 bdev 字段相关</p></li></ul><h4 id="基于日志的元数据管理"><a href="#基于日志的元数据管理" class="headerlink" title="基于日志的元数据管理"></a>基于日志的元数据管理</h4><p>BlueFS除文件内容数据写入磁盘，其他数据均以日志形式记录在专门的日志文件</p><ul><li><p>文件目录结构、磁盘空间分配器等元数据在BlueFS启动时通过回放日志生成，并常驻内存</p><ul><li><p>磁盘空间分配管理：BlueFS使用多个模板向量记录空间列表、总空间大小、待释放空间等，使用Allocator管理磁盘空间的增加和移除。</p><p>这些结构在BlueFS启动时，通过回放日志赋值，存放于内存不会落盘存储，且在运行过程中动态更新。</p></li><li><p>目录与文件映射关系管理：使用 <code>dir_map</code> 和 <code>file_map</code> 两个内存表格管理文件与目录映射关系。通过这两个表格实现文件与目录创建和删除过程中的元数据管理</p><p>dir_map 实现目录名与文件名及文件fnode的关系映射</p><p>file_map 实现文件 <code>fnode.ino</code> 与 <code>fnode</code> 的关系映射</p><p>这两个表格在BlueFS重放日志时构建，并常驻内存</p></li></ul></li></ul><h5 id="superblock结构"><a href="#superblock结构" class="headerlink" title="superblock结构"></a>superblock结构</h5><blockquote><p>超块是一个地址被硬编码的磁盘块，位于磁盘设备的第二个磁盘块（一般为第2个4KB空间，其实地址为4KB(0x1000)，长度为4KB）</p></blockquote><p>BlueFS日志文件的头部存储在磁盘固定的超块(superblock)中，BlueFS启动时直接到固定位置读取日志文件的 <code>fnode</code> 结构，然后读取日志文件内容并进行回放</p><ul><li><p>超块中保存了 <strong>磁盘块大小</strong> 、版本号、uuid、osduuid及 <strong>日志文件的元数据</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/bluefs_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bluefs_super_t</span> &#123;</span><br><span class="line">  uuid_d uuid;      <span class="comment">///&lt; unique to this bluefs instance</span></span><br><span class="line">  uuid_d osd_uuid;  <span class="comment">///&lt; matches the osd that owns us</span></span><br><span class="line">  <span class="type">uint64_t</span> version;</span><br><span class="line">  <span class="type">uint32_t</span> block_size;</span><br><span class="line"></span><br><span class="line">  <span class="type">bluefs_fnode_t</span> log_fnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日志文件元数据保存信息：<strong>存储日志文件内容的磁盘编号</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bluefs_fnode_t</span> &#123;</span><br><span class="line">    <span class="comment">// 存储日志文件内容的磁盘</span></span><br><span class="line">  	<span class="type">uint64_t</span> ino;	<span class="comment">//文件id</span></span><br><span class="line">  	<span class="type">uint8_t</span> prefer_bdev;</span><br><span class="line">    <span class="comment">// 日志文件内容所在磁盘地址信息</span></span><br><span class="line">  	mempool::bluefs::vector&lt;<span class="type">bluefs_extent_t</span>&gt; extents;</span><br><span class="line">    <span class="type">uint64_t</span> size;</span><br><span class="line">  	<span class="type">utime_t</span> mtime;</span><br><span class="line">  	<span class="type">uint64_t</span> allocated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>示例</strong></p><p>使用 <code>dd if=/dev/ceph-dbpool/osd0.db of=/home/test13 bs=8K count=1</code> 导出并查看前8K内容</p><p><img src="/posts/181607087/image-20241116202733750.png" alt="image-20241116202733750"></p><p><code>log_fnode</code> 从 <em>0x1032</em> 开始，<code>log_fnode.extent</code> 中保存了日志文件的硬件地址信息</p><ul><li><code>extent.offset</code> 在硬盘上小端存储，所以内容为 <em>0x00 00 02 73</em> ，又由于采用LBA编码，所以实际内容为 <em>0x4E 00 00 0</em></li><li><code>extent.length</code> 也采用了类似的编码方式，实际内容为 <em>0x10 00 00</em></li><li><code>extent.bdev</code> 表示设备编号</li></ul><p>所以上述超块中，<code>extent1</code> 表明BlueFS日志文件的第一块存储空间位于第一块硬盘的 <em>0x4E 00 00 0</em> 地址处，空间大小为 <em>0x10 00 00</em></p><h5 id="日志文件与操作日志"><a href="#日志文件与操作日志" class="headerlink" title="日志文件与操作日志"></a>日志文件与操作日志</h5><p>BlueFS将对文件与目录等元数据的操作记录在日志文件中，</p><p>实质上，将多条日志记录整合为事务，每个事务按“磁盘块大小对齐”的方式存放，BlueFS事务定义为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/bluefs_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bluefs_transaction_t</span> &#123;</span><br><span class="line">    uuid_d uuid;          <span class="comment">///&lt; 与超块中的uuid对应</span></span><br><span class="line">  	<span class="type">uint64_t</span> seq;         <span class="comment">///&lt; 事务序号</span></span><br><span class="line">  	bufferlist op_bl;     <span class="comment">///&lt; 事务内的操作，由操作码和操作参数组成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务中的操作 <code>op_bl</code> 由操作码与操作参数组成，</p><div class="table-container"><table><thead><tr><th>OP_NONE</th><th>空操作</th></tr></thead><tbody><tr><td>操作名称</td><td>含义</td></tr><tr><td>OP_INIT</td><td>BlueFS初始化或日志文件整理压缩时使用</td></tr><tr><td>OP_ALLOC_ADD(id, offset, length)</td><td>添加磁盘块extent给BlueFS</td></tr><tr><td>OP_ALLOC_RM(id, offset, length)</td><td>从BlueFS中移除磁盘块extent</td></tr><tr><td>OP_DIR_LINK(dirname,filename, ino)</td><td>为文件分配目录</td></tr><tr><td>OP_DIR_UNLINK(dirname,filename)</td><td>将文件从目录中移除</td></tr><tr><td>OP_DIR_CREATE(dirname)</td><td>创建目录</td></tr><tr><td>OP_DIR_ REMOVE(dirname)</td><td>删除目录</td></tr><tr><td>OP_FILE_UPDATE(fnode)</td><td>更新文件的元数据fnode</td></tr><tr><td>OP_FILE_REMOVE</td><td>删除文件</td></tr><tr><td>OP_JUMP(next_seq, offset)</td><td>跳过事务编号或跳过磁盘块内的偏移</td></tr><tr><td>OP_JUMP_SEQ(next_seq)</td><td>跳过事务编号，在重放日志时使用</td></tr></tbody></table></div><h5 id="超块与BlueFS日志文件及事务内容的对应关系"><a href="#超块与BlueFS日志文件及事务内容的对应关系" class="headerlink" title="超块与BlueFS日志文件及事务内容的对应关系"></a>超块与BlueFS日志文件及事务内容的对应关系</h5><p>超块中的 <code>log_fnode.extent</code> 记录了日志文件的磁盘地址，读取日志文件内容，事务落盘结构除 <code>op_bl</code> 外，还需要额外的辅助信息</p><ul><li>uuid必须与超块的uuid一致</li><li>在BlueFS挂载时，使用CRC校验码对本事务的数据进行校验</li><li>op_bl中的操作码与操作参数按序排列，操作参数原文存储，不经过编码</li></ul><p><img src="/posts/181607087/image-20241116214142224.png" alt="image-20241116214142224"></p><p>随运行时间增长，BlueFS的日志内容会持续增加，其所占用磁盘空间也会越来越大，因此，BlueFS实现了日志压缩功能</p><h3 id="5-2-3-BlueStore对磁盘空间的管理"><a href="#5-2-3-BlueStore对磁盘空间的管理" class="headerlink" title="5.2.3 BlueStore对磁盘空间的管理"></a>5.2.3 BlueStore对磁盘空间的管理</h3><p>BlueStore将硬盘分为三类，分别是超高速设备（WAL空间）、高速设备（DB空间）和慢速设备（DATA空间）</p><ul><li>超高速设备优先存储RocksDB的 <code>.log</code> 文件</li><li>高速设备存储RocksDB承载的数据，即BlueStore的元数据</li><li>慢速设备存储对象的内容数据</li></ul><h4 id="与BlueFS关系"><a href="#与BlueFS关系" class="headerlink" title="与BlueFS关系"></a>与BlueFS关系</h4><p>存储对象元数据及RocksDB的 <em>.log</em> 文件由BlueFS管理，存储对象内容数据的空间由BlueStore直接管理</p><p>BLueFS可用的空间不足时，由于其具有 <strong>跨设备构建文件系统</strong> 的特点，可以向BlueStore借用一部分空间，当BlueFS空间占用率下降后，归还借用的空间</p><h4 id="BlueStore磁盘空间的地址结构"><a href="#BlueStore磁盘空间的地址结构" class="headerlink" title="BlueStore磁盘空间的地址结构"></a>BlueStore磁盘空间的地址结构</h4><p><img src="/posts/181607087/BlueStore的地址结构.svg" alt="BlueStore的地址结构"></p><p><img src="/posts/181607087/bluestore-object-blob-disk-arch.jpg" alt="bluestore-object-blob-disk-arch"></p><p>BlueStore使用 <code>bluestore_pextent_t</code> 描述磁盘地址，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/blue_types.h</span></span><br><span class="line"><span class="comment">/// pextent: physical extent</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bluestore_pextent_t</span> : <span class="keyword">public</span> <span class="type">bluestore_interval_t</span>&lt;<span class="type">uint64_t</span>, <span class="type">uint32_t</span>&gt; &#123;</span><br><span class="line">	OFFS_TYPE offset = <span class="number">0</span>;	<span class="comment">//硬盘上的物理偏移量，要块大小对齐</span></span><br><span class="line">    LEN_TYPE length = <span class="number">0</span>;	<span class="comment">//数据长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BlueStore的数据读写需要一段连续的硬盘空间， <code>bluestore_pextent.offset</code> 作为这段空间的起始地址，<code>bluestore_pextent.length</code> 为这段空间的长度</li></ul><p>为实现数据校验、数据压缩等功能，将多个 <code>bluestore_pextent_t</code> 组合为数据结构 <code>blob</code> ，并在 <code>blob</code> 中添加了数据压缩标志、数据校验位</p><ul><li>Blob里的pextent个数最多为：max_blob_size / min_alloc_size；</li><li>多个pextent映射的Blob offset可能不连续，中间有空洞；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#src/os/bluestore</span></span><br><span class="line"><span class="keyword">typedef</span> mempool::bluestore_cache_other::vector&lt;<span class="type">bluestore_pextent_t</span>&gt; PExtentVector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// blob: a piece of data on disk</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bluestore_blob_t</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//向量容器将多个bluestore_pextent_t组合为blob</span></span><br><span class="line">  	PExtentVector extents;              <span class="comment">///&lt; 磁盘上的一组数据段</span></span><br><span class="line">    <span class="type">uint32_t</span> logical_length = <span class="number">0</span>;    <span class="comment">// blob的原始数据长度</span></span><br><span class="line">    bufferptr csum_data;                <span class="comment">///数据校验基于blob实现，存放于RocksDB数据库中</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int16_t</span> id = <span class="number">-1</span>;</span><br><span class="line">    SharedBlobRef shared_blob;      <span class="comment">// 共享的blob状态</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bluestore_blob_t</span> blob;  <span class="comment">///&lt; decoded blob metadata</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> boost::intrusive_ptr&lt;Blob&gt; BlobRef;</span><br></pre></td></tr></table></figure><p><code>bluestore_pextent_t</code> 和 <code>blob</code> 都可用于描述磁盘上的物理数据块</p><p>一个 <code>extent</code> 结构关联一个 <code>blob</code> 结构，用于将对象内部的逻辑空间与物理数据块关联起来</p><p>在 <code>extent</code> 结构内增加了对象内部的逻辑地址字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Extent</span> : <span class="keyword">public</span> ExtentBase &#123;</span><br><span class="line">    <span class="built_in">MEMPOOL_CLASS_HELPERS</span>();</span><br><span class="line">    <span class="type">uint32_t</span> logical_offset = <span class="number">0</span>;      <span class="comment">///逻辑地址，对象内的逻辑起始地址</span></span><br><span class="line">    <span class="comment">///当逻辑地址非块大小对齐时，用于定位数据在blob内的偏移</span></span><br><span class="line">    <span class="type">uint32_t</span> blob_offset = <span class="number">0</span>;         </span><br><span class="line">    <span class="type">uint32_t</span> length = <span class="number">0</span>;              <span class="comment">///&lt; length</span></span><br><span class="line">    <span class="comment">//blob的引用指针，一个extent关联一个blob</span></span><br><span class="line">    BlobRef  blob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> boost::intrusive::set&lt;Extent&gt; <span class="type">extent_map_t</span>;</span><br></pre></td></tr></table></figure><p>如果对象较大，需要多个 <code>extent</code> 组合成 <code>extent_map</code> ，保存在KB数据库中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExtentMap</span> &#123;</span><br><span class="line">    Onode *onode;                   <span class="comment">// 指向Onode指针</span></span><br><span class="line">    <span class="type">extent_map_t</span> extent_map;        <span class="comment">// Extents到Blobs的map</span></span><br><span class="line">    <span class="type">blob_map_t</span> spanning_blob_map;   <span class="comment">// 跨越shards的blobs</span></span><br><span class="line"> 	</span><br><span class="line">    # ExtentMap还提供了分片功能,防止在文件碎片化严重，会随着写入数据的变化而变化；连续小段会合并为大；</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Shard</span> &#123;</span><br><span class="line">        <span class="type">bluestore_onode_t</span>::shard_info *shard_info = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">unsigned</span> extents = <span class="number">0</span>;  <span class="comment">///&lt; count extents in this shard</span></span><br><span class="line">        <span class="type">bool</span> loaded = <span class="literal">false</span>;   <span class="comment">///&lt; true if shard is loaded</span></span><br><span class="line">        <span class="type">bool</span> dirty = <span class="literal">false</span>;    <span class="comment">///&lt; true if shard is dirty and needs reencoding</span></span><br><span class="line">    &#125;;</span><br><span class="line">     mempool::bluestore_cache_other::vector&lt;Shard&gt; shards;    <span class="comment">///&lt; shards</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BlueStore对 <code>extent_map</code> 编码后，将其分片保存在KV数据库中，访问这些信息的 <code>key</code> 值是 <code>extent_map_shards</code></p><p><code>extent_map_shards</code> 直接存储在对象的 <code>onode</code> 中</p><p>因此，通过 <code>extent_map_shards</code> 到RocksDB数据库中检索需要的 <code>extent_map</code> 具体分片，然后再依次向下查找 <code>extent</code> 、<code>blob</code> 、<code>bluestore_pextent_t</code> ，并从 <code>bluestore_pextent_t</code> 中找到最终的物理硬盘地址</p><h4 id="磁盘空间的缓存"><a href="#磁盘空间的缓存" class="headerlink" title="磁盘空间的缓存"></a>磁盘空间的缓存</h4><blockquote><p>由于BlueStore使用DIO模式进行硬盘数据读写，不经过操作系统内核缓存，所以对于读数据，也不能使用内核态的缓存</p></blockquote><p>BlueStore在用户态实现了缓存功能，主要用于读缓存，缓存对象是 <code>onode</code></p><p>在BlueStore读取数据时，程序先到缓存空间中查找数据，若没有命中，再到数据库或硬盘中读取数据</p><p>写操作不适用缓存</p><h4 id="硬盘空间分配器"><a href="#硬盘空间分配器" class="headerlink" title="硬盘空间分配器"></a>硬盘空间分配器</h4><p>BLueStore使用 <strong>Allocator</strong> 管理已分配磁盘空间的管理，使用 <strong>FreelistManager</strong> 进行未分配的空闲空间管理</p><p>BlueStore的blob分配器，支持如下几种：</p><ul><li>BitmapAllocator</li><li>StupidAllocator</li><li>…</li></ul><p>默认使用的 FreelistManager 是：BitmapFreelistManager</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> BlueStore::_open_fm(<span class="type">bool</span> create)&#123;</span><br><span class="line">    fm = FreelistManager::<span class="built_in">create</span>(cct, freelist_type, db, PREFIX_ALLOC);</span><br><span class="line">    <span class="type">int</span> r = fm-&gt;<span class="built_in">init</span>(bdev-&gt;<span class="built_in">get_size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-4-BlockDevice——BlueStore的数据I-O方式"><a href="#5-2-4-BlockDevice——BlueStore的数据I-O方式" class="headerlink" title="5.2.4 BlockDevice——BlueStore的数据I/O方式"></a>5.2.4 BlockDevice——BlueStore的数据I/O方式</h3><p>BlueStore将内容数据直接存储在磁盘块，即 <strong>BlueStore直接管理硬盘裸设备</strong></p><p>在 <code>_open_dev</code> 中完成初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> BlueStore::_open_bdev(<span class="type">bool</span> create)&#123;</span><br><span class="line">    string p = path + <span class="string">&quot;/block&quot;</span>;</span><br><span class="line">    bdev = BlockDevice::<span class="built_in">create</span>(cct, p, aio_cb, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    <span class="type">int</span> r = bdev-&gt;<span class="built_in">open</span>(p);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (bdev-&gt;<span class="built_in">supported_bdev_label</span>()) &#123;</span><br><span class="line">        r = _check_or_set_bdev_label(p, bdev-&gt;<span class="built_in">get_size</span>(), <span class="string">&quot;main&quot;</span>, create);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// initialize global block parameters</span></span><br><span class="line">    block_size = bdev-&gt;<span class="built_in">get_block_size</span>();</span><br><span class="line">    block_mask = ~(block_size - <span class="number">1</span>);</span><br><span class="line">    block_size_order = <span class="built_in">ctz</span>(block_size);</span><br><span class="line">     </span><br><span class="line">    r = _set_cache_sizes();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持三种类型的设备</p><p><img src="/posts/181607087/BlockDevice.svg" alt="BlockDevice"></p><ul><li><p>KernelDevice：SATA、SCSI、LVM等大多数设备</p><p>通过Direct I/O 与异步 I/O 配合的方式操作这类设备</p></li><li><p>NVMEDevice：以PCIe为物理接口，以NVMe为上层协议的快速固态硬盘</p><p>通过SPDK用户态驱动操作这类设备</p></li><li><p>PMEMDevice</p></li></ul><p>其中前两种目前最常用</p><h4 id="Direct-I-O和-异步I-O控制KernelDevice类型的硬盘设备"><a href="#Direct-I-O和-异步I-O控制KernelDevice类型的硬盘设备" class="headerlink" title="Direct I/O和 异步I/O控制KernelDevice类型的硬盘设备"></a>Direct I/O和 异步I/O控制KernelDevice类型的硬盘设备</h4><h5 id="Direct-I-O"><a href="#Direct-I-O" class="headerlink" title="Direct I/O"></a>Direct I/O</h5><p>Linux操作系统为文件系统对硬盘设备的读写提供了两种接口：</p><ul><li><p>Buffered I/O</p><p>在数据读写时，先将数据缓存在内核Cache中，然后将数据从内核空间复制到用户态的应用程序进程空间</p><ul><li>广泛应用于普通文件系统，由于FileStore基于文件系统构建，所以也用到了这种方式</li></ul></li><li><p>Direct I/O</p><p>直接进行磁盘数据读写，中间不经过内核缓存</p></li></ul><p>BlueStore使用Direct I/O，将数据在硬盘与BlueStore所在的OSD进程空间中直接传输，避免了内核缓存</p><ul><li>BlueStore中的缓存由自身在用户态实现，减少IO路径，降低CPU开销</li></ul><p><strong>实现</strong> ：Linux采用一切皆文件，所以通过文件打开函数 <code>open()</code> 以 Direct I/O打开设备</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/KernelDevice.cc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KernelDevice::open</span><span class="params">(<span class="type">const</span> string&amp; p)</span></span>&#123;</span><br><span class="line">  path = p;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dout</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; path &quot;</span> &lt;&lt; path &lt;&lt; dendl;</span><br><span class="line">	<span class="comment">//::全局作用域运算符，表示全局命名空间中的 open 函数</span></span><br><span class="line">  fd_direct = ::<span class="built_in">open</span>(path.<span class="built_in">c_str</span>(), O_RDWR | O_DIRECT | O_CLOEXEC);</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">//作为对比，buffered I/O不需要指定标志位</span></span><br><span class="line">  fd_buffered = ::<span class="built_in">open</span>(path.<span class="built_in">c_str</span>(), O_RDWR | O_CLOEXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对数据块的要求</strong></p><p>采用 Direct I/O 时，读写数据的长度和偏移需要和设备的逻辑块大小对齐，一般为 4KB。</p><p>对于超过逻辑块大小的数据，将数据分为首、尾和中间部分。中间部分严格的块对齐，非块大小对齐的首、尾部分进行特殊处理</p><h5 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h5><p><strong>同步I/O 与异步I/O的区别</strong></p><ul><li><p>同步 I/O 在写入数据时，需要数据写入硬盘或内核缓存后才返回</p></li><li><p>异步I/O在提交写请求的同时，提供本次操作的上下文。提交写请求后立即返回，然后监视写操作完成时间，收到写完成事件后，根据操作的上下文识别对应的写操作，然后调用相应的回调函数，确认写操作完成</p><p>对于监视任务，BlueStore采用一个专门的线程轮询查询事件的状态</p></li></ul><p><strong>BlueStore采用异步I/O</strong></p><p>由于磁盘与应用程序进程空间的数据传输不经过内核缓存，所以数据量一般比较大，采用同步 I/O 模型易造成程序阻塞，BlueStore将 Direct I/O与操作系统的异步I/O一起使用</p><blockquote><p>BlueStore使用操作系统提供的 <code>libaio</code> 库发起异步 I/O 请求</p><ul><li><p><code>libaio</code> 依赖于 Linux 内核的异步 I/O 支持。内核提供了系统调用接口（如 <code>io_setup</code>、<code>io_submit</code>、<code>io_getevents</code> 和 <code>io_destroy</code>），这些接口由内核实现，并被 <code>libaio</code> 调用，实现了异步 I/O 操作。</p></li><li><p>libaio提供的五个主要API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_setup</span><span class="params">(<span class="type">int</span> max_events, <span class="type">io_context_t</span> *ctxp)</span></span>; <span class="comment">//创建异步I/O上下文</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_destroy</span><span class="params">(<span class="type">io_context_t</span> ctx)</span></span>;			<span class="comment">//摧毁异步I/O上下文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aio_submit</span><span class="params">(<span class="type">io_context_t</span> ctx, <span class="type">long</span> nr, )</span>	<span class="comment">//提交异步I/O请求</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_cancel</span><span class="params">(<span class="type">io_context_t</span> ctx, <span class="keyword">struct</span> iocb *iocb, <span class="keyword">struct</span> io_event *result)</span></span>;							<span class="comment">//取消异步I/O</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_getevents</span><span class="params">(<span class="type">io_context_t</span> ctx_id, <span class="type">long</span> min_nr, <span class="type">long</span> nr, <span class="keyword">struct</span> io_event *events, <span class="keyword">struct</span> timespec *timeout)</span></span>;	<span class="comment">//获取已完成的I/O事件</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h5 id="Direct-I-O配合异步I-O示例"><a href="#Direct-I-O配合异步I-O示例" class="headerlink" title="Direct I/O配合异步I/O示例"></a>Direct I/O配合异步I/O示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;./direct.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_EVENTS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件，使用 O_DIRECT 和 O_SYNC 标志</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FILENAME, O_CREAT | O_RDWR | O_DIRECT | O_SYNC, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 I/O 上下文</span></span><br><span class="line">    <span class="type">io_context_t</span> ctx;	<span class="comment">//声明异步I/O上下文变量</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="built_in">size</span>(ctx));	<span class="comment">//为变量分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">io_setup</span>(NR_EVENTS, &amp;ctx) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_setup&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配对其的缓冲区</span></span><br><span class="line">    <span class="type">char</span> * buf;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">posix_memalign</span>((<span class="type">void</span> **)&amp;buf, <span class="built_in">sysconf</span>(_SC_PAGESIZE), BUFFER_SIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">        <span class="built_in">io_destroy</span>(ctx);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 I/O 控制块</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iocb</span> *iocbpp = (strcut iocb *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> iocb));</span><br><span class="line">    <span class="built_in">memset</span>(iocbpp, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> iocb));</span><br><span class="line">    iocbpp[<span class="number">0</span>].data = buf;</span><br><span class="line">    iocbpp[<span class="number">0</span>].aio_lio_opcopde = IO_CMD_PWRITE;</span><br><span class="line">    iocbpp[<span class="number">0</span>].aio_reqprio = <span class="number">0</span>;</span><br><span class="line">    iocbpp[<span class="number">0</span>].aio_fildes = fd;</span><br><span class="line">    iocbpp[<span class="number">0</span>].u.c.buf = bnuf;</span><br><span class="line">    iocbpp[<span class="number">0</span>].u.c.nbytes = page_size;	<span class="comment">// strlen(buf) 必须按512B对其</span></span><br><span class="line">    iocbpp[<span class="number">0</span>].u.c.offset = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交异步操作，异步写磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">io_submit</span>(ctx, <span class="number">1</span>, iocbs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_submit&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        <span class="built_in">io_destroy</span>(ctx);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_event</span> events[NR_EVENTS];</span><br><span class="line">    <span class="comment">// 获取写操作结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">io_getevents</span>(ctx, <span class="number">1</span>, <span class="number">1</span>, events, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_getevents&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        <span class="built_in">io_destroy</span>(ctx);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查写操作结果</span></span><br><span class="line">    <span class="keyword">if</span> (events[<span class="number">0</span>].res != BUFFER_SIZE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Write error: &quot;</span> &lt;&lt; events[<span class="number">0</span>].res &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        <span class="built_in">io_destroy</span>(ctx);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="built_in">io_destroy</span>(ctx);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过SPDK支持NVMEDevice"><a href="#通过SPDK支持NVMEDevice" class="headerlink" title="通过SPDK支持NVMEDevice"></a>通过SPDK支持NVMEDevice</h4><h3 id="5-2-5-BlueStore的mount过程"><a href="#5-2-5-BlueStore的mount过程" class="headerlink" title="5.2.5 BlueStore的mount过程"></a>5.2.5 BlueStore的mount过程</h3><p>在BlueStore的 mount过程中，会调用各个函数来初始化其使用的各个组件，顺序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> BlueStore::_mount(<span class="type">bool</span> kv_only) <span class="comment">//指示是否只挂载键值存储还是整个存储</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//读取元数据中的 type 字段来验证存储类型是否为 bluestore</span></span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">read_meta</span>(<span class="string">&quot;type&quot;</span>, &amp;type);</span><br><span class="line">    <span class="keyword">if</span> (type != <span class="string">&quot;bluestore&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件系统检查：如果配置了 bluestore_fsck_on_mount，则执行文件系统的检查。如果检查发现错误，则返回 -EIO。</span></span><br><span class="line">    <span class="keyword">if</span> (cct-&gt;_conf-&gt;bluestore_fsck_on_mount) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开路径：调用 _open_path() 来准备或打开存储路径。如果失败，则返回错误。</span></span><br><span class="line">    <span class="type">int</span> r = _open_path();</span><br><span class="line">    <span class="comment">//打开文件系统 ID (fsid)：打开 fsid，并在成功后读取 fsid。</span></span><br><span class="line">    r = _open_fsid(<span class="literal">false</span>);</span><br><span class="line">    r = _read_fsid(&amp;fsid);</span><br><span class="line">    <span class="comment">//锁定 fsid：使用 _lock_fsid() 函数锁定 fsid</span></span><br><span class="line">    r = _lock_fsid();</span><br><span class="line">    <span class="comment">//通过 _open_bdev() 函数打开块设备。</span></span><br><span class="line">    r = _open_bdev(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//通过 _open_db() 函数打开数据库。</span></span><br><span class="line">    r = _open_db(<span class="literal">false</span>);</span><br><span class="line"> 	<span class="comment">//如果仅挂载键值存储，则结束</span></span><br><span class="line">    <span class="keyword">if</span> (kv_only)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> 	<span class="comment">//打开超级块元数据：通过 _open_super_meta() 函数打开超级块元数据。</span></span><br><span class="line">    r = _open_super_meta();</span><br><span class="line">    <span class="comment">//打开文件映射 (File Mapping)：通过 _open_fm() 函数打开文件映射。</span></span><br><span class="line">    r = _open_fm(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//打开分配器：通过 _open_alloc() 函数打开分配器。</span></span><br><span class="line">    r = _open_alloc();</span><br><span class="line">    <span class="comment">//打开集合：通过 _open_collections() 函数打开集合</span></span><br><span class="line">    r = _open_collections();</span><br><span class="line">    <span class="comment">//重载日志：通过 _reload_logger() 函数重载日志系统。</span></span><br><span class="line">    r = _reload_logger();</span><br><span class="line"> 	<span class="comment">// 如果 bluefs 存在，则调用 _reconcile_bluefs_freespace() 协调 BlueFS 的空闲空间。</span></span><br><span class="line">    <span class="keyword">if</span> (bluefs) &#123;</span><br><span class="line">        r = _reconcile_bluefs_freespace();</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">//启动键值系统：通过 _kv_start() 启动键值系统。</span></span><br><span class="line">    _kv_start();</span><br><span class="line">    <span class="comment">// 延迟重播：通过 _deferred_replay() 执行延迟重播。</span></span><br><span class="line">    r = _deferred_replay();</span><br><span class="line">    <span class="comment">//初始化内存池线程：初始化内存池线程。</span></span><br><span class="line">    mempool_thread.<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">//挂载成功：如果所有步骤都成功完成，则设置 mounted 标志为 true 并返回成功。</span></span><br><span class="line">    mounted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-事务在BlueStore中的实现"><a href="#5-3-事务在BlueStore中的实现" class="headerlink" title="5.3 事务在BlueStore中的实现"></a>5.3 事务在BlueStore中的实现</h2><h3 id="5-3-1-BlueStore写数据流程"><a href="#5-3-1-BlueStore写数据流程" class="headerlink" title="5.3.1 BlueStore写数据流程"></a>5.3.1 BlueStore写数据流程</h3><p>BlueStore里的写数据入口是<code>BlueStore::_do_write()</code>，它会根据 <code>min_alloc_size</code> 来切分 [offset, length] 的写，然后分别依据 small write 和 big write 来处理，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照min_alloc_size大小切分，把写数据映射到不同的块上</span></span><br><span class="line">          [offset, length]</span><br><span class="line">          |==p1==|=======p2=======|=p3=|</span><br><span class="line">|----------------|----------------|----------------|</span><br><span class="line">| min_alloc_size | min_alloc_size | min_alloc_size |</span><br><span class="line">|----------------|----------------|----------------|</span><br><span class="line">small write: p1, p3</span><br><span class="line">big   write: p2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">BlueStore::_do_write()</span><br><span class="line">|-- BlueStore::_do_write_data()</span><br><span class="line">|   <span class="comment">// 依据`min_alloc_size`把写切分为`small/big`写</span></span><br><span class="line">|   | -- BlueStore::_do_write_small()</span><br><span class="line">|   |    | -- BlueStore::ExtentMap::<span class="built_in">seek_lextent</span>()</span><br><span class="line">|   |    | -- BlueStore::Blob::<span class="built_in">can_reuse_blob</span>()</span><br><span class="line">|   |         reuse blob? <span class="keyword">or</span> <span class="keyword">new</span> blob?</span><br><span class="line">|   |    | -- insert to <span class="keyword">struct</span> WriteContext &#123;&#125;;</span><br><span class="line">|   | -- BlueStore::_do_write_big()</span><br><span class="line">|   |    | -- BlueStore::ExtentMap::<span class="built_in">punch_hole</span>()</span><br><span class="line">|   |    | -- BlueStore::Blob::<span class="built_in">can_reuse_blob</span>()</span><br><span class="line">|   |         reuse blob? <span class="keyword">or</span> <span class="keyword">new</span> blob?</span><br><span class="line">|   |    | -- insert to <span class="keyword">struct</span> WriteContext &#123;&#125;;</span><br><span class="line">|-- BlueStore::_do_alloc_write()</span><br><span class="line">|   | -- StupidAllocator::<span class="built_in">allocate</span>()</span><br><span class="line">|   | -- BlueStore::ExtentMap::<span class="built_in">set_lextent</span>()</span><br><span class="line">|   | -- BlueStore::_buffer_cache_write()</span><br><span class="line">|-- BlueStore::_wctx_finish()</span><br></pre></td></tr></table></figure><p>小写先写到RocksDB，大写直接落盘</p><h3 id="5-3-2-BlueStore事务"><a href="#5-3-2-BlueStore事务" class="headerlink" title="5.3.2 BlueStore事务"></a>5.3.2 BlueStore事务</h3><p>OSD的写操作需要封装进写事务，同样需要满足ACID原则</p><ul><li><p>原子性：一个事务内封装了多个操作，事务完成意味着这些操作全部完成后，才通过回调函数通知客户端，不会只完成事务内的一部分操作</p></li><li><p>一致性：在一个事务执行前，系统处于一个一致性状态，事务执行后，系统处于另一个一致性状态</p></li><li><p>隔离性：多个事务并存时，一个事务的执行不受另一个事务的干扰（BlueStore通过全局事务队列实现）</p></li><li><p>持久性：一个事务执行完成后，该事务对相关数据的影响就会持久存在</p><p>如：BlueStore的延迟写，数据写入RocksDB后就报告事务完成，然后才择机落盘。落盘前出现故障可以通过回放RocksDB中的日志恢复数据，提高了效率，也保证了事务的持久性</p></li></ul><p><strong>一个普通的写事务会被分解为多个执行单元，每个执行单元可能有多项数据</strong></p><p><img src="/posts/181607087/image-20241115221007664.png" alt="image-20241115221007664"></p><p>以 <code>&#123;&quot;hw&quot;:&quot;Hello World!&quot;&#125;</code> 的RADOS对象写为例，接口 <code>libRADOS::rados_write()</code> 生成的 <code>transaction</code> 实例如上图</p><ul><li><p><code>op_bl</code> ：列出写事务中包含的事务执行单元，分别为 <code>TOUCH</code> 、 <code>SETATTRS</code>、<code>WRITE</code> 、<code>SETKEYS</code></p><p>每个事务执行单元操作的对象通过 <code>oid</code> 在 <code>object_index</code> 表中检索，本例中全部为 <code>oid=0</code></p></li><li><p>每个执行单元的数据通过序列化操作一次存入 <code>data_bl</code> 中</p><p><code>TOUCH</code> 事务执行单元没有数据</p><p><code>SETATTRS</code> 事务执行单元有4条数据</p><p><code>WRITE</code> 事务执行单元有2条数据</p><p><code>SETKEYS</code> 事务执行单元有6条数据</p></li></ul><h3 id="5-3-3-事务处理的基本流程"><a href="#5-3-3-事务处理的基本流程" class="headerlink" title="5.3.3 事务处理的基本流程"></a>5.3.3 事务处理的基本流程</h3><p>BlueStore通过统一的 <code>queue_transactions</code> 接口收到事务后，首先进行本地寻址，然后处理事务执行单元的写操作，最后进行元数据的写入，执行回调函数</p><h4 id="事务的过程控制"><a href="#事务的过程控制" class="headerlink" title="事务的过程控制"></a>事务的过程控制</h4><blockquote><p>写操作在完成本地寻址后立即进行提交，因此，需要控制的主要是元数据的写入顺序</p></blockquote><p>BlueStore采用 <strong>状态机+队列</strong> 的机制进行事务的过程控制</p><p>事务队列采用FIFO方式控制执行顺序，状态机控制着事务完成一个状态才可以进入下一个状态，事务内各执行单元被多个线程调度并执行</p><h5 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h5><p>将状态的定义值依转换顺序增加，一方面便于编码实现在队列中判断事务的状态；另一方面确保事务的执行的顺序</p><p>按照一个事务执行的顺序，先定义数据异步写操作的状态，然后定义KV元数据写操作的状态，再后针对延迟写进行状态定义，最后是事务完成的最终状态</p><ul><li>某些状态可以跳过，但一个事务的状态转换不可逆向</li></ul><div class="table-container"><table><thead><tr><th>状态</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>STATE_PREPARE</td><td>0</td><td>初始状态，每个事务进入主控队列后处于此状态</td></tr><tr><td>STATE_AIO_WAIT</td><td>1</td><td>异步I/O写操作请求提交后，事务处于的状态</td></tr><tr><td>STATE_IO_DONE</td><td>2</td><td>异步I/O写操作执行完毕后，事务处于的状态</td></tr><tr><td>STATE_KV_QUEUED</td><td>3</td><td>KV元数据写操作进人队列后的状态</td></tr><tr><td>STATE_KV_SUBMITTED</td><td>4</td><td>KV元数据写请求提交后的状态</td></tr><tr><td>STATE_KV_DONE</td><td>5</td><td>KV元数据完成后的状态</td></tr><tr><td>STATE_DEFERRED_QUEUED</td><td>6</td><td>延迟写进入队列后的状态</td></tr><tr><td>STATE_DEFERRED_CLEANUP</td><td>7</td><td>延迟写清理完对应KV日志后的状态</td></tr><tr><td>STATE_DEFERRED_DONE</td><td>8</td><td>延迟写完成的状态</td></tr><tr><td>STATE_FINISHING</td><td>9</td><td>事务执行后处理清理操作的状态</td></tr><tr><td>STATE_DONE</td><td>10</td><td>事务完成</td></tr></tbody></table></div><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>事务执行顺序控制器：控制事务在BlueStore中的全生命周期——<code>OpSequencer</code> 定义的两个队列</p><p>控制元数据写入的多个KV元数据处理队列</p><p><strong>OpSequencer</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpSequencer</span> : <span class="keyword">public</span> Sequencer_impl &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::intrusive::list&lt;</span><br><span class="line">        TransContext,</span><br><span class="line">    	boost::intrusive::member_hook&lt;</span><br><span class="line">        	TransContext,</span><br><span class="line">			boost::intrusive::list_member_hook&lt;&gt;,</span><br><span class="line">			&amp;TransContext::sequencer_item&gt; </span><br><span class="line">        &gt; <span class="type">q_list_t</span>;</span><br><span class="line">    <span class="type">q_list_t</span> q;  <span class="comment">///主控队列，控制事务的全生命周期</span></span><br><span class="line">    boost::intrusive::list_member_hook&lt;&gt; deferred_osr_queue_item;	<span class="comment">//延迟写操作队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个PG一个 <code>OpSequencer</code> 控制器，控制着PG内所有事物的执行顺序</p><p>其作用原理：当队列中事务的关键状态发生变化时，<strong>检查队列前面的其他事务的状态是否处于该事务的状态之后</strong>，是则继续执行，进行下一步状态转换；否则等不执行状态转换，等待后续处理机会</p><p>效果：<strong>q队列中，排在前面的事务执行状态不慢于当前状态，后面的事务才有进入当前状态的下一状态的可能</strong></p><h5 id="控制事务执行的示例代码"><a href="#控制事务执行的示例代码" class="headerlink" title="控制事务执行的示例代码"></a>控制事务执行的示例代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.cc</span></span><br><span class="line"><span class="type">void</span> BlueStore::_txc_finish_io(TransContext *txc)&#123;</span><br><span class="line">    OpSequencer *osr = txc-&gt;osr.<span class="built_in">get</span>();</span><br><span class="line">    txc-&gt;state = TransContext::STATE_IO_DONE;	<span class="comment">//设定txc事务当前状态</span></span><br><span class="line">    OpSequencer::<span class="type">q_list_t</span>::iterator p = osr-&gt;q.<span class="built_in">iterator_to</span>(*txc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p != osr-&gt;q.<span class="built_in">begin</span>()) &#123;<span class="comment">//从当前事务开始，向q队列的前部遍历</span></span><br><span class="line">    	--p;</span><br><span class="line">        </span><br><span class="line">    	<span class="keyword">if</span> (p-&gt;state &lt; TransContext::STATE_IO_DONE) &#123;<span class="comment">//若有事务慢于STATE_IO_DONE，</span></span><br><span class="line">            <span class="comment">//说明队列中，有事务还不具备进入状态转换的条件，等待后续调度</span></span><br><span class="line">     		 <span class="built_in">dout</span>(<span class="number">20</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; txc &lt;&lt; <span class="string">&quot; blocked by &quot;</span> &lt;&lt; &amp;*p &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">	       		&lt;&lt; p-&gt;<span class="built_in">get_state_name</span>() &lt;&lt; dendl;</span><br><span class="line">      		<span class="keyword">return</span>;	<span class="comment">//直接结束，不送入状态机转换状态</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state &gt; TransContext::STATE_IO_DONE) &#123;<span class="comment">//检查队列前的其他事务状态是否快于当前事务状态</span></span><br><span class="line">            <span class="comment">//若找到，说明当前事务之前的所有事务状态都不慢于此状态，队列中只有该事务后续的状态可能等于当前状态</span></span><br><span class="line">      		++p;</span><br><span class="line">      		<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">do</span> &#123;</span><br><span class="line">    	_txc_state_proc(&amp;*p++);</span><br><span class="line">        <span class="comment">//所有处于 STATE_IO_DONE状态的事务依次送入状态转换机转换到下一状态</span></span><br><span class="line">  	&#125; <span class="keyword">while</span> (p != osr-&gt;q.<span class="built_in">end</span>() &amp;&amp; p-&gt;state == TransContext::STATE_IO_DONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TransContext</code> 在 <code>ObjectStore::Transaction</code> 基础上，又封装了RADOS对象的onode、延迟写队列等信息</p><h4 id="写操作事务的处理流程"><a href="#写操作事务的处理流程" class="headerlink" title="写操作事务的处理流程"></a>写操作事务的处理流程</h4><h5 id="写类型"><a href="#写类型" class="headerlink" title="写类型"></a>写类型</h5><p>分为普通写和延迟写两类，</p><ul><li><p>待写入数据的长度小于一个磁盘块的写操作，将内容数据的写操作与元数据写操作一起封装为一个<strong>延迟写</strong>事务，预写入RocksDB内，然后就向上层应用反馈成功写入，后续择机将内容数据落盘</p></li><li><p>待写入数据的长度超过磁盘块的大写操作，将整块的部分按<strong>普通写</strong>方式落盘，然后执行后续操作；不足整块部分，按延迟写处理</p></li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>（TransContext），创建之始事务状态为 <code>STATE_PREPARE</code> 。内容数据 <code>&quot;hello world\0&quot;</code> 共12B，所以采用延迟写事务类型进行处理。事务处理过程中，先写入元数据，再将内容数据也以元数据的形式写入RocksDB，然后择机将实际内容数据落盘。</p><p><img src="/posts/181607087/image-20241117173610808.png" alt="image-20241117173610808"></p><h6 id="PREPARE"><a href="#PREPARE" class="headerlink" title="PREPARE"></a>PREPARE</h6><p>写操作事务通过统一的 <code>queue_transaction</code> 传入BlueStore后，</p><ul><li>TransContext对象内的相关结构以C++容器存储，支持将多个上层事务转换为一个TransContext对象</li></ul><p><strong>1. 创建事务本地化对象 <code>TransContext</code></strong></p><p>首先进行<code>txc</code> <strong>事务本地化对象的创建</strong>，自写操作事务对象 <code>txc</code> 诞生后，事务首先进入 <em>OpSequencer</em> 控制器队列</p><p><img src="/posts/181607087/image-20241117155101062.png" alt="image-20241117155101062"></p><p><strong>2. 分配元数据写入位置的磁盘空间</strong></p><ul><li>对 <strong>创建<code>hw</code>对象的元数据onode</strong>，并从磁盘分配器 <em>Allocator</em> 中 <strong>分配磁盘空间</strong></li></ul><p><strong>3. 将写操作转换为元数据操作</strong></p><ul><li><p>采用RocksDB的<strong>原子写</strong>批处理方式，将OMAP等元数据的写操作内容利用数据库的批处理对象 <code>(KeyValueDB:Transaction) t</code> 进行 <code>put()</code> 操作，等待下一步阶段提交</p><p><code>db-&gt;write()</code></p></li><li><p>写操作转换为元数据操作：以L为前缀，以序列号 <code>deffered_txn-&gt;seq</code> 为key，value为 data、extents等的序列化编码</p></li></ul><p><strong>4. 构建延迟写事务</strong></p><ul><li><p>由于 <code>hw</code> 对象长度不足块大小，所以为延迟写模式，<strong>构建延迟写事务</strong> ，并存入 <code>txc</code> 事务的 <code>deffered_txn</code> 列表内</p></li><li><p>延迟写事务记录待写入的数据 <code>data</code> 和写入位置 <code>extents</code> ，由于内容数据需要块对齐，所以填充为4KB</p></li></ul><p><strong>5. 将事务提交至状态转换机</strong></p><ul><li><code>BlueStore::_txc_state_proc</code> ，事务进入下一状态 <code>STATE_IO_DONE</code></li></ul><h6 id="IO-DONE"><a href="#IO-DONE" class="headerlink" title="IO_DONE"></a>IO_DONE</h6><p><strong>进行事务队列的保序处理，确保序队列前面事务的状态都不小于 STATE_IO_DONE</strong></p><p>当前事务开始，沿队列向前依次查看每个事务的状态，如果发现有的事务状态小于 STATE_IO_DONE，说明本例事务处理太快，停止本例事务，将其留在队列，等待下次遍历队列再行处理</p><p>当满足条件后，调用状态机处理函数 <code>BlueStore::_txc_state_proc</code> ，事务进入 <code>STATE_KV_QUEUED</code></p><h6 id="KV-QUEUED"><a href="#KV-QUEUED" class="headerlink" title="KV_QUEUED"></a>KV_QUEUED</h6><p><strong>提交元数据RocksDB的批处理任务与元数据落盘</strong></p><p>先将事务置入 kvqueue相关内部处理队列，然后通知独立的元数据同步线程 <code>kv_sync_thread</code> 进行处理（线程切换）</p><p>元数据同步线程根据 kvqueue 内部队列依次执行 <code>db-&gt;Write()</code> 函数提交原子批处理任务，实现元数据落盘</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/Bluestore.cc</span></span><br><span class="line"><span class="type">void</span> BlueStore::_kv_sync_thread()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> r = cct-&gt;_conf-&gt;bluestore_debug_omit_kv_commit ? <span class="number">0</span> : db-&gt;<span class="built_in">submit_transaction</span>(txc-&gt;t);</span><br><span class="line">    <span class="built_in">assert</span>(r == <span class="number">0</span>);</span><br><span class="line">    _txc_applied_kv(txc);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># src/kv/RocksDBStore.cc</span></span><br><span class="line"># 调用原子批处理任务处理函数Write提交任务</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RocksDBStore::submit_transaction</span><span class="params">(KeyValueDB::Transaction t)</span></span>&#123;</span><br><span class="line">    rocksdb::Status s = db-&gt;<span class="built_in">Write</span>(woptions, &amp;<span class="type">_t</span>-&gt;bat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时，元数据已写入数据库，延迟写的内容数据在预写入数据库，后续还需正式落盘存储</li></ul><p>后续进行缓存清理工作（flush），进一步确保元数据落盘。</p><p>最后，在元数据同步线程内设置事务状态为 <code>STATE_KV_SUBMITTED</code></p><h6 id="KV-SUBMITTED"><a href="#KV-SUBMITTED" class="headerlink" title="KV_SUBMITTED"></a>KV_SUBMITTED</h6><p><strong>通知上层完成写操作，deffered操作进入单独的队列</strong></p><p>由独立的元数据终结线程 <code>kv_finalize_thread</code> 执行</p><p>元数据终结线程依据 kvqueue 相关内部队列，接受线程同步机制条件变量的<strong>唤醒</strong></p><p>唤醒后，将待执行的、通知客户端完成写操作的<strong>回调函数</strong> 置入回调函数调用队列</p><p>触发专门的异步回调线程执行执行回调函数</p><blockquote><p>此时，内容数据以元数据的形式存入数据库，即使后续步骤出现问题，也可以通过回放日志的方式使数据真正落盘，因此，可以安全的通知上层完成写操作</p></blockquote><p>完成上述工作后，元数据终结线程将事务设置为 KV_DONE 状态</p><h6 id="KV-DONE"><a href="#KV-DONE" class="headerlink" title="KV_DONE"></a>KV_DONE</h6><p>数据已经预写入 直接将事务置为 DEFFERED_QUEUE状态</p><h6 id="DEFFERED-QUEUE"><a href="#DEFFERED-QUEUE" class="headerlink" title="DEFFERED_QUEUE"></a>DEFFERED_QUEUE</h6><p><strong>将事务置入延迟写内部队列，择机落盘</strong></p><p>先将写事务置入 deffere 内部队列，然后将事务从 kvqueue 内部队列中弹出</p><p>根据 defequeue 队列中的排队情况等相关因素，选择是否立即进入下一状态</p><p>如果defequeue队列中事务较少，则本例事务在 defequeue中等待较长时间</p><ul><li><code>bluestore_deffered_batch_ops</code> 影响事务批提交数量</li></ul><p>条件满足后，元数据终结线程调用 <code>BlueStore::_deffered_submit_unlock()</code> 函数。在该函数中，执行 <code>libaio</code> 的异步写接口 <code>aio_submit()</code> ，向硬盘设备提交写请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/Bluestore.cc</span></span><br><span class="line"><span class="type">void</span> BlueStore::_deferred_submit_unlock(OpSequencer *osr)&#123;</span><br><span class="line">    ......</span><br><span class="line">    deferred_lock.<span class="built_in">unlock</span>();</span><br><span class="line">  	bdev-&gt;<span class="built_in">aio_submit</span>(&amp;b-&gt;ioc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写操作完成状态确认工作，由异步写回调线程 <code>aio_thread</code> 调用libaio的接口函数 <code>io_getevents()</code> ，循环检测写操作完成状态。检测到写操作完成后，将事务设置为 DEFFERED_CLEANUP 状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/aio.cc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">aio_queue_t::get_next_completed</span><span class="params">(<span class="type">int</span> timeout_ms, <span class="type">aio_t</span> **paio, <span class="type">int</span> max)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	r = <span class="built_in">io_getevents</span>(ctx, <span class="number">1</span>, max, event, &amp;t);</span><br><span class="line">  	&#125; <span class="keyword">while</span> (r == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="DEFFERED-CLEANUP"><a href="#DEFFERED-CLEANUP" class="headerlink" title="DEFFERED_CLEANUP"></a>DEFFERED_CLEANUP</h6><p>清理kv中的deffered日志</p><p>异步写回调线程 <code>aio_thread</code> 通过线程同步机制唤醒元数据同步线程 <code>kv_sync_thread</code> 继续执行</p><p>因为数据已写入硬盘并收到确认，所以需要清理RocksDB数据中的延迟写日志，避免重复回放</p><h6 id="STATE-FINISHING"><a href="#STATE-FINISHING" class="headerlink" title="STATE_FINISHING"></a>STATE_FINISHING</h6><p>转到元数据终结线程 <code>kv_finalize_thread</code> 处理，处理空间共享、管理PG等放置冲突的任务</p><p>将事务置入下一状态</p><h6 id="STATE-DONE"><a href="#STATE-DONE" class="headerlink" title="STATE_DONE"></a>STATE_DONE</h6><p>择机将事务移出操作控制器 <code>OpSequencer</code> 主控队列、释放所占用的资源、删除txc、删除延迟写队列等</p><h4 id="写结果"><a href="#写结果" class="headerlink" title="写结果"></a>写结果</h4><p>通过开启Ceph bluestore debug来抓取其写过程中对数据的映射，具体步骤如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建一个文件</span></span><br><span class="line">touch tstfile</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 查看该文件的inode numer</span></span><br><span class="line">ls -i</span><br><span class="line">2199023255554 tstfile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 获取该文件的映射信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上述inode number转换为16进制：20000000002</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件的第一个默认4M Object的映射信息</span></span><br><span class="line">ceph osd map cephfs_data_ssd 20000000002.00000000</span><br><span class="line">osdmap e2649 pool &#x27;cephfs_data_ssd&#x27; (3) object &#x27;20000000002.00000000&#x27; -&gt; pg 3.3ff3fe94 (3.94) -&gt; up ([12,0], p12) acting ([12,0], p12)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">osdmap epoch数 存储池 对象<span class="built_in">id</span> -&gt; pg <span class="built_in">id</span> -&gt; osd <span class="built_in">id</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 在osd 12上开启bluestroe debug信息</span></span><br><span class="line">ceph daemon /var/run/ceph/ceph-osd.12.asok config set debug_bluestore &quot;30&quot;  # 开启debug</span><br><span class="line">ceph daemon /var/run/ceph/ceph-osd.12.asok config set debug_bluestore &quot;1/5&quot; # 恢复默认</span><br><span class="line"> </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 对测试文件的前4M内进行<span class="built_in">dd</span>操作，收集<span class="built_in">log</span></span></span><br><span class="line">dd if=/dev/zero of=tstfile bs=4k count=1 oflag=direct</span><br><span class="line">grep -v &quot;trim shard target&quot; /var/log/ceph/ceph-osd.12.log | grep -v &quot;collection_list&quot; &gt; bluestore-write-0-4k.log</span><br></pre></td></tr></table></figure><p>通过上述方式可以搜集到Bluestore在写入数据时，object的数据分配和映射过程，可以帮助理解其实现。</p><h6 id="BlueStore-dd-write各种case"><a href="#BlueStore-dd-write各种case" class="headerlink" title="BlueStore dd write各种case"></a>BlueStore dd write各种case</h6><p>为了更好的理解BlueStore里一个write的过程，我们通过<code>dd</code>命令写一个Object，然后抓取log后分析不同情况下的Object数据块映射情况，最后结果如下图所示：</p><blockquote><p>注释：上图的数据块映射关系是通过抓取log后获取的。</p></blockquote><p><img src="/posts/181607087/bluestore-dd-tst-extentmap-17321749615501.jpg" alt="bluestore-dd-tst-extentmap"></p><p>最后一图中，写[100k, 200)的区域，查看Object对应的ExtentMap并不是与 min_alloc_size（16k）对齐的，只是保证是block_size（4k）对齐而已。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/181607087/" title="5.BlueStore">https://amostian.github.io/posts/181607087/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 存储</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 分布式存储</a> <a href="/tags/Ceph/" rel="tag"><i class="fa fa-tags"></i> Ceph</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1234137269/" rel="prev" title="4.OSD"><i class="fa fa-chevron-left"></i> 4.OSD</a></div><div class="post-nav-item"><a href="/posts/821066227/" rel="next" title="Filebench">Filebench <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-BlueStore%E5%AF%B9%E5%A4%96%E6%8E%A5%E5%8F%A3"><span class="nav-text">5.1 BlueStore对外接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BlueStore%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">BlueStore中的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8BlueStore%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="nav-text">对象在BlueStore中的表示与存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8BlueStore%E4%B8%AD%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-text">对象在BlueStore中的组织方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-BlueStore%E7%BB%84%E4%BB%B6"><span class="nav-text">5.2 BlueStore组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-RocksDB%E2%80%94%E2%80%94BlueStore%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-text">5.2.1 RocksDB——BlueStore的元数据的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RocksDB%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-text">RocksDB的元数据组织方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocksDB%E7%9A%84%E5%86%99"><span class="nav-text">RocksDB的写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocksDB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">RocksDB的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocksDB%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-text">RocksDB的文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-BlueFS"><span class="nav-text">5.2.2 BlueFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-text">文件索引与磁盘地址结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="nav-text">基于日志的元数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#superblock%E7%BB%93%E6%9E%84"><span class="nav-text">superblock结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97"><span class="nav-text">日志文件与操作日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E5%9D%97%E4%B8%8EBlueFS%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%8A%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AE%B9%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-text">超块与BlueFS日志文件及事务内容的对应关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-BlueStore%E5%AF%B9%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-text">5.2.3 BlueStore对磁盘空间的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8EBlueFS%E5%85%B3%E7%B3%BB"><span class="nav-text">与BlueFS关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlueStore%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-text">BlueStore磁盘空间的地址结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-text">磁盘空间的缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-text">硬盘空间分配器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-BlockDevice%E2%80%94%E2%80%94BlueStore%E7%9A%84%E6%95%B0%E6%8D%AEI-O%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.4 BlockDevice——BlueStore的数据I&#x2F;O方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Direct-I-O%E5%92%8C-%E5%BC%82%E6%AD%A5I-O%E6%8E%A7%E5%88%B6KernelDevice%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A1%AC%E7%9B%98%E8%AE%BE%E5%A4%87"><span class="nav-text">Direct I&#x2F;O和 异步I&#x2F;O控制KernelDevice类型的硬盘设备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Direct-I-O"><span class="nav-text">Direct I&#x2F;O</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5I-O"><span class="nav-text">异步I&#x2F;O</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Direct-I-O%E9%85%8D%E5%90%88%E5%BC%82%E6%AD%A5I-O%E7%A4%BA%E4%BE%8B"><span class="nav-text">Direct I&#x2F;O配合异步I&#x2F;O示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87SPDK%E6%94%AF%E6%8C%81NVMEDevice"><span class="nav-text">通过SPDK支持NVMEDevice</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-BlueStore%E7%9A%84mount%E8%BF%87%E7%A8%8B"><span class="nav-text">5.2.5 BlueStore的mount过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E4%BA%8B%E5%8A%A1%E5%9C%A8BlueStore%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.3 事务在BlueStore中的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-BlueStore%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><span class="nav-text">5.3.1 BlueStore写数据流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-BlueStore%E4%BA%8B%E5%8A%A1"><span class="nav-text">5.3.2 BlueStore事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-text">5.3.3 事务处理的基本流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">事务的过程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-text">状态机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">控制事务执行的示例代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">写操作事务的处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E7%B1%BB%E5%9E%8B"><span class="nav-text">写类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#PREPARE"><span class="nav-text">PREPARE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IO-DONE"><span class="nav-text">IO_DONE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#KV-QUEUED"><span class="nav-text">KV_QUEUED</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#KV-SUBMITTED"><span class="nav-text">KV_SUBMITTED</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#KV-DONE"><span class="nav-text">KV_DONE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#DEFFERED-QUEUE"><span class="nav-text">DEFFERED_QUEUE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#DEFFERED-CLEANUP"><span class="nav-text">DEFFERED_CLEANUP</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#STATE-FINISHING"><span class="nav-text">STATE_FINISHING</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#STATE-DONE"><span class="nav-text">STATE_DONE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E7%BB%93%E6%9E%9C"><span class="nav-text">写结果</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BlueStore-dd-write%E5%90%84%E7%A7%8Dcase"><span class="nav-text">BlueStore dd write各种case</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">236</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">84</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1252.1k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">50:25</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>