<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="离散数学：研究离散量结构及相互关系的学科  数理逻辑 集合论 代数系统 图论   逻辑：研究推理的科学 数学方法：引进一套符号系统的方法    数理逻辑是用数学方法研究形式逻辑的科学，即使用符号化系统研究推理的方法。又称符号逻辑。"><meta property="og:type" content="article"><meta property="og:title" content="1.数理逻辑"><meta property="og:url" content="https://amostian.github.io/posts/1891345388/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="离散数学：研究离散量结构及相互关系的学科  数理逻辑 集合论 代数系统 图论   逻辑：研究推理的科学 数学方法：引进一套符号系统的方法    数理逻辑是用数学方法研究形式逻辑的科学，即使用符号化系统研究推理的方法。又称符号逻辑。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-1645105067151.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220212200703541.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220212202350454.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220212225456384.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220212230555605.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220212230609636.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220217113316780.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220217113438547.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220217113648515.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220217115307478.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220217121237202.png"><meta property="og:image" content="https://amostian.github.io/posts/1891345388/image-20220217160956591.png"><meta property="article:published_time" content="2022-02-19T08:45:12.000Z"><meta property="article:modified_time" content="2022-02-20T13:26:11.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="数学"><meta property="article:tag" content="离散数学"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/1891345388/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-1645105067151.png"><link rel="canonical" href="https://amostian.github.io/posts/1891345388/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>1.数理逻辑 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">68</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">84</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">235</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/1891345388/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">1.数理逻辑</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2022-02-19 16:45:12" itemprop="dateCreated datePublished" datetime="2022-02-19T16:45:12+08:00">2022-02-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2022-02-20 21:26:11" itemprop="dateModified" datetime="2022-02-20T21:26:11+08:00">2022-02-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">离散数学</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">8.1k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>离散数学：研究离散量结构及相互关系的学科</p><ul><li>数理逻辑</li><li>集合论</li><li>代数系统</li><li>图论</li></ul></blockquote><p>逻辑：研究推理的科学</p><p>数学方法：引进一套符号系统的方法</p><blockquote><p>数理逻辑是<strong>用数学方法研究形式逻辑的科学</strong>，即使用符号化系统研究推理的方法。又称符号逻辑。</p></blockquote><span id="more"></span><h1 id="1-数理逻辑"><a href="#1-数理逻辑" class="headerlink" title="1. 数理逻辑"></a>1. 数理逻辑</h1><h2 id="1-1-命题逻辑"><a href="#1-1-命题逻辑" class="headerlink" title="1.1 命题逻辑"></a>1.1 命题逻辑</h2><p><img src="/posts/1891345388/命题逻辑-1645105067151.png" alt="命题逻辑"></p><h3 id="1-1-1-命题"><a href="#1-1-1-命题" class="headerlink" title="1.1.1 命题"></a>1.1.1 命题</h3><blockquote><p>命题：具有确定真值的陈述句</p></blockquote><ul><li>断言：一个 <strong>陈述句</strong></li><li>真值：命题的结果为真，真值为真；命题结果为假，真值为假</li></ul><blockquote><p>悖论：真假无法确定的断言称为悖论</p></blockquote><p><strong>命题分类</strong></p><ul><li>原子命题(本原命题)：一个不能分解成更简单的命题</li><li>复合命题：由联结词，标点符号和原子命题复合构成的命题</li></ul><h4 id="1-命题联结词"><a href="#1-命题联结词" class="headerlink" title="1. 命题联结词"></a>1. 命题联结词</h4><blockquote><p>命题演算中的运算符</p></blockquote><ul><li>命题和原子命题通过 <strong>命题联结词</strong> 构成新的 <strong>复合命题</strong></li></ul><h5 id="否定词¬"><a href="#否定词¬" class="headerlink" title="否定词¬"></a>否定词¬</h5><blockquote><p>P表示命题，¬P(P的否定)表示P不真</p></blockquote><div class="table-container"><table><thead><tr><th>P</th><th>¬P</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></tbody></table></div><p><strong>注：</strong></p><ul><li>P：都是… ；</li><li>¬P：不都是<ul><li>$\neq$ 都不是</li></ul></li></ul><h5 id="合取∧"><a href="#合取∧" class="headerlink" title="合取∧"></a>合取∧</h5><blockquote><p>若P和Q都是命题，则 “P并且Q” 这一命题表示为 P∧Q（P和Q的合取）</p></blockquote><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P∧Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><h5 id="析取∨"><a href="#析取∨" class="headerlink" title="析取∨"></a>析取∨</h5><blockquote><p>若P和Q命题，那么 “P或Q” 这一命题表示为 P∨Q（P和Q的析取）</p><ul><li><p>可兼或：不排除P、Q都会发生</p><p>如：</p><ol><li>P：今晚我写字；Q：今晚我看书。为可兼或</li><li>P：他今年30岁；Q：他今年40岁。为排斥或</li></ol></li></ul></blockquote><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P∨Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><h5 id="蕴含词-条件次-→"><a href="#蕴含词-条件次-→" class="headerlink" title="蕴含词(条件次)→"></a>蕴含词(条件次)→</h5><blockquote><p>设P和Q是命题，新命题 “P蕴含Q” 表示为 P→Q（P蕴含Q）</p><ul><li>P：前提、假设或前件</li><li>Q：结论、后件</li></ul></blockquote><p>蕴含式 P→Q 的多种陈述方式</p><ul><li>若P，则Q</li><li>P是Q的充分条件；Q是P的必要条件</li><li>Q每当P：只要P就Q；因为P所以Q</li><li>P仅当Q：只有Q，才P；除非Q，否则¬P</li></ul><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P→Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p><strong>理解</strong>：Q表示没有犯罪，P表示证据，如果没有证据，则无法证明Q犯罪了</p><p>应用：P→Q为假，当且仅当P真Q假</p><ul><li>以假的条件为前提，不管结论真假，新命题 P→Q 都是真的</li><li>以真的条件为前提，结论的真值就是新命题 P→Q 的真值</li></ul><p>蕴含式 P→Q 的关联命题</p><ul><li>逆反命题：¬Q→¬P</li><li>逆命题：Q→P</li><li>反命题：¬P→¬Q</li></ul><p>蕴含式分类（不重要）</p><ul><li>因果蕴含：用于断言前提和结论之间的因果或实质关系<br>P：G是正方形，Q：G的四边相等</li><li>实质蕴含：前提和结论之间无因果或实质关系，这种蕴含式叫实质蕴含<br>P：桔子是紫色的，Q：大地是不平的</li></ul><h5 id="等值-双条件词-↔"><a href="#等值-双条件词-↔" class="headerlink" title="等值(双条件词)↔"></a>等值(双条件词)↔</h5><blockquote><p>设P和Q是命题，新命题 “P等值于Q” 表示为 P↔Q（P等值于Q）<br>多种陈述方式</p></blockquote><ul><li>P是Q的充要条件</li><li>P当且仅当Q</li></ul><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P↔Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><script type="math/tex;mode=display">P\leftrightarrow Q\iff(P\rightarrow Q)∧(Q\rightarrow P) \iff (P∨Q)∧(¬P∨¬Q)</script><h5 id="与非"><a href="#与非" class="headerlink" title="与非"></a>与非</h5><script type="math/tex;mode=display">P\uparrow Q \iff ¬(P∧Q)</script><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P $\uparrow$ Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><script type="math/tex;mode=display">\begin{aligned}
1.& P\uparrow P\iff ¬(P∧P) \iff ¬P\\
2. &(P\uparrow Q) \uparrow(P\uparrow Q) \iff ¬(P\uparrow Q) \iff P∧Q\\
3.&(P\uparrow P)\uparrow(Q\uparrow Q) \iff ¬P\uparrow¬Q \iff P∨Q\\
\end{aligned}</script><h5 id="或非"><a href="#或非" class="headerlink" title="或非"></a>或非</h5><script type="math/tex;mode=display">P\downarrow Q\iff ¬(P∨Q)</script><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P $\downarrow$ Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><script type="math/tex;mode=display">\begin{aligned}
1.& P\downarrow P\iff ¬(P∨P) \iff ¬P\\
2. &(P\downarrow Q) \downarrow(P\downarrow Q) \iff ¬(P\downarrow Q) \iff P∨Q\\
3.&(P\downarrow P)\downarrow(Q\downarrow Q) \iff ¬P\downarrow¬Q \iff P∧Q\\
\end{aligned}</script><h4 id="2-联结词优先级"><a href="#2-联结词优先级" class="headerlink" title="2. 联结词优先级"></a>2. 联结词优先级</h4><ul><li>强弱顺序 ¬ &gt; ∧ &gt; ∨ &gt; → &gt; ↔</li><li>相同的运算符，按从左至右的顺序计算，括号可省略</li><li>最外层的圆括号可以省略<br>如：(¬((P∧¬Q)∨R)→((R∨P)∨Q)) 可写成 ¬(P∧¬Q∨R)→R∨P∨Q</li></ul><h4 id="3-命题翻译"><a href="#3-命题翻译" class="headerlink" title="3. 命题翻译"></a>3. 命题翻译</h4><ol><li>设P：明天下雨，Q：明天下雪，R：我去学校<ul><li>如果明天不是雨夹雪，则我去学校：¬(P∧Q)→R</li><li>如果明天不下雨且不下雪，则我去学校：¬P∧¬Q→R</li><li>如果明天下雨或下雪，则我不去学校：P∨Q→¬R</li><li>明天，雨雪无阻，我一定去学校：P∧Q∧R∨¬P∧Q∧R∨P∧¬Q∧R∨¬P∧¬Q∧R</li><li>当且仅当明天不下雪且不下雨时，我才去学校：¬P∧¬Q↔R</li></ul></li><li>说小学生编不了程序或说小学生使用不了个人计算机，那是不对的<br>设P：小学生会变成，Q：小学生会用个人计算机<br>¬(¬P∨¬Q)</li><li>若不是他生病或出差了，我是不会同意他不参加学习的<br>设P：他生病了，Q：他出差了，R；我同意他不参加学习<br>¬(P∨Q)↔¬R 或 P∨Q↔R</li></ol><h4 id="4-联结词归纳"><a href="#4-联结词归纳" class="headerlink" title="4. 联结词归纳"></a>4. 联结词归纳</h4><blockquote><p>一个联结词集合，用其中联结词构成的式子足以把一切命题公式等价表达出来，则这个联结词集合称为全功能的</p></blockquote><script type="math/tex;mode=display">\begin{aligned}
\{¬,∨\}、&\{¬,∧\}及其变形都是全功能集
\end{aligned}</script><p>判断联结词集合A是不是全功能集，选全功能联结词集合B，若B中每一联结词都能用A中联结词表示，则A是全功能的</p><h3 id="1-1-2-命题公式"><a href="#1-1-2-命题公式" class="headerlink" title="1.1.2 命题公式"></a>1.1.2 命题公式</h3><blockquote><p>命题变元：以”真“、”假“为变域的变量</p></blockquote><ul><li><p>T和F称为命题常元</p></li><li><p>原子公式：单个命题变元或命题常元</p></li></ul><blockquote><p>命题公式定义：由命题、命题联结词、命题常元、命题变元组成的符号串，满足下列条件</p><ol><li>单个原子公式是命题公式</li><li>如果A和B是命题公式，则由命题联结词关联的A和B也是命题公式</li><li>命题公式是 <strong>有限的</strong></li></ol></blockquote><p><strong>命题公式的指派</strong></p><blockquote><p>有 n 个命题变元的命题公式( $P_1,P_2,…,P_n$ )，命题变元的真值有 $2^n$ 种不同的组合。每种组合为一个指派</p></blockquote><ul><li>对应每一指派，命题公式得到确定的值，即命题公式成为命题。</li></ul><h4 id="1-重言式"><a href="#1-重言式" class="headerlink" title="1. 重言式"></a>1. 重言式</h4><blockquote><p>重言式(永真式)：对所有指派，命题公式的取值均为 T<br>矛盾式(永假式)：对所有指派，命题公式的取值均为 F</p></blockquote><ul><li>偶然式：不是永真式及永假式</li><li>可满足的：一个公式至少存在一个指派使其值为真</li><li>非永真：一个命题公式至少存在一个指派使其值为假</li></ul><h5 id="重言式性质"><a href="#重言式性质" class="headerlink" title="重言式性质"></a>重言式性质</h5><ol><li>重言式的否定是矛盾式，矛盾式的否定是重言式</li><li>重言式的合取、析取、蕴含、等值等都是重言式</li></ol><h5 id="两类重要的重言式"><a href="#两类重要的重言式" class="headerlink" title="两类重要的重言式"></a>两类重要的重言式</h5><h6 id="恒等式-真值为1的等值式"><a href="#恒等式-真值为1的等值式" class="headerlink" title="恒等式(真值为1的等值式)"></a>恒等式(真值为1的等值式)</h6><blockquote><p>由相同命题公式组成的命题组 $A(P_1,P_2,…,P_n)$ 和 $B(P_1,P_2,…,P_n)$ ，如果 A↔B 是重言式，则对A与B的任何指派都有相同的真值(全0或全1)，则 A恒等于B 或 A等价于B。记为 $A \iff B$ (逻辑恒等式)</p></blockquote><div class="table-container"><table><thead><tr><th>逻辑恒等式</th><th>描述</th></tr></thead><tbody><tr><td>¬¬p $\iff$ P</td><td>双否定</td></tr><tr><td>P ∨ P $\iff$ P</td><td>等幂律</td></tr><tr><td>P∧P $\iff$ P</td><td>等幂律</td></tr><tr><td>P ∨ Q $\iff$ Q ∨ P</td><td>交换律</td></tr><tr><td>P∧Q $\iff$ Q∧P</td><td>交换律</td></tr><tr><td>(P∨Q)∨R $\iff$ P∨(Q∨R)</td><td>结合律</td></tr><tr><td>(P∧Q)∧R $\iff$ P∧(Q∧R)</td><td>结合律</td></tr><tr><td>P∨(Q∧R) $\iff$ (P∨Q)∧(P∨R)</td><td>分配律</td></tr><tr><td>P∧(Q∨R) $\iff$ P∧Q∨ P∧R</td><td>分配律</td></tr><tr><td>¬(P∨Q) $\iff$ ¬P∧¬Q</td><td><strong>德摩根律</strong></td></tr><tr><td>¬(P∧Q) $\iff$ ¬P∨¬Q</td><td><strong>德摩根律</strong></td></tr><tr><td>P∨(P∧Q) $\iff$ P</td><td>吸收律</td></tr><tr><td>P∧(P∨Q) $\iff$ P</td><td>吸收律</td></tr><tr><td>P→Q $\iff$ ¬P∨Q</td><td><strong>蕴含表达式</strong></td></tr><tr><td>P↔Q $\iff$ (P→Q)∧(Q→P)<br>$\iff$ (¬P∨Q)∧(¬Q∨P)<br>$\iff$ ¬P∧¬Q ∨ Q∧P</td><td><strong>等值表达式</strong></td></tr><tr><td>P∨¬P $\iff$ T</td><td><strong>排中律</strong></td></tr><tr><td>P∧¬P $\iff$ F</td><td><strong>矛盾律</strong></td></tr><tr><td>P→Q $\iff$ ¬Q→¬P</td><td><strong>逆反律</strong></td></tr></tbody></table></div><h6 id="永真蕴含式"><a href="#永真蕴含式" class="headerlink" title="永真蕴含式"></a>永真蕴含式</h6><blockquote><p>如果 A→B 是以永真式，则称为永真蕴含式，记为 A $\Rightarrow$ B(A永真蕴含B)</p></blockquote><p><strong>证明蕴含式永真</strong>：</p><p>方法一：真值表</p><p>方法二：命题演算</p><div class="table-container"><table><thead><tr><th>永真式</th><th>推导</th></tr></thead><tbody><tr><td>P$\Rightarrow$P∨Q</td><td>¬P∨P∨Q=T∨Q=T</td></tr><tr><td>P∧Q$\Rightarrow$P</td><td>¬(P∧Q)∨P=¬P∨¬Q∨P=T</td></tr><tr><td>P∧(P→Q)$\Rightarrow$ Q</td><td>¬(P∧(P→Q)∨Q=¬P∨¬(¬P∨Q)∨Q<br>=¬P∨P∧¬Q∨Q=¬(P∧¬P∨Q∧¬Q)<br>=¬(F∨F)=T</td></tr></tbody></table></div><p>方法三：分情况讨论 <strong>肯定前件，否定后件</strong></p><ul><li><p>假定前件真，若能推出后件真，则此蕴含式真</p></li><li><p>假定后件假，若能退出前件假，则此蕴含式真</p></li></ul><p>例：证明 ¬Q∧(P-&gt;Q)$\Rightarrow$¬P</p><ol><li><p>真值表</p><p>若前件真，则¬Q与P-&gt;Q为真，即Q为假，进而推出P是假，因而后件是真，满足蕴含式的定义</p></li><li><p>分情况讨论<br>设P是真，即后件假，若能证明前件假，则为永真蕴含式<br>(1) 若Q为真，则¬Q为假，P$\rightarrow$Q为真，故 ¬Q∧(P-&gt;Q) 为假<br>(2) 若Q为假，则¬Q为真，P$\rightarrow$Q为假，故 ¬Q∧(P-&gt;Q) 为假<br>故等式为永真蕴含式</p></li></ol><p>方法四：将永真蕴含变为蕴含式与1等价</p><script type="math/tex;mode=display">(A\Rightarrow B) \iff (A\rightarrow B \iff 1)</script><h6 id="恒等式与永真蕴含关系"><a href="#恒等式与永真蕴含关系" class="headerlink" title="恒等式与永真蕴含关系"></a>恒等式与永真蕴含关系</h6><p>$A\iff B$，就是 $A\Rightarrow B$ 且 $B\Rightarrow A$ 同时成立</p><h6 id="恒等式和永真蕴含式的性质"><a href="#恒等式和永真蕴含式的性质" class="headerlink" title="恒等式和永真蕴含式的性质"></a>恒等式和永真蕴含式的性质</h6><p><strong>传递性</strong></p><ul><li>若 A$\iff$B、B$\iff$C，则 A$\iff$C</li><li>若 A $\Rightarrow$ B、B$\Rightarrow$C，则 A$\Rightarrow$C</li></ul><p><strong>永真蕴含结合律</strong></p><p>若A $\Rightarrow$ B、A $\Rightarrow$ C，则 A$\Rightarrow$B∧C</p><p><strong>代入规则</strong> (变形式)</p><blockquote><p>用同一命题公式代替出现在重言式中的某个命题变元，所得的仍是重言式</p></blockquote><ul><li>代入后所得公式称为原公式的代入实例</li></ul><p>对于非重言式，不做代入运算，因为所得的代入实例性质不确定</p><p><strong>替换规则</strong> (真值不变)</p><p>若A$\iff$B，在公式C中出现A的地方可替换为B，得到公式D，则 C$\iff$D</p><ul><li>在公式C和D中，除替换部分外均相同，但对任一指派，A与B的真值相等，故C与D的真值也相等</li></ul><blockquote><p>代入规则和替换规则是命题演算的基础</p></blockquote><h4 id="2-对偶原理"><a href="#2-对偶原理" class="headerlink" title="2. 对偶原理"></a>2. 对偶原理</h4><blockquote><p>对偶公式：设有公式A仅有联结词∧、∨、¬。将A中∧、∨、T、F分别换为∨、∧、F、T得到公式<script type="math/tex">A^*</script>，则<script type="math/tex">A^*</script>称为A的对偶公式</p></blockquote><ul><li>对偶是相互的</li></ul><ol><li><p>设A与 $A^*$ 是对偶式关系</p><p>设 $P_1,P_2,…,P_n$ 是出现于 A 和<script type="math/tex">A^*</script>的所有命题变元，则<script type="math/tex">¬A(P_1,P_2,...,P_n)\iff A^*(¬P_1,¬P_2,...,¬P_n)</script></p></li><li><p>等价命题公式的对偶式相互等价</p><p>若$A\iff B$ ,且A、B为由命题变元$P_1,P_2,…,P_n$及联结词∧、∨、¬构成的公式，则<script type="math/tex">A^*\iff$ B^*</script></p></li><li><p>若$A\Rightarrow B$，且A、B为由命题变元$P_1,P_2,…,P_n$及联结词∧、∨、¬构成的公式，则<script type="math/tex">B^*\Rightarrow A^*</script></p></li></ol><h4 id="3-范式"><a href="#3-范式" class="headerlink" title="3. 范式"></a>3. 范式</h4><blockquote><p>将命题公式转化为其逻辑等价的标准形式</p></blockquote><p>给定一个命题公式，范式一定存在，但不一定唯一，所以引入主范式，一个命题公式的主范式是唯一的</p><h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><blockquote><p>基本积：若干命题变元及其否定的合取式<br>基本和：若干命题变元及其否定的析取式</p></blockquote><p><strong>例</strong>：</p><ul><li>P、P∧Q、¬P∧Q等都是基本积</li><li>P、P∨Q、¬P∨Q等都是基本和</li></ul><p><strong>单个命题变元，既是基本积又是基本和</strong></p><p><strong>性质</strong> ：</p><ul><li>一个基本积是永假式，当且仅当他只含有P、¬P形式的两个因子<br>¬P∧P=F</li><li>一个基本和是永真式，当且仅当他含有P、¬P形式的两个因子<br>¬P∨P=T</li></ul><blockquote><p>析取范式：一个基本积之和的公式，如果与给定的命题公式A等价，则称它为A的析取范式</p></blockquote><script type="math/tex;mode=display">A\iff A_1∨A_2∨...∨A_n,n\ge1,A_i是基本积</script><p>任何一个命题公式的析取范式否是不唯一的，运算符最少的称为 <strong>最简析取范式</strong></p><script type="math/tex;mode=display">\begin{aligned}
¬(P∨Q)&↔(P∧Q) \\
& \iff¬(¬(P∨Q))∧¬(P∧Q)∨¬(P∨Q)∧(P∧Q)\\
& \iff(P∨Q)∧(¬P∨¬Q)∨(¬P∧¬Q)∧(P∧Q)\\
& \iff Q∧¬P∨P∧¬Q
\end{aligned}</script><blockquote><p>合取范式：一个基本和之积组成的公式，如果与给定的命题公式A等价，则称它是A的合取范式</p></blockquote><script type="math/tex;mode=display">A\iff A_1∧A_2∧...∧A_n,n\ge1,A_i是基本和</script><p>任何一个命题公式的合取范式否是不唯一的，运算符最少的称为 <strong>最简合取范式</strong></p><script type="math/tex;mode=display">\begin{aligned}
¬(P∨Q)&↔(P∧Q) \\
& \iff¬(¬(P∨Q))∧¬(P∧Q)∨¬(P∨Q)∧(P∧Q)\\
& \iff(P∨Q)∧(¬P∨¬Q)
\end{aligned}</script><h5 id="极大项与极小项"><a href="#极大项与极小项" class="headerlink" title="极大项与极小项"></a>极大项与极小项</h5><blockquote><p>极小项：在n个变元的基本积中，若每一个变元与其否定不同时存在，而两者之一必出现且仅出现一次</p></blockquote><p>n个变元可构成 $2^n$ 个不同的极小项</p><script type="math/tex;mode=display">\begin{aligned}
m_0 &\iff ¬P_1∧¬P_2∧...∧¬P_n\\
m_1 &\iff ¬P_1∧¬P_2∧...∧P_n\\
\vdots\\
m_{2^n-1} &\iff P_1∧P_2∧...∧P_n
\end{aligned}</script><ul><li>极小项下标与指派真值关系：命题变元指派为1，命题变元的否定指派为0</li></ul><blockquote><p>极大项：在n个变元的基本和，每个变元与其否定不同时存在，而二者之一必出现且仅出现一次</p></blockquote><p>n个变元可构成<script type="math/tex">2^n</script>个不同的极大项</p><script type="math/tex;mode=display">\begin{aligned}
M_0 &\iff ¬P_1∨¬P_2∨...∨¬P_n\\
M_1 &\iff ¬P_1∨¬P_2∨...∨P_n\\
\vdots\\
M_{2^n-1} &\iff P_1∨P_2∨...∨P_n
\end{aligned}</script><ul><li>极大项下标与指派真值关系：命题变元指派为0，命题变元的否定指派为1</li></ul><p><strong>极小项和极大项的性质</strong></p><ol><li><p>越交越小，(极大项)大交小(F)</p><ul><li>$m_i∧m_j\iff F,(i\neq j)$</li><li>$∧_{i=0}^{2^n-1}M_i\iff F$</li><li>$¬m_i \iff M_i$</li></ul></li><li><p>越并越大，（极小项）小交大(T)</p><ul><li>$M_i∨M_j\iff T(i\neq j)$</li><li>$∨_{i=0}^{2^n-1}m_i \iff T$</li><li>$¬M_i \iff m_i$</li></ul></li></ol><h5 id="主析取范式与主合取范式"><a href="#主析取范式与主合取范式" class="headerlink" title="主析取范式与主合取范式"></a>主析取范式与主合取范式</h5><blockquote><p>主析取范式：一个由极小项之和组成的公式，且与给定的命题公式A等价</p></blockquote><script type="math/tex;mode=display">P∧T=P\iff P∧(Q∨¬Q) \\ m_i∨m_k \iff \sum(i,k)</script><ul><li>一个命题公式的真值表是唯一的，因此一个命题公式的主析取范式是唯一的</li><li>具有相同的主析取范式的命题公式，二者逻辑等价</li></ul><blockquote><p>主合取范式：一个由极大项之积组成的公式，且与给定的命题公式A等价</p></blockquote><script type="math/tex;mode=display">P∨F=P\iff P∨(Q∧¬Q)\\
M_i∧M_k \iff \pi(i,k)</script><ul><li>一个命题公式的真值表唯一，因此一个命题公式的主合取范式是唯一的</li><li>具有相同的主合取范式的命题公式，二者逻辑等价</li></ul><h6 id="主析取范式与主合取范式关系"><a href="#主析取范式与主合取范式关系" class="headerlink" title="主析取范式与主合取范式关系"></a>主析取范式与主合取范式关系</h6><p>代表极小项和极大项的下标是互补的，即二者一起构成 $1,2,…,2^n-1$</p><h6 id="主析取范式的个数"><a href="#主析取范式的个数" class="headerlink" title="主析取范式的个数"></a>主析取范式的个数</h6><p>n个命题变元的命题公式，其数量是无限的，但任何一个命题公式都有等价的主析取范式</p><p>两个命题公式有相同的主析取范式，那两个命题公式属于一个等价类</p><script type="math/tex;mode=display">n个命题变元可构造2^{2^n}个主析取范式或主合取范式</script><p>当n=1,极小项有 $2^1=2$ ,即P、¬P，主析取范式有：</p><script type="math/tex;mode=display">\begin{aligned}
f_1\iff F & \\
f_2\iff P & \\
f_3 \iff ¬P &\\
f_4 \iff ¬P∨P
\end{aligned}</script><h3 id="1-1-3-推理规则和证明方法"><a href="#1-1-3-推理规则和证明方法" class="headerlink" title="1.1.3 推理规则和证明方法"></a>1.1.3 推理规则和证明方法</h3><h4 id="1-推理基本概念"><a href="#1-推理基本概念" class="headerlink" title="1. 推理基本概念"></a>1. 推理基本概念</h4><p>论证：列出的前提和结论（待证的结论）若是文字形式，则将论证转化为命题形式</p><p>证明：有效论证的展开，由一系列命题公式根据推理规则得出</p><blockquote><p>若 $H_1∧H_2∧…∧H_n\Rightarrow C$ ，则称C是 $H_1∧H_2∧…∧H_n$ 的有效结论有效</p></blockquote><ul><li><p><strong>推理正确$\neq$结论正确</strong> ：永真蕴含式为真不等价于结论是真；</p><p>若再加上前提是真，则可得结论是真</p><p>若前提是假，当结论为假时，蕴含式也可能为真</p></li></ul><h4 id="2-常用的推理规则"><a href="#2-常用的推理规则" class="headerlink" title="2. 常用的推理规则"></a>2. 常用的推理规则</h4><p><strong>假言推理(分离规则)</strong></p><p><img src="/posts/1891345388/image-20220212200703541.png" alt></p><p><strong>析取三段论</strong></p><p><img src="/posts/1891345388/image-20220212202350454.png" alt></p><p><img src="/posts/1891345388/image-20220212225456384.png" alt></p><ol><li>规则P：在推导的任何步骤上都可以引入前提</li><li>规则T：在推导中，如果前面有一个或多个公式永真蕴含 S，则可以把S引入推导过程</li></ol><p>例：</p><ol><li><img src="/posts/1891345388/image-20220212230555605.png" alt></li><li><img src="/posts/1891345388/image-20220212230609636.png" alt></li></ol><h4 id="3-证明方法"><a href="#3-证明方法" class="headerlink" title="3. 证明方法"></a>3. 证明方法</h4><p><strong>不常用方法</strong></p><ol><li>无义证明法：P是假，则蕴含式是真</li><li>平凡证明法：Q是真，则蕴含式是真</li></ol><h5 id="直接证明法"><a href="#直接证明法" class="headerlink" title="直接证明法"></a><strong>直接证明法</strong></h5><p>假设P是真的，如果能推得Q是真，则 P→Q 是真</p><h5 id="间接证明法-逆反证明法"><a href="#间接证明法-逆反证明法" class="headerlink" title="间接证明法(逆反证明法)"></a><strong>间接证明法(逆反证明法)</strong></h5><p>$P→Q\iff ¬Q→¬P$ ，若Q是假，且P是假，则 $¬Q→¬P$ 是真，也就是 $P→Q$ 是真</p><p><strong>一.逆反命题</strong> $P_1∧P_2∧…∧P_n→Q$</p><p>间接证明：逆反公式是 $¬Q→P_1∨P_2∨…∨P_n$ ，只需证明至少有一个i，使 $¬Q→¬P_i$ 是真</p><p><strong>二.附加前提</strong> $P_1∧P_2∧…∧P_n→(P→Q)$</p><p>CP规则（演绎定理）：等价公式 $P_1∧P_2∧…∧P_n∧P→Q$</p><p>若结论为蕴含式，则前提可作为附加条件</p><p><strong>三.</strong> $P_1∨P_2∨…∨P_n→Q$</p><p>分情况 证明：</p><script type="math/tex;mode=display">\begin{aligned}
P_1∨&P_2∨...∨P_n→Q\\
&\iff ¬P_1∧¬P_2∧...∧¬P_n∨Q\\
&\iff (¬P_1∨Q)∧(¬P_2∨Q)∧...∧(¬P_n∨Q)\\
&\iff (P_1→Q)∧(P_2→Q)∧...∧(P_n→Q)
\end{aligned}</script><h5 id="反证法-归谬法"><a href="#反证法-归谬法" class="headerlink" title="反证法(归谬法)"></a><strong>反证法(归谬法)</strong></h5><ul><li>一致性：若公式 $H_1,H_2,…,H_n$ 的原子命题变元 $P_1,P_2,…,P_n$ 存在某一指派，使得命题变元的积 $P_1∧P_2∧…∧P_n$ 具有真值T，则命题公式集合 $\{H_1,H_2,…,H_n\}$ 是一致的</li></ul><blockquote><p>反证法定理：设 $\{H_1,H_2,…,H_n\}$ 是一致的，C是一命题公式，如果 $\{H_1,H_2,…,H_n,¬C\}$ 是非一致的，则能从 $H_1,H_2,…,H_n$ 能推出 C。</p></blockquote><script type="math/tex;mode=display">\begin{aligned}
欲证H_1∧H_2∧...∧H_n\Rightarrow C,只需证明H_1∧H_2∧...∧H_n∧¬C\Rightarrow F
\end{aligned}</script><ul><li>¬C：假设前提</li></ul><h2 id="1-2-谓词逻辑"><a href="#1-2-谓词逻辑" class="headerlink" title="1.2 谓词逻辑"></a>1.2 谓词逻辑</h2><p>命题是谓词形式的一种特殊情况</p><p>由于原子命题不可拆</p><p><img src="/posts/1891345388/谓词逻辑.png" alt="谓词逻辑"></p><h3 id="1-2-1-谓词和量词"><a href="#1-2-1-谓词和量词" class="headerlink" title="1.2.1 谓词和量词"></a>1.2.1 谓词和量词</h3><blockquote><p>将原子命题拆分成三部分：个体词+谓词+量词</p></blockquote><h4 id="1-个体词"><a href="#1-个体词" class="headerlink" title="1. 个体词"></a>1. 个体词</h4><blockquote><p>个体：代表个体的变元叫个体变元</p></blockquote><p>个体域(论述域)：谓词公式中个体变元的取值范围<br>每个论述域都至少有一个个体</p><h4 id="2-谓词"><a href="#2-谓词" class="headerlink" title="2. 谓词"></a>2. 谓词</h4><blockquote><p>可以理解为函数，表示变量间的某一种关系</p></blockquote><ul><li>谓词：刻画个体的性质或个体间的关系的词</li><li>个体用小写字母表示；谓词用大写字母表示</li></ul><blockquote><p>谓词（谓词命名式）：F(x)、G(x,y)等</p></blockquote><ul><li>F(x)：表示x是质数</li></ul><blockquote><p>n元谓词：表示n个个体间关系的谓词</p></blockquote><ul><li>谓词常元：指定一个谓词的具体意义</li><li>谓词变元：一个字母代表任意谓词</li></ul><h5 id="全总个体域"><a href="#全总个体域" class="headerlink" title="全总个体域"></a>全总个体域</h5><blockquote><p>不同个体变元的论述域集合，可以理解为全体论述域大集合</p></blockquote><ul><li>不同的论述对象需用不同的 <strong>特性谓词</strong> 加以刻画</li></ul><p>例子：设F(x)表示“x是不怕死的”，D(x)表示“x是要死的”,M(x)表示“x是人”</p><ul><li><p>论述域是人类</p><ul><li>“人总是要死的”—— $\forall xD(x)$</li><li>“有些人不怕死”——$∃xF(x)$</li></ul></li><li><p>论述域：全总个体域</p><ul><li>由于论述域是全总个体域，故需要添加特性谓词M(x)<script type="math/tex;mode=display">\begin{aligned}
人总是要怕死的——\forall x(M(x)\rightarrow D(x))\\\\
有些人不怕死——∃ \ x(M(x)∧F(x))
\end{aligned}</script></li></ul></li></ul><h5 id="特性谓词的加入规则"><a href="#特性谓词的加入规则" class="headerlink" title="特性谓词的加入规则"></a><strong>特性谓词的加入规则</strong></h5><ul><li>全称量词，特性谓词作为蕴含式的前件加入</li><li>存在量词，特性谓词作为合取项加入</li></ul><p>在翻译命题时，遇到全称量词提取特性谓词作为前件，遇到存在量词，提取特性谓词作为合取项</p><h4 id="3-量词"><a href="#3-量词" class="headerlink" title="3. 量词"></a>3. 量词</h4><p><strong>全称量词</strong></p><blockquote><p>$\forall x$ :“对一切x”、“对任一x”——变元的全称量化</p></blockquote><p><strong>存在量词</strong></p><blockquote><p>∃x ：存在一x、至少有一x——变元的存在量化</p></blockquote><p>变元x的全称量化或存在量化，<strong>量化的作用是约束变元</strong></p><ul><li>量化后所得命题的真值与论述域有关</li></ul><h5 id="量化断言和命题的关系"><a href="#量化断言和命题的关系" class="headerlink" title="量化断言和命题的关系"></a>量化断言和命题的关系</h5><ol><li><p>论述域有限的</p><script type="math/tex;mode=display">\begin{aligned}
\forall xP(x) \iff P(x_1)∧P(x_2)∧...∧P(x_n)\\
∃ xP(x) \iff P(x_1)∨P(x_2)∨...∨P(x_n)
\end{aligned}</script></li><li><p>论述域可数无限</p><script type="math/tex;mode=display">\begin{aligned}
\forall xP(x) \iff P(x_1)∧P(x_2)∧...∧P(x_n)∧ \dots \\
∃ xP(x) \iff P(x_1)∨P(x_2)∨...∨P(x_n)∨ \dots
\end{aligned}</script></li><li><p>论述域不可数无限，无法表示</p></li></ol><h3 id="1-2-2-谓词公式"><a href="#1-2-2-谓词公式" class="headerlink" title="1.2.2 谓词公式"></a>1.2.2 谓词公式</h3><p>谓词演算的原子公式：不出现命题联结词和量词的谓词命名式 $P(x_1,x_2,…,x_n) (n=0,1,2…)$</p><ul><li>$P(x_1,x_2,…,x_n)$ 是n元谓词公式，其中 $x_1,x_2,…,x_n$ 是个体变项</li></ul><blockquote><p>谓词演算的合式公式</p><ol><li>谓词演算的原子公式是谓词演算公式</li><li>若A，B是谓词演算公式，则¬P、A∧B、A∨B、A→B、A↔B、$\forall xA(x)、∃ xA(x)$是谓词演算公式</li><li>有限步骤的 1,2 构成的公式才是谓词演算公式</li></ol></blockquote><h4 id="1-自由变元与约束变元"><a href="#1-自由变元与约束变元" class="headerlink" title="1. 自由变元与约束变元"></a>1. 自由变元与约束变元</h4><p>辖域：紧接于量词之后的最小的子公式叫量词的辖域</p><blockquote><p>约束变元：在辖域内的变元出现叫约束出现，辖域内的变元叫约束变元<br>自由变元：在辖域外的变元出现叫自由出现，辖域外的变元叫自由变元</p></blockquote><h5 id="代入规则与改名规则"><a href="#代入规则与改名规则" class="headerlink" title="代入规则与改名规则"></a>代入规则与改名规则</h5><blockquote><p>对于谓词公式A(x)，x不出现在y的量词辖域中，则称A(x)对y是自由的</p></blockquote><p>代入规则 $\neq$ 改名规则：代入规则——自由变元；改名规则——约束变元</p><p><strong>改名规则</strong></p><ul><li>若要改名，则该变元在量词及其辖域中的所有出现均需一起更改</li><li>改名时，所选用的符号必须是量词辖域中未出现的符号，最好是公式中未出现的符号</li></ul><p><strong>代入规则</strong></p><ul><li>在一公式中，任一自由个体变元可用另一个体变元代替，需全部替换该公式中的变元。且不能用约束变元的符号替换</li><li>用以代入的变元与原公式中所有变元的名称都不能相同</li></ul><h4 id="2-谓词公式的解释"><a href="#2-谓词公式的解释" class="headerlink" title="2. 谓词公式的解释"></a>2. 谓词公式的解释</h4><blockquote><p>解释I：由非空区域D和对谓词公式G中常项符号、函数符号、谓词符号有下列规则进行的一组指定</p><ol><li>对每一个常项符号指定D中一个元素</li><li>对每一个n元函数符号指定一个函数</li><li>对每一个n元谓词符号，指定一个谓词</li></ol></blockquote><p>给定G的一个解释I，则G在解释I下有一个真值，记作 $T_I(G)$<br>若存在解释I，使得G在解释I下取值为真，则称G是可满足的，建成满足G<br>若G的所有解释I都满足I，则G为永真式（重言式）</p><h3 id="1-2-3-谓词演算的永真式"><a href="#1-2-3-谓词演算的永真式" class="headerlink" title="1.2.3 谓词演算的永真式"></a>1.2.3 谓词演算的永真式</h3><h4 id="1-永真的定义"><a href="#1-永真的定义" class="headerlink" title="1. 永真的定义"></a>1. 永真的定义</h4><p>给定任一谓词公式A，如果在论述域E上，对公式A的谓词和个体变元进行上述两种指派，所得命题：</p><ol><li>都真，则称 <strong>A在E上有效</strong> 或 <strong>在E上永真</strong></li><li>至少有一个是真，则称 <strong>A在E上可满足</strong></li><li>都假，则称 <strong>A在E上永假</strong> 或 <strong>在E上不可满足</strong></li></ol><p>给定任一谓词公式A，如果在任一论述域上，对上述两种指派</p><ol><li>A永真，则称 <strong>A永真</strong> 或 <strong>有效</strong></li><li>A至少在一个域上可满足，则称 <strong>A可满足</strong></li><li>A永假，则称 <strong>A永假</strong> 或 <strong>不可满足</strong></li></ol><h5 id="永真的判定"><a href="#永真的判定" class="headerlink" title="永真的判定"></a>永真的判定</h5><p>若谓词公式A的个体域和谓词的解释是有限的，则可用真值表判定谓词公式A是否永真</p><h4 id="2-谓词公式的等价"><a href="#2-谓词公式的等价" class="headerlink" title="2. 谓词公式的等价"></a>2. 谓词公式的等价</h4><blockquote><p>两个任意谓词公式A和B，E是A、B公有的论述域，若对E上的任意解释所得的命题具有相同的真值，则称公式A和B <strong>遍及E等价</strong>，即为 <strong>在E上</strong> $A\iff B$</p></blockquote><p>A和B等价定义：$A\iff B$ 在 <strong>任一论述域</strong> 上都等价</p><h5 id="谓词演算的基本等价式"><a href="#谓词演算的基本等价式" class="headerlink" title="谓词演算的基本等价式"></a>谓词演算的基本等价式</h5><p>命题演算的永真公式也是谓词演算的永真公式</p><p>含有量词的谓词演算的基本永真公式</p><ol><li><p>常元的量词辖域</p><script type="math/tex;mode=display">\begin{aligned}
\forall xA \iff A\\
∃ xA \iff A
\end{aligned}</script></li><li><p>量词辖域对命题常元的扩展和收缩</p><script type="math/tex;mode=display">\begin{aligned}
\forall xA(x)∨P \iff \forall x(A(x)∨P) \\
\forall xA(x)∧P \iff \forall x(A(x)∧P) \\
∃ xA(x)∨P \iff ∃ x(A(x)∨P) \\
∃ xA(x)∧P \iff ∃ x(A(x)∧P) \\
\forall x(A(x)\rightarrow B)\iff ∃ xA(x)\rightarrow B\\
\forall x(B\rightarrow A(x)) \iff B \rightarrow \forall xA(x)\\
∃ x(A(x)\rightarrow B)\iff \forall xA(x)\rightarrow B\\
∃ x(B\rightarrow A(x)) \iff B \rightarrow ∃ xA(x)\\
\end{aligned}</script></li><li><p>全称量词与存在量词具有对偶性</p><script type="math/tex;mode=display">\begin{aligned}
¬(\forall xP(x)) \iff ∃ x¬P(x)\\
 ¬(∃ xP(x)) \iff \forall x¬P(x)\\
\end{aligned}</script></li><li><p>量词的分配形式</p><p>交起来的辖域小于分开交，并起来的辖域大于分开并</p><ul><li><p>对一切x，A(x)∧B(x)是真。等价于。对一切x，A(x)是真并且对一切x，B(x)是真</p><script type="math/tex;mode=display">\forall x(A(x)∧B(x)) \iff \forall xA(x)∧\forall xB(x)  \\</script></li><li><p>存在一个x，使A(x)∨B(x)是真。等价于。存在一个x使A(x)是真或存在一个x使B(x)是真</p><script type="math/tex;mode=display">∃ x(A(x)∨B(x)) \iff ∃ xA(x)∨∃ xB(x) \\</script></li></ul></li><li><p>量词对 →与↔ 的处理<br>只需用其对全功能集合{¬,∨,∧} 的恒等式即可推出</p></li></ol><h4 id="3-谓词公式的永真蕴含式"><a href="#3-谓词公式的永真蕴含式" class="headerlink" title="3. 谓词公式的永真蕴含式"></a>3. 谓词公式的永真蕴含式</h4><ol><li><p>全称推存在：$\forall xP(x) \Rightarrow ∃ xP(x)$</p><script type="math/tex;mode=display">\begin{aligned}
\forall xP(x) \Rightarrow P(y)&\quad 或 &\forall xP(x) \Rightarrow P(x)\\
P(y)\Rightarrow ∃ xP(x)& &P(x)\Rightarrow ∃ xP(x)
\end{aligned}</script><p>上：如果断言“对一切x，P(x)是真”成立，那么 “对任一确定x,P(x)是真”<br>下：如果对某一确定的x，P(x)是真，那么断言 “存在一x，使P(x)是真”成立</p></li><li><p>小范围 $\Rightarrow$ 大范围；大范围 $\nRightarrow$ 小范围<br>交起来的辖域小于分开交，并起来的辖域大于分开并</p><ul><li><p>$∃ x(A(x)∧B(x)) \Rightarrow ∃ xA(x)∧∃ B(x)$</p><p>小范围中存在的元素 $\Rightarrow$ 大范围中存在该元素</p><p>大范围中存在的元素 $\nRightarrow$ 小范围中存在的元素</p></li><li><p>$\forall xA(x)∨\forall xB(x) \Rightarrow \forall x(A(x)∨B(x))$</p><p>小范围中的所有元素 一定全部 被包含在大范围中</p><p>大范围中的所有元素 不一定全部 被包含在小范围</p></li></ul></li><li><p>量词对前后件都是蕴含式的分配</p><script type="math/tex;mode=display">\begin{aligned}
1.&∃ xA(x)\rightarrow \forall xB(x) \Rightarrow \forall x(A(x)\rightarrow B(x))\\

2.&\forall x(A(x)\rightarrow B(x)) \Rightarrow ∃ xA(x)\rightarrow ∃ xB(x)\\

&证明：由CP规则,若上式成立，则有下式成立\\
&\iff \forall x(A(x)\rightarrow B(x))∧∃ xA(x) \rightarrow ∃ xB(x)\\
&\iff ¬\forall x(A(x)\rightarrow B(x))∨¬∃ xA(x) ∨ ∃ xB(x)\\
&\iff ¬\forall x(A(x)\rightarrow B(x))∨(∃ xA(x) \rightarrow ∃ xB(x))\\
&\iff \forall x(A(x)\rightarrow B(x))\rightarrow(∃ xA(x) \rightarrow ∃ xB(x))\\
3.&\forall x(A(x)\rightarrow B(x)) \Rightarrow \forall xA(x)\rightarrow \forall xB(x)\\
\end{aligned}</script></li></ol><h4 id="4-多个量词的永真式"><a href="#4-多个量词的永真式" class="headerlink" title="4. 多个量词的永真式"></a>4. 多个量词的永真式</h4><p>量词的次序：同可互换，异注意次序<br>①对一切x和一切y，P(x,y)为真。等价于。对一切y和一切x，P(x,y)为真</p><script type="math/tex;mode=display">\forall x\forall yP(x,y) \iff \forall y\forall xP(x,y)</script><p>②存在一个x和存在一个y，P(x,y)为真。等价于。存在一个y和存在一个x,P(x,y)为真</p><script type="math/tex;mode=display">∃ x∃ y P(x,y) \iff ∃ y ∃ xP(x,y)</script><p>③全称=&gt;存在，存在 $\nRightarrow$ 全称</p><script type="math/tex;mode=display">\begin{aligned}
\forall x\forall yP(x,y) \Rightarrow ∃ y\forall xP(x,y)\\
\forall x∃ yP(x,y) \Rightarrow ∃ x∃ y P(x,y)
\end{aligned}</script><p>④存在一切$\Rightarrow$一切存在，一切存在$\nRightarrow$存在一切</p><script type="math/tex;mode=display">∃ y\forall xP(x,y) \Rightarrow \forall x∃ yP(x,y)</script><h4 id="5-谓词演算永真式的规则"><a href="#5-谓词演算永真式的规则" class="headerlink" title="5. 谓词演算永真式的规则"></a>5. 谓词演算永真式的规则</h4><ol><li><p>替换规则</p><p>设 $A(x_1,x_2,…,x_n) \iff B(x_1,x_2,…,x_n)$ ，而A是公式C中的子公式，用B替换C中之A得D，则 $C \iff D$</p></li><li><p>对偶原理</p><p>在公式 $A\iff B$ 或 $A\Rightarrow B$ 中，A、B仅含运算符∧、∨、¬，将上式中的全称量词与存在量词互换，∧、∨互换，TF互换，则</p></li></ol><script type="math/tex;mode=display">A^* \iff B^*,B^*\Rightarrow A^*</script><h3 id="1-2-4-谓词演算的推理规则"><a href="#1-2-4-谓词演算的推理规则" class="headerlink" title="1.2.4 谓词演算的推理规则"></a>1.2.4 谓词演算的推理规则</h3><h4 id="1-前束范式"><a href="#1-前束范式" class="headerlink" title="1. 前束范式"></a>1. 前束范式</h4><blockquote><p>所有量词均在谓词公式开头，且辖域延伸到公式的末尾，则该公式称为前束范式</p></blockquote><ul><li>对任意一个谓词公式都可以化为与他等价的前束范式</li></ul><p><strong>步骤</strong></p><ol><li>利用等价公式将谓词公式中的联结词 →与→去掉</li><li>利用量词的对偶律，将量词前面的否定深入谓词前面</li><li>利用改名和代入规则以及量词辖域扩张的公式将量词转移到全式前面</li></ol><p>例：</p><script type="math/tex;mode=display">\begin{aligned}
&¬∀x(∃yP(x,y)→∃x∀y(Q(x,y)∧∀y(P(y,x)→Q(x,y))))\\
\iff& ¬∀x∃yP(x,y)→∃x∀y(Q(x,y)∧∀z(P(z,x)→Q(x,z)))\\
\iff &¬∀x∃yP(x,y)→∃u∀v(Q(u,v)∧∀z(P(z,u)→Q(u,z)))\\
\iff &∃x∀y¬(¬P(x,y)∨∃u∀v(Q(u,v)∧∀z(P(z,u)→Q(u,z)))\\
\iff &∃x∀y∃u∀v∀zP(x,y)∧¬(Q(u,v)∧P(z,u)→Q(u,z))\\
\iff &∃x∀y∃u∀v∀zP(x,y)∧(¬Q(u,v)∨¬(P(z,u)→Q(u,z))\\
\iff &∃x∀y∃u∀v∀zP(x,y)∧(¬Q(u,v)∨¬(¬P(z,u)∨Q(u,z))\\
\iff &∃x∀y∃u∀v∀zP(x,y)∧(¬Q(u,v)∨(P(z,u)∧¬Q(u,z))\\
\end{aligned}</script><p>任何谓词公式都可转化为与其等价的前束析取范式和束合取范式</p><h4 id="2-推理规则"><a href="#2-推理规则" class="headerlink" title="2. 推理规则"></a>2. 推理规则</h4><p>XS——删X</p><ul><li>转化为命题演算</li></ul><p>XG——生X</p><ul><li>使结论呈现为量化形式</li></ul><h5 id="全称指定规则——全称量词可以删除-Universal-Specification"><a href="#全称指定规则——全称量词可以删除-Universal-Specification" class="headerlink" title="全称指定规则——全称量词可以删除(Universal Specification)"></a>全称指定规则——全称量词可以删除(Universal Specification)</h5><p><img src="/posts/1891345388/image-20220217113316780.png" alt></p><p>可以是个体变元A(y)，也可以是个体常元A(c)</p><h5 id="存在指定规则-Existential-Specification"><a href="#存在指定规则-Existential-Specification" class="headerlink" title="存在指定规则(Existential Specification)"></a>存在指定规则(Existential Specification)</h5><p>假设某一确定个体y使A(y)为真</p><p><img src="/posts/1891345388/image-20220217113438547.png" alt></p><p>使用条件：</p><ol><li><p>使用ES消去存在量词条件是P(x)中除x没有其他个体变元</p></li><li><p>y是A(x)中未出现的字母，表示个体常元</p></li><li>A(x)对于y必须是自由的，A(y)是暂用前提，不能用作结论，所以在结束前，必须使用EG，使之称为约束变元</li></ol><h5 id="存在推广原则-Existential-Generalization"><a href="#存在推广原则-Existential-Generalization" class="headerlink" title="存在推广原则(Existential Generalization)"></a>存在推广原则(Existential Generalization)</h5><p><img src="/posts/1891345388/image-20220217113648515.png" alt></p><h5 id="全称推广-Universal-Generalization"><a href="#全称推广-Universal-Generalization" class="headerlink" title="全称推广(Universal Generalization)"></a>全称推广(Universal Generalization)</h5><p><img src="/posts/1891345388/image-20220217115307478.png" alt></p><p>使用条件：</p><ol><li>在推出A(x)的前提中，x都必须不是自由的；A(x)中的x不是由使用ES而引入的</li><li>使用US引出自由变元x后，ES引入的新变元不能在A(x)中自由出现</li></ol><p><img src="/posts/1891345388/image-20220217121237202.png" alt="image-20220217121237202"></p><p>但上述推理中，(2)-&gt;(3)是错误的，违反UG规则的第二条，使用US后，ES引入的新变元d，不能是自由变元，违背UG的第二条，所以错误</p><p><strong>含义角度</strong></p><p>$\forall x∃ yP(x,y)$ 表示 “对所有x存在一个对应的y使得P(x,y)为真”，而经过推导变为P(c,d)表示”对于任一个体c,存在同一个体d使得P(c,d)”成立，显然不等价</p><h4 id="3-推理举例"><a href="#3-推理举例" class="headerlink" title="3. 推理举例"></a>3. 推理举例</h4><ol><li><p>$\forall x(C(x) \rightarrow (W(x)∧R(x)))∧∃ xC(x)∧Q(x)\Rightarrow ∃ Q(x)∧∃ xQ(x)$</p><script type="math/tex;mode=display">\begin{aligned}
1.\quad&∃ xC(x) \quad &P\\
2. \quad&C(y)    \quad &ES(1)\\
3. \quad&\forall x(C(x) \rightarrow (W(x)∧R(x))) \quad &P\\
4. \quad&C(y) \rightarrow (W(y)∧R(y)) \quad&US(3)\\
5. \quad& W(y)∧R(y) \\
6. \quad&R(y)\\
7. \quad&∃ xR(x)\quad &EG(6)\\
8. \quad& Q(x)\quad &P\\
9. \quad &∃ xQ(x)\quad &EG(8)\\
10. \quad &∃ xQ(x)∧∃ xQ(x)
\end{aligned}</script></li><li><p>给定前提：</p><script type="math/tex;mode=display">\begin{aligned}
 ∃x(P(x)∧∀y(Q(y)→R(x,y)))\\
 ∀x(P(x)→∀y(S(y)→¬R(x,y)))
 \end{aligned}</script><p>证明：$∀x(Q(x)→¬S(x))$</p><script type="math/tex;mode=display">\begin{aligned}
 1. \quad &∃x(P(x)∧∀y(Q(y)→R(x,y)))\quad &P\\
 2. \quad&P(a)∧∀y(Q(y)→R(a,y))\quad&ES(1)\\
 3. \quad&P(a)\quad &T(2)\\
 4. \quad&∀x(P(x)→∀y(S(y)→¬R(x,y)))\quad &P\\
 5. \quad&P(a)→∀y(S(y)→¬R(a,y))\quad &US\\
 6. \quad&∀y(S(y)→¬R(a,y))\quad &T(3)(5)\\
 7. \quad&S(z)→¬R(a,z)\quad &US(6)\\
 8. \quad&∀y(Q(y)→R(a,y))\quad &T(2)\\
 9. \quad&Q(z)→R(a,z)\quad&US(8)\\
 10.\quad&R(a,z)→¬S(z)\quad&逆反(7)\\
 11.\quad&Q(z)→¬S(z)\quad&传递性(9)(10)\\
 12.\quad&∀xQ(x)→¬S(x)\quad&UG(11)
 \end{aligned}</script></li><li><p>所有的有理数都是实数，所有的无理数也是实数，任何虚数都不是实数，所以任何虚数既不是有理数，也不是无理数<br>设：<br>P(x):x是有理数<br>Q(x):x是无理数<br>R(x):x是实数<br>S(x):x是虚数<br>本题符号化为:</p><script type="math/tex;mode=display">\begin{aligned}
  &\forall x(P(x)\rightarrow R(x)),\forall x(Q(x)\rightarrow R(x)),\forall x(S(x)\rightarrow ¬R(x)) \\ 
  &\Rightarrow \forall x(S(x)\rightarrow ¬P(x)∧¬R(x))
  \end{aligned}</script><p>推理过程：</p><script type="math/tex;mode=display">\begin{aligned}
     1. \quad &\forall x(S(x)\rightarrow ¬R(x)) \quad &P\\
     2. \quad &S(y)\rightarrow ¬R(y) \quad &US(1)\\
     3. \quad &\forall x(P(x)\rightarrow R(x))\quad &P\\
     4. \quad &P(y)\rightarrow R(y)\quad &US(3)\\
     5. \quad &\forall x(Q(x)\rightarrow R(x))\quad &P\\
     6. \quad &Q(y)\rightarrow R(y)\quad&US(5)\\
     7. \quad &¬R(y)\rightarrow ¬Q(y),¬R(y)\rightarrow ¬P(y)\quad&逆反(4)(6)\\
     8. \quad &S(y)\rightarrow ¬Q(y),S(y)\rightarrow ¬P(y)\quad&传递性(2)(7)\\
     9. \quad &(S(y)\rightarrow ¬Q(y))∧(S(y)\rightarrow ¬P(y))\\
     10. \quad &(¬S(y)∨¬Q(y))∧(¬S(y)∨¬P(y))\quad &等价(9)\\
     11. \quad &¬S(y)∨(¬Q(y)∧¬P(y))\quad&分配律(10)\\
     12. \quad &S(y)\rightarrow (¬Q(y)∧¬P(y))\quad &等价(12)\\
     13. \quad &\forall xS(x)\rightarrow (¬Q(x)∧¬P(x))\quad &UG(12)
     \end{aligned}</script></li><li><p>反证</p></li></ol><p><img src="/posts/1891345388/image-20220217160956591.png" alt></p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/1891345388/" title="1.数理逻辑">https://amostian.github.io/posts/1891345388/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"><i class="fa fa-tags"></i> 数学</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag"><i class="fa fa-tags"></i> 离散数学</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/763904780/" rel="prev" title="算法学习路线"><i class="fa fa-chevron-left"></i> 算法学习路线</a></div><div class="post-nav-item"><a href="/posts/3927125353/" rel="next" title="2.集合论">2.集合论 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91"><span class="nav-text">1. 数理逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91"><span class="nav-text">1.1 命题逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E5%91%BD%E9%A2%98"><span class="nav-text">1.1.1 命题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%91%BD%E9%A2%98%E8%81%94%E7%BB%93%E8%AF%8D"><span class="nav-text">1. 命题联结词</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%A6%E5%AE%9A%E8%AF%8D%C2%AC"><span class="nav-text">否定词¬</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%8F%96%E2%88%A7"><span class="nav-text">合取∧</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%90%E5%8F%96%E2%88%A8"><span class="nav-text">析取∨</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%95%B4%E5%90%AB%E8%AF%8D-%E6%9D%A1%E4%BB%B6%E6%AC%A1-%E2%86%92"><span class="nav-text">蕴含词(条件次)→</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%89%E5%80%BC-%E5%8F%8C%E6%9D%A1%E4%BB%B6%E8%AF%8D-%E2%86%94"><span class="nav-text">等值(双条件词)↔</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E9%9D%9E"><span class="nav-text">与非</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%96%E9%9D%9E"><span class="nav-text">或非</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%81%94%E7%BB%93%E8%AF%8D%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">2. 联结词优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%91%BD%E9%A2%98%E7%BF%BB%E8%AF%91"><span class="nav-text">3. 命题翻译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%81%94%E7%BB%93%E8%AF%8D%E5%BD%92%E7%BA%B3"><span class="nav-text">4. 联结词归纳</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E5%91%BD%E9%A2%98%E5%85%AC%E5%BC%8F"><span class="nav-text">1.1.2 命题公式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%87%8D%E8%A8%80%E5%BC%8F"><span class="nav-text">1. 重言式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%A8%80%E5%BC%8F%E6%80%A7%E8%B4%A8"><span class="nav-text">重言式性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%B1%BB%E9%87%8D%E8%A6%81%E7%9A%84%E9%87%8D%E8%A8%80%E5%BC%8F"><span class="nav-text">两类重要的重言式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%81%92%E7%AD%89%E5%BC%8F-%E7%9C%9F%E5%80%BC%E4%B8%BA1%E7%9A%84%E7%AD%89%E5%80%BC%E5%BC%8F"><span class="nav-text">恒等式(真值为1的等值式)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B0%B8%E7%9C%9F%E8%95%B4%E5%90%AB%E5%BC%8F"><span class="nav-text">永真蕴含式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%81%92%E7%AD%89%E5%BC%8F%E4%B8%8E%E6%B0%B8%E7%9C%9F%E8%95%B4%E5%90%AB%E5%85%B3%E7%B3%BB"><span class="nav-text">恒等式与永真蕴含关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%81%92%E7%AD%89%E5%BC%8F%E5%92%8C%E6%B0%B8%E7%9C%9F%E8%95%B4%E5%90%AB%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">恒等式和永真蕴含式的性质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%B9%E5%81%B6%E5%8E%9F%E7%90%86"><span class="nav-text">2. 对偶原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%8C%83%E5%BC%8F"><span class="nav-text">3. 范式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F"><span class="nav-text">范式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%81%E5%A4%A7%E9%A1%B9%E4%B8%8E%E6%9E%81%E5%B0%8F%E9%A1%B9"><span class="nav-text">极大项与极小项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E6%9E%90%E5%8F%96%E8%8C%83%E5%BC%8F%E4%B8%8E%E4%B8%BB%E5%90%88%E5%8F%96%E8%8C%83%E5%BC%8F"><span class="nav-text">主析取范式与主合取范式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BB%E6%9E%90%E5%8F%96%E8%8C%83%E5%BC%8F%E4%B8%8E%E4%B8%BB%E5%90%88%E5%8F%96%E8%8C%83%E5%BC%8F%E5%85%B3%E7%B3%BB"><span class="nav-text">主析取范式与主合取范式关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BB%E6%9E%90%E5%8F%96%E8%8C%83%E5%BC%8F%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">主析取范式的个数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99%E5%92%8C%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95"><span class="nav-text">1.1.3 推理规则和证明方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8E%A8%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 推理基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="nav-text">2. 常用的推理规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95"><span class="nav-text">3. 证明方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AF%81%E6%98%8E%E6%B3%95"><span class="nav-text">直接证明法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E8%AF%81%E6%98%8E%E6%B3%95-%E9%80%86%E5%8F%8D%E8%AF%81%E6%98%8E%E6%B3%95"><span class="nav-text">间接证明法(逆反证明法)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E8%AF%81%E6%B3%95-%E5%BD%92%E8%B0%AC%E6%B3%95"><span class="nav-text">反证法(归谬法)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91"><span class="nav-text">1.2 谓词逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E8%B0%93%E8%AF%8D%E5%92%8C%E9%87%8F%E8%AF%8D"><span class="nav-text">1.2.1 谓词和量词</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%AA%E4%BD%93%E8%AF%8D"><span class="nav-text">1. 个体词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B0%93%E8%AF%8D"><span class="nav-text">2. 谓词</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E6%80%BB%E4%B8%AA%E4%BD%93%E5%9F%9F"><span class="nav-text">全总个体域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E8%B0%93%E8%AF%8D%E7%9A%84%E5%8A%A0%E5%85%A5%E8%A7%84%E5%88%99"><span class="nav-text">特性谓词的加入规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%87%8F%E8%AF%8D"><span class="nav-text">3. 量词</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8F%E5%8C%96%E6%96%AD%E8%A8%80%E5%92%8C%E5%91%BD%E9%A2%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">量化断言和命题的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E8%B0%93%E8%AF%8D%E5%85%AC%E5%BC%8F"><span class="nav-text">1.2.2 谓词公式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%87%AA%E7%94%B1%E5%8F%98%E5%85%83%E4%B8%8E%E7%BA%A6%E6%9D%9F%E5%8F%98%E5%85%83"><span class="nav-text">1. 自由变元与约束变元</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E5%85%A5%E8%A7%84%E5%88%99%E4%B8%8E%E6%94%B9%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">代入规则与改名规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B0%93%E8%AF%8D%E5%85%AC%E5%BC%8F%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="nav-text">2. 谓词公式的解释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97%E7%9A%84%E6%B0%B8%E7%9C%9F%E5%BC%8F"><span class="nav-text">1.2.3 谓词演算的永真式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B0%B8%E7%9C%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 永真的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B0%B8%E7%9C%9F%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="nav-text">永真的判定</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B0%93%E8%AF%8D%E5%85%AC%E5%BC%8F%E7%9A%84%E7%AD%89%E4%BB%B7"><span class="nav-text">2. 谓词公式的等价</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%89%E4%BB%B7%E5%BC%8F"><span class="nav-text">谓词演算的基本等价式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%B0%93%E8%AF%8D%E5%85%AC%E5%BC%8F%E7%9A%84%E6%B0%B8%E7%9C%9F%E8%95%B4%E5%90%AB%E5%BC%8F"><span class="nav-text">3. 谓词公式的永真蕴含式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%A4%9A%E4%B8%AA%E9%87%8F%E8%AF%8D%E7%9A%84%E6%B0%B8%E7%9C%9F%E5%BC%8F"><span class="nav-text">4. 多个量词的永真式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97%E6%B0%B8%E7%9C%9F%E5%BC%8F%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">5. 谓词演算永真式的规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97%E7%9A%84%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="nav-text">1.2.4 谓词演算的推理规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%89%8D%E6%9D%9F%E8%8C%83%E5%BC%8F"><span class="nav-text">1. 前束范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="nav-text">2. 推理规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E7%A7%B0%E6%8C%87%E5%AE%9A%E8%A7%84%E5%88%99%E2%80%94%E2%80%94%E5%85%A8%E7%A7%B0%E9%87%8F%E8%AF%8D%E5%8F%AF%E4%BB%A5%E5%88%A0%E9%99%A4-Universal-Specification"><span class="nav-text">全称指定规则——全称量词可以删除(Universal Specification)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E6%8C%87%E5%AE%9A%E8%A7%84%E5%88%99-Existential-Specification"><span class="nav-text">存在指定规则(Existential Specification)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E6%8E%A8%E5%B9%BF%E5%8E%9F%E5%88%99-Existential-Generalization"><span class="nav-text">存在推广原则(Existential Generalization)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E7%A7%B0%E6%8E%A8%E5%B9%BF-Universal-Generalization"><span class="nav-text">全称推广(Universal Generalization)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8E%A8%E7%90%86%E4%B8%BE%E4%BE%8B"><span class="nav-text">3. 推理举例</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">235</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">84</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2026</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1256.9k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">50:48</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>