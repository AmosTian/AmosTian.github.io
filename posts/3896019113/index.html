<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="[TOC]"><meta property="og:type" content="article"><meta property="og:title" content="Ceph参数注解-OSD"><meta property="og:url" content="https://amostian.github.io/posts/3896019113/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="[TOC]"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-06-24T06:04:16.000Z"><meta property="article:modified_time" content="2024-10-04T04:04:38.839Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="存储"><meta property="article:tag" content="分布式存储"><meta property="article:tag" content="Ceph"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://amostian.github.io/posts/3896019113/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Ceph参数注解-OSD | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">64</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">81</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">216</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/3896019113/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Ceph参数注解-OSD</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-06-24 14:04:16" itemprop="dateCreated datePublished" datetime="2024-06-24T14:04:16+08:00">2024-06-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2024-10-04 12:04:38" itemprop="dateModified" datetime="2024-10-04T12:04:38+08:00">2024-10-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/" itemprop="url" rel="index"><span itemprop="name">Ceph</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">17.6k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>35 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>[TOC]</p><span id="more"></span><h2 id="OSD"><a href="#OSD" class="headerlink" title="OSD"></a>OSD</h2><p><code>objecter_tick_interval</code> ：Ceph 对象存储层（Object Storage Layer，简称OSD）中对象执行器（Objecter）的 tick 间隔时间。</p><ul><li>tick 是 Ceph 用于协调不同组件之间操作的机制。</li><li>控制对象执行器Objecter在处理客户端请求和内部操作时的时间间隔，这个选项的值越小，对象执行器执行操作的频率越高，这可能会提高集群的响应速度，但也可能导致资源消耗增加。相反，如果这个值设置得较大，对象执行器执行操作的频率会降低，这可能会减少资源消耗，但也可能导致集群的响应速度变慢。</li></ul><p><code>objecter_timeout</code> ：定义了在操作未完成时，对象执行器多久会认为操作“延迟”，并查询监控节点（Monitoring Service，简称Mon）以获取最新的 OSDMap。</p><p><code>objecter_tick_interval</code> 控制对象执行器执行操作的频率，而 <code>objecter_timeout</code> 控制对象执行器如何处理长时间未完成的操作。</p><p><code>objecter_inflight_op_bytes</code> ：最大动态数据数量（双向）</p><p><code>objecter_inflight_ops</code> ：最大动态操作数</p><p><code>osd_ignore_stale_divergent_priors</code> ：</p><p><code>osd_auto_mark_unfound_lost</code> ：当对象在一定时间内无法找到时，是否自动将其标记为丢失（lost）</p><p><code>osd_check_for_log_corruption</code> ：如果启用此选项，OSD 在启动时会扫描其日志文件，并检查是否有任何腐败的迹象。这可以帮助检测和防止由于日志文件损坏导致的潜在数据损坏或一致性问题。</p><ul><li>用于控制 OSD 启动时是否检查日志文件的腐败情况。启用该选项有助于确保数据的一致性和完整性，但可能会增加 OSD 的启动时间。</li></ul><p><code>osd_force_auth_primary_missing_objects</code> ：近似缺失对象，在其上方强制auth_log_shard暂时成为主要对象</p><p><code>threadpool_default_timeout</code> 是 Ceph 分布式存储系统中的一个配置选项，用于设置线程池中线程的默认超时时间（以秒为单位）。当线程在执行任务时超过了这个超时时间，线程将被视为超时。这个参数有助于控制和管理线程池中的线程行为，特别是在处理长时间运行的任务时。</p><p><code>threadpool_empty_queue_max_wait</code> 是 Ceph 分布式存储系统中的一个配置选项，用于设置线程池中线程在队列为空时最大等待时间（以秒为单位）。当线程池的任务队列为空时，线程将等待新的任务进入队列。如果超过了这个等待时间且仍然没有新任务，线程可能会被销毁或释放资源。</p><p><code>osd_bench_small_size_max_iops</code> 是 Ceph 分布式存储系统中的一个配置选项，用于设置 OSD（对象存储守护进程）基准测试中小尺寸操作的最大 IOPS（每秒输入/输出操作数）。该配置选项主要用于控制在进行性能基准测试时 OSD 处理小尺寸 I/O 操作的速率，从而评估 OSD 的性能。</p><p><code>osd_bench_large_size_max_throughput</code></p><p><code>osd_bench_max_block_size</code></p><p><code>osd_blkin_trace_all</code> 是 Ceph 分布式存储系统中的一个配置选项，用于控制 OSD（对象存储守护进程）是否启用对所有操作的详细跟踪。启用此选项后，Ceph 将记录每个 OSD 操作的详细跟踪信息，这对于调试和性能分析非常有用，但也会增加系统的开销和日志量。</p><p><code>osdc_blkin_trace_all</code> 是 Ceph 客户端配置中的一个选项，用于控制客户端是否启用对所有操作的详细跟踪。启用此选项后，Ceph 客户端将记录每个操作的详细跟踪信息，这对于调试和性能分析非常有用，但也会增加系统的开销和日志量。</p><h3 id="存储后端"><a href="#存储后端" class="headerlink" title="存储后端"></a>存储后端</h3><h4 id="Bluestore"><a href="#Bluestore" class="headerlink" title="Bluestore"></a>Bluestore</h4><h5 id="自动调整缓存大小"><a href="#自动调整缓存大小" class="headerlink" title="自动调整缓存大小"></a>自动调整缓存大小</h5><p><code>bluestore_cache_autotune</code> ：自动调整分配给各种 BlueStore 缓存的空间比率，同时遵守最小值。</p><ul><li><p><code>osd_memory_target</code> ：启用 tcmalloc 和缓存自动调整后，请尝试将这么多字节映射到内存中。</p><p>注意：这可能并不完全符合进程的RSS内存使用情况。虽然通常进程映射的堆内存总量应该接近这个目标，但没有保证内核实际上会回收已经被取消映射的内存。在初始开发期间，发现某些内核导致OSD的RSS内存超过映射内存的20%。然而，有人假设当内存压力很大时，内核通常可能会更积极地回收未映射的内存。您的实际体验可能会有所不同。</p></li><li><p><code>bluestore_cache_autotune_interval</code> ：启用缓存自动调整时，再平衡之间等待的秒数</p><p>bluestore_cache_autotune_interval 设置Ceph重新计算各种缓存的分配比例的速度</p><p>注意：将此间隔设置得太小可能会导致 CPU 使用率较高和性能较低。</p></li><li><p><code>osd_memory_base</code> ：启用 tcmalloc 和缓存自动调整后，估计 OSD 所需的最小内存量（以字节为单位）</p><p>这用于帮助自动调整器估计缓存的预期聚合内存消耗。</p></li><li><p><code>osd_memory_expected_fragmentation</code> ：估计内存碎片的百分比</p></li><li><p><code>osd_memory_cache_min</code> ：设置用于缓存的最小内存量。将此值设置得太低可能会导致严重的缓存抖动。</p></li><li><p><code>osd_memory_cache_resize_interval</code> ：在调整缓存大小之间等待这么多秒。</p><p>此设置更改 BlueStore 可用于缓存的内存总量。请注意，将此间隔设置得太小可能会导致内存分配器混乱并降低性能。</p></li></ul><h5 id="手动调整缓存大小"><a href="#手动调整缓存大小" class="headerlink" title="手动调整缓存大小"></a>手动调整缓存大小</h5><p><code>bluestore_cache_size</code> ：Bluestore 的缓存大小</p><ul><li>这包括 BlueStore 缓存的数据和元数据，以及专用于 rocksdb 缓存的内存。</li><li>为0，则使用ssd或hdd<ul><li><code>bluestore_cache_size_hdd</code> ：当由 HDD 支持时，BlueStore 将用于其缓存的默认内存量。</li><li><code>bluestore_cache_size_ssd</code> :</li></ul></li></ul><p><code>bluestore_cache_meta_ratio</code> ：bluestore 缓存用于元数据的比例</p><p><code>bluestore_cache_kv_ratio</code> ：bluestore缓存用于键/值数据库（RocksDB）的比例</p><p><code>bluestore_cache_kv_onode_ratio</code> ：bluestore 缓存与 kv onode 柱族的比率 （rocksdb）</p><h5 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h5><p><code>bluestore_csum_type</code> ：要使用的默认校验和算法</p><h5 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h5><p><code>bluestore_compression_mode</code> ：当池未指定时的默认压缩策略</p><ul><li><p>不为none表示使用压缩</p></li><li><p>对于 <code>bluestore_compression_algorithm</code> ，只能是某个算法的字符串，不能是列表</p><p>bluestore 压缩算法源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/bluestore/BlueStore.cc</span></span><br><span class="line"><span class="type">void</span> BlueStore::_set_compression()&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; alg_name = cct-&gt;_conf-&gt;bluestore_compression_algorithm;</span><br><span class="line">compressor = Compressor::<span class="built_in">create</span>(cct, alg_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CompressorRef <span class="title">Compressor::create</span><span class="params">(CephContext *cct, <span class="type">int</span> alg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (alg &lt; <span class="number">0</span> || alg &gt;= COMP_ALG_LAST) &#123;</span><br><span class="line">	 <span class="built_in">lderr</span>(cct) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; invalid algorithm value:&quot;</span> &lt;&lt; alg &lt;&lt; dendl;</span><br><span class="line">	 <span class="keyword">return</span> <span class="built_in">CompressorRef</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::string type_name = <span class="built_in">get_comp_alg_name</span>(alg);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">create</span>(cct, type_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># src/compressor/Compressor.cc</span></span><br><span class="line"><span class="function">CompressorRef <span class="title">Compressor::create</span><span class="params">(CephContext *cct, <span class="type">const</span> std ::string &amp;type)</span></span>&#123;</span><br><span class="line">	# 根据type指定的压缩算法名称，创建压缩器插件实例</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="string">&quot;random&quot;</span>) &#123;</span><br><span class="line">		<span class="type">int</span> alg = ceph::util::<span class="built_in">generate_random_number</span>(<span class="number">0</span>, COMP_ALG_LAST - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (alg == COMP_ALG_NONE) &#123;</span><br><span class="line">		  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	 <span class="keyword">return</span> <span class="built_in">create</span>(cct, alg);</span><br><span class="line">	&#125;</span><br><span class="line">	# 对于其他非 <span class="string">&quot;random&quot;</span> 类型的type，</span><br><span class="line">	# 它会尝试使用ceph::CompressionPlugin 的工厂模式来创建压缩器实例</span><br><span class="line">	CompressorRef cs_impl = <span class="literal">NULL</span>;</span><br><span class="line">	std::stringstream ss;</span><br><span class="line">	<span class="keyword">auto</span> reg = cct-&gt;<span class="built_in">get_plugin_registry</span>();</span><br><span class="line">	# 因此，如果 alg_name 是一个逗号分隔的列表，</span><br><span class="line">	# Compressor::create 不会自动尝试列表中的其他算法名称。</span><br><span class="line">	# 	只会尝试使用列表中的第一个算法名称来创建压缩器。</span><br><span class="line">	# 	如果第一个算法名称无效或创建失败，它不会继续尝试列表中的其他算法名称</span><br><span class="line">	<span class="keyword">auto</span> factory = <span class="built_in">dynamic_cast</span>&lt;ceph::CompressionPlugin*&gt;(reg-&gt;<span class="built_in">get_with_load</span>(<span class="string">&quot;compressor&quot;</span>, type));</span><br><span class="line">	<span class="type">int</span> err = factory-&gt;<span class="built_in">factory</span>(&amp;cs_impl, &amp;ss);</span><br><span class="line">	<span class="keyword">return</span> cs_impl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#src/common/PluginRegistry.cc</span></span><br><span class="line"><span class="function">Plugin *<span class="title">PluginRegistry::get_with_load</span><span class="params">(<span class="type">const</span> std::string&amp; type, <span class="type">const</span> std::string&amp; name)</span></span>&#123;</span><br><span class="line">	Plugin* ret = <span class="built_in">get</span>(type, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Plugin *<span class="title">PluginRegistry::get</span><span class="params">(<span class="type">const</span> std::string&amp; type, <span class="type">const</span> std::string&amp; name)</span></span>&#123;	</span><br><span class="line">	# 找到插件用迭代器i接收</span><br><span class="line">	std::map&lt;std::string,map&lt;std::string,Plugin*&gt; &gt;::iterator i = plugins.<span class="built_in">find</span>(type);</span><br><span class="line">	# 在插件中找name类型，</span><br><span class="line">	j = i-&gt;second.<span class="built_in">find</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bluestore_compression_required_ratio</code> ：存储压缩数据所需的压缩比</p><p>如果我们压缩数据并得到的少于此值，我们将丢弃结果并存储原始未压缩的数据。</p><p>压缩后的数据块的大小相对于原始大小的比率必须至少如此小才能存储压缩版本。</p></li><li><p><code>bluestore_compression_min_blob_size</code> ：当对象需要随机访问时，要应用压缩的最大块大小。</p><p>小于此值的块永远不会被压缩。</p><ul><li><code>bluestore_compression_min_blob_size_hdd</code> ：旋转介质的bluestore_compression_min_blob_size默认值</li><li><code>bluestore_compression_min_blob_size_ssd</code> 固态介质的bluestore_compression_min_blob_size默认值</li></ul></li><li><p><code>bluestore_compression_max_blob_size</code> ：当需要对对象进行非随机访问时，要应用压缩的最大块大小。大于此值的块在压缩之前被分解成更小的块</p><ul><li><code>bluestore_compression_max_blob_size_hdd</code> ：旋转介质的默认值 bluestore_compression_max_blob_size</li><li><code>bluestore_compression_max_blob_size_ssd</code> ：非旋转介质(SSD，NVMe)的默认值 bluestore_compression_max_blob_size</li></ul></li></ul><h5 id="rocksdb"><a href="#rocksdb" class="headerlink" title="rocksdb"></a>rocksdb</h5><p><code>bluestore_rocksdb_cf</code> ：允许对 bluestore 元数据使用 rocksdb 列族。</p><ul><li><p>如果为 true，则使用 bluestore_rocksdb_cfs。仅当 OSD 执行 —mkfs 时应用。</p></li><li><p><code>bluestore_rocksdb_cfs</code> ：列族的定义及其分片</p><p>以空格分隔的元素列表： column_def [ ‘=’ rocksdb_options ]。column_def ：= column_name [ ‘（’ shard_count [ ‘，’ hash_begin ‘-‘ [ hash_end ] ] ‘）’ ]。示例：’I=write_buffer_size=1048576 O（6） m（7,10-）’。间隔 [hash_begin..hash_end） 定义用于哈希计算的字符。推荐的哈希范围：O（0-13） P（0-8） m（0-16）。不建议对 S、T、C、M、B 前缀进行分片</p></li></ul><h5 id="流量控制Throttling"><a href="#流量控制Throttling" class="headerlink" title="流量控制Throttling"></a>流量控制Throttling</h5><p><code>bluestore_throttle_bytes</code> ：在开始限制IO提交之前，已经发出但尚未确认完成的IO请求字节数</p><p><code>bluestore_throttle_deferred_bytes</code> ：限制 IO 提交之前，延迟写入的最大字节数</p><p><code>bluestore_throttle_cost_per_io</code> ：每个 IO 的事务成本（以字节为单位）的开销增加</p><ul><li><code>bluestore_throttle_cost_per_io_hdd</code></li><li><code>bluestore_throttle_cost_per_io_ssd</code></li></ul><p><code>bluestore_throttle_trace_rate</code> ：对 bluestore 事务进行采样的速率（每秒）</p><ul><li>可以小于等于0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WITH_LTTNG)</span></span><br><span class="line">      <span class="type">double</span> rate = conf.<span class="built_in">get_val</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;bluestore_throttle_trace_rate&quot;</span>);</span><br><span class="line">      trace_period_mcs = rate &gt; <span class="number">0</span> ? <span class="built_in">floor</span>((<span class="number">1</span>/rate) * <span class="number">1000000.0</span>) : <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="对象的最小分配"><a href="#对象的最小分配" class="headerlink" title="对象的最小分配"></a>对象的最小分配</h5><p><code>bluestore_use_optimal_io_size_for_min_alloc_size</code> ：发现介质最佳 IO 大小并使用 min_alloc_size</p><ul><li>为 false，才能手动调整</li><li><code>bluestore_min_alloc_size</code> ：要为对象分配的最小分配大小<ul><li>较小的分配大小通常意味着在触发 copy-on-write 操作时（例如，在写入最近快照的内容时）读取然后重写的数据更少。同样，在执行覆盖之前记录的数据较少（小于min_alloc_size的写入必须首先通过 BlueStore 日志）。较大的 min_alloc_size 值可以减少描述磁盘布局所需的元数据量，并减少整体碎片。</li><li><code>bluestore_min_alloc_size_hdd</code></li><li><code>bluestore_min_alloc_size_ssd</code></li></ul></li><li><code>bluestore_max_alloc_size</code> ：单个分配的最大大小（0 表示无最大值）</li></ul><p><code>bluestore_prefer_deferred_size</code> ：写入小于此大小的数据将被写入日志，然后异步写入设备。当使用旋转媒体时，这可以带来好处，因为寻址操作成本高昂，无论使用固态日志/WAL设备还是非固态日志/WAL设备，这种方式都有帮助。</p><h5 id="BlueFS"><a href="#BlueFS" class="headerlink" title="BlueFS"></a>BlueFS</h5><p><code>bluefs_alloc_size</code> 是 Ceph 分布式存储系统中的一个配置选项，用于控制 BlueStore 的 BlueFS 文件系统的分配单元大小。BlueFS 是 BlueStore 使用的轻量级文件系统，用于管理元数据（metadata）和小对象。调整 <code>bluefs_alloc_size</code> 可以影响 BlueFS 的性能和存储效率。</p><ul><li>DB 和 WAL 设备的分配单元大小</li></ul><p><code>bluefs_shared_alloc_size</code> 是 Ceph 分布式存储系统中的一个配置选项，用于控制 BlueFS 文件系统的共享分配单元大小。BlueFS 是 BlueStore 使用的轻量级文件系统，用于管理元数据和小对象。调整 <code>bluefs_shared_alloc_size</code> 可以影响 BlueFS 的性能和存储效率，特别是在处理共享的写入负载时。</p><ul><li>主共享设备的分配单元大小</li></ul><p><code>bluefs_failed_shared_alloc_cooldown</code> ：遇到ENOSPC故障后，下次尝试使用 “bluefs_shared_alloc_size” 的间隔时间（以秒为单位）</p><ul><li>冷却周期（以秒为单位），当 BlueFS 面临可恢复的（通过回退到较小数据块大小）ENOSPC（无剩余空间）失败时，使用共享/慢设备分配大小而不是“bluefs_shared_alloc_size”定义的大小。这主要是为了避免重复的失败分配，这些分配可能会非常昂贵。</li></ul><p><code>bluefs_max_prefetch</code> ：</p><p><code>bluefs_replay_recovery</code> ：尝试读取 bluefs 日志，该日志太大，以至于无法读取。</p><ul><li>如果 BlueFS 日志增长到极端大小 （200GB+），则它很可能变得不可读。此选项支持扫描设备以启发式方法查找缺失数据。默认情况下不启用</li></ul><p><code>bluefs_check_for_zeros</code> ：检查读取的数据是否存在可疑页面</p><ul><li>查看读取的数据以检查是否存在完全由零填充的 4K 块。如果发生这种情况，我们会重新读取数据。如果存在差异，我们将错误打印到日志</li></ul><p><code>bluefs_check_volume_selector_on_umount</code> ：检查umount上volume_selector的有效性</p><ul><li>检查 volume_selector 是否未偏离其应处于的状态。引用是从 bluefs inode 表构造的。对不一致的断言</li></ul><p><code>bluefs_check_volume_selector_often</code> ：定期检查 volume_selector 的有效性</p><hr><p><code>bluestore_bluefs</code> ：使用 BlueFS 支持 rocksdb</p><ul><li>BlueFS允许rocksdb与 BlueStore 的其余部分 共享相同的物理设备。它应该在所有情况下使用，除非为Bluestore测试/开发替代的元数据数据库</li></ul><p><code>bluestore_bluefs_env_mirror</code> 将 bluefs 数据镜像到文件系统进行测试/验证</p><p><code>bluestore_bluefs_max_free</code> ：分配给 BlueFS 的最大可用空间</p><p><code>bluestore_bluefs_alloc_failure_dump_interval</code> ：在BlueFS空间分配失败时转储分配器的频率（以秒为单位）</p><hr><p><code>bluestore_spdk_mem</code> ：dpdk 内存大小（以 MB 为单位）</p><ul><li>如果每个节点运行多个 SPDK 实例，则必须指定每个实例将使用的 dpdk 内存大小（以 MB 为单位），以确保每个实例使用自己的 dpdk 内存</li></ul><p><code>bluestore_spdk_max_io_completion</code> ：检查队列对完成时要批处理完成的最大 IO，0 表示让 spdk 库确定它</p><h5 id="blob-size"><a href="#blob-size" class="headerlink" title="blob_size"></a>blob_size</h5><p><code>bluestore_max_blob_size</code> ：Bluestore blob 是源自一个或多个对象的盘区（即磁盘上数据）的集合。可以压缩 Blob，通常具有校验和数据，可以覆盖，可以共享（使用范围参map）或拆分。此设置控制允许的 blob 的最大大小。</p><h5 id="bluestore-extent-map-shard"><a href="#bluestore-extent-map-shard" class="headerlink" title="bluestore_extent_map_shard"></a>bluestore_extent_map_shard</h5><p><code>bluestore_extent_map_shard_max_size</code> ：拆分前单个 extent map分片的最大大小（字节）</p><p><code>bluestore_extent_map_shard_target_size</code> ：单个 extent map分片的目标大小（字节）</p><p><code>bluestore_extent_map_shard_min_size</code> ：拆分前单个 extent map分片的最小大小（字节）</p><p><code>bluestore_extent_map_shard_target_size_slop</code> ：在尝试对齐到现有范围或数据块边界时，分片的目标比例高于/低于目标。</p><p><code>bluestore_extent_map_inline_shard_prealloc_size</code></p><h5 id="bluestore-avl"><a href="#bluestore-avl" class="headerlink" title="bluestore_avl"></a>bluestore_avl</h5><p><code>bluestore_avl_alloc_ff_max_search_count</code> ：在切换到best-fit模式之前，使用first-fit 模式搜索的次数，0 遍历所需块的所有范围。</p><p><code>bluestore_avl_alloc_ff_max_search_bytes</code></p><p><code>bluestore_avl_alloc_bf_threshold</code> ：设置了一个阈值，当最大的空闲数据块大小小于这个阈值时，分配器会切换到最佳拟合（best-fit）模式</p><ul><li>AVL分配器工作在两种模式下：近似拟合和最佳拟合。</li><li>默认情况下，它使用非常快速的近似拟合模式，在这种模式下，它试图将一个新的数据块放置在最后一个分配的相似大小的数据块附近。</li><li>第二种模式是更慢的最佳拟合模式，在这种模式下，它试图为请求的分配找到一个完全匹配。当设备变得碎片化或者空闲空间不足时，使用这种模式。当最大的空闲数据块小于 ‘bluestore_avl_alloc_bf_threshold’ 时，将使用最佳拟合模式。</li></ul><p><code>bluestore_avl_alloc_bf_free_pct</code> ：设置了一个阈值，当空闲空间缩小到这个百分比（整数）时，将触发启用最佳拟合模式。</p><ul><li>AVL分配器工作在两种模式下：near-fit 和 best-fit。默认情况下，它使用非常快速的near-fit模式，在这种模式下，它试图将一个新的数据块放置在最后一个分配的相似大小的数据块附近。</li><li>第二种模式是更慢的best-fit模式，在这种模式下，它试图为请求的分配找到一个完全匹配。当设备变得碎片化或者空闲空间不足时，使用这种模式。当空闲空间小于 ‘bluestore_avl_alloc_bf_free_pct’ 时，将使用最佳拟合模式。</li></ul><h5 id="bluestore-volume"><a href="#bluestore-volume" class="headerlink" title="bluestore_volume"></a>bluestore_volume</h5><p><code>bluestore_volume_selection_policy</code> ：确定 bluefs 卷选择策略</p><ul><li>确定 bluefs 卷选择策略。<ul><li>“use_some_extra”策略允许覆盖 RocksDB 级别的粒度，并将高级数据放到更快的设备上，即使该级别不完全适合那里。</li><li>“fit_to_fast”策略允许使用 100% 更快的磁盘容量，并允许用户在 RocksDB 选项中打开“level_compaction_dynamic_level_bytes”选项。</li></ul></li></ul><p><code>bluestore_volume_selection_reserved_factor</code> ：数据库级大小乘数。</p><ul><li><p>确定数据库设备上的空间量，以便在“使用一些额外”策略生效时禁止使用。保留大小确定为 sum（L_max_size[0]， L_max_size[L-1]） + L_max_size[L] * this_factor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculating how much extra space is available at DB volume.</span></span><br><span class="line"><span class="comment">// Depending on the presence of explicit reserved size specification it might be either</span></span><br><span class="line"><span class="comment">// * DB volume size - reserved</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="comment">// * DB volume size - sum_max_level_size(0, L-1) - max_level_size(L) * reserved_factor</span></span><br><span class="line"><span class="keyword">if</span> (!reserved) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> prev_levels = _level0_size;</span><br><span class="line">    <span class="type">uint64_t</span> cur_level = _level_base;</span><br><span class="line">    <span class="type">uint64_t</span> cur_threshold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">uint64_t</span> next_level = cur_level * _level_multiplier;</span><br><span class="line">        <span class="type">uint64_t</span> next_threshold = prev_levels + cur_level + next_level * reserved_factor;</span><br><span class="line">        <span class="keyword">if</span> (_db_total &lt;= next_threshold) &#123;</span><br><span class="line">            db_avail4slow = cur_threshold ? _db_total - cur_threshold : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_levels += cur_level;</span><br><span class="line">            cur_level = next_level;</span><br><span class="line">            cur_threshold = next_threshold;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    db_avail4slow = _db_total - reserved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这段代码是用来计算数据库卷上除预留空间外还剩下多少额外空间的。其逻辑依据是否存在明确的预留空间大小指示分为两种情况处理：</span><br><span class="line"></span><br><span class="line">如果指定了预留空间（reserved为真）：计算很简单，直接从数据库总大小（_db_total）中减去预留的空间大小，得到的结果就是可用空间db_avail4slow。</span><br><span class="line"></span><br><span class="line">如果没有指定预留空间（reserved为假）：则通过一个循环动态计算。这个过程基于一个层级体系，每一层的大小基于前一层按一定的倍数（_level_multiplier）增长，并且每一层都会计算一个阈值，该阈值由前面所有层的大小之和加上当前层大小以及根据reserved_factor调整的下一层大小组成。循环会持续进行，直到计算出的阈值超过了数据库的总大小。此时，如果当前阈值不为零，则可用空间为数据库总大小减去这个阈值；如果当前阈值为零，则说明没有额外空间。</span><br><span class="line">    reserved_factor应当是一个正数，用来调整最后一层大小在计算阈值时的影响。如果这个值不是正数，可能会导致计算逻辑出现问题，因此在实际应用中应该确保其合理性。</span><br></pre></td></tr></table></figure></li></ul><p><code>bluestore_volume_selection_reserved</code> ：在数据库设备上保留空间，不允许用于“use_some_extra”策略。覆盖“bluestore_volume_selection_reserved_factor”设置并引入直接限制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/BlueStore.cc</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RocksDBBlueFSVolumeSelector</span>(</span><br><span class="line">    bluefs-&gt;<span class="built_in">get_block_device_size</span>(BlueFS::BDEV_WAL) * <span class="number">95</span> / <span class="number">100</span>,</span><br><span class="line">    bluefs-&gt;<span class="built_in">get_block_device_size</span>(BlueFS::BDEV_DB) * <span class="number">95</span> / <span class="number">100</span>,</span><br><span class="line">    bluefs-&gt;<span class="built_in">get_block_device_size</span>(BlueFS::BDEV_SLOW) * <span class="number">95</span> / <span class="number">100</span>,</span><br><span class="line">    <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>, <span class="comment">//<span class="doctag">FIXME:</span> set expected l0 size here</span></span><br><span class="line">    rocks_opts.max_bytes_for_level_base,</span><br><span class="line">    rocks_opts.max_bytes_for_level_multiplier,</span><br><span class="line">    reserved_factor,</span><br><span class="line">    cct-&gt;_conf-&gt;bluestore_volume_selection_reserved,</span><br><span class="line">    cct-&gt;_conf-&gt;bluestore_volume_selection_policy == <span class="string">&quot;use_some_extra&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RocksDBBlueFSVolumeSelector</span>(</span><br><span class="line">    <span class="type">uint64_t</span> _wal_total,</span><br><span class="line">    <span class="type">uint64_t</span> _db_total,</span><br><span class="line">    <span class="type">uint64_t</span> _slow_total,</span><br><span class="line">    <span class="type">uint64_t</span> _level0_size,</span><br><span class="line">    <span class="type">uint64_t</span> _level_base,</span><br><span class="line">    <span class="type">uint64_t</span> _level_multiplier,</span><br><span class="line">    <span class="type">double</span> reserved_factor,</span><br><span class="line">    <span class="type">uint64_t</span> reserved,</span><br><span class="line">    <span class="type">bool</span> new_pol)</span><br></pre></td></tr></table></figure><ul><li><code>bluestore_bluefs_min</code> 和 <code>bluestore_bluefs_min_free</code> 都指定了 BlueFS 的最小空间需求，但一个是总的磁盘空间，另一个是空闲空间。</li><li><code>bluestore_bluefs_max_free</code> 指定了 BlueFS 可以拥有的最大空闲空间量，这个值应该大于或等于 <code>bluestore_bluefs_min_free</code>。</li><li><code>bluestore_bluefs_min_ratio</code> 和 <code>bluestore_bluefs_max_ratio</code> 定义了 BlueFS 可以使用的磁盘空间的最小和最大比例。<code>bluestore_bluefs_min_ratio</code> 应该小于或等于 <code>bluestore_bluefs_max_ratio</code>。</li><li><code>bluestore_bluefs_gift_ratio</code> 和 <code>bluestore_bluefs_reclaim_ratio</code> 定义了 BlueFS 在一次操作中可以增加或减少的空闲空间的最大比例。这两个比例应该在 <code>bluestore_bluefs_min_ratio</code> 和 <code>bluestore_bluefs_max_ratio</code> 定义的范围内。<ul><li><strong>bluestore_bluefs_gift_ratio</strong>: 这是一次性可以分配给 BlueFS 的最大空闲空间比例。默认值是 0.02，即 2%。</li><li><strong>bluestore_bluefs_reclaim_ratio</strong>: 这是一次性可以从 BlueFS 回收的最大空闲空间比例。默认值是 0.20000000000000001，即 20%。</li></ul></li></ul><h4 id="Filestore"><a href="#Filestore" class="headerlink" title="Filestore"></a>Filestore</h4><p><code>filestore_debug_omap_check</code></p><h5 id="journal"><a href="#journal" class="headerlink" title="journal"></a>journal</h5><p><code>osd_journal</code> ：OSD 日志的路径（当使用 FileStore 后端时）</p><ul><li>OSD 日志的路径。这可能是文件或块设备（例如 SSD 的分区）的路径。如果它是文件，则必须创建目录来包含它。当 osd_data 驱动器是 HDD 时，我们建议使用单独的快速设备。</li></ul><p><code>osd_journal_size</code> ：FileStore journal 的大小（以 MiB 为单位）</p><p><code>filer_max_purge_ops</code> 在执行日志条带清理操作时，可以同时进行的最大操作数。这个值会影响清理操作的并发性和效率，同时也可能影响集群的性能。</p><ul><li>这个选项影响 Ceph 文件存储（Filestore）组件的 purge 行为</li></ul><p><code>filer_max_truncate_ops</code> 在执行日志条带裁剪/删除操作时，可以同时进行的最大操作数。这个值会影响裁剪/删除操作的并发性和效率，同时也可能影响集群的性能。</p><ul><li>这个选项影响 Ceph 文件存储（Filestore）组件的 truncate 行为</li></ul><p><code>journaler_write_head_interval</code> ：对象存储设备（OSD）在写入日志头部时应该等待的时间长度。</p><ul><li>日志头部包含有关日志条带的最新状态信息，这些信息对于日志的重放（replay）操作至关重要。</li><li>影响 Ceph 文件存储（Filestore）组件的行为<ul><li><strong>性能</strong>：设置一个较高的 <code>journaler_write_head_interval</code> 值可能会导致日志头部更新不频繁，这可能会影响日志条带的重放效率。</li><li><strong>稳定性</strong>：设置一个较低的 <code>journaler_write_head_interval</code> 值可以确保日志头部更新更加频繁，这有助于保持日志条带状态的最新性，从而提高集群的稳定性。</li></ul></li></ul><p><code>journaler_prefetch_periods</code> ：允许对象存储设备（OSD）在处理 MDS 日志时预先获取多个条带化周期（striping periods）的数据。</p><ul><li>条带化是一种数据分布技术，用于将数据分散存储在多个 OSD 上。</li><li><strong>性能</strong>：设置一个较高的 <code>journaler_prefetch_periods</code> 值可以提高读取 MDS 日志的效率，因为 OSD 可以同时处理多个条带化周期的数据。然而，这也可能会增加集群的负载，尤其是在高并发情况下。</li><li><strong>稳定性</strong>：设置一个较低的 <code>journaler_prefetch_periods</code> 值可以减少集群的负载，从而提高稳定性。然而，这也可能会降低读取 MDS 日志的效率，导致操作需要更长的时间来完成。</li></ul><p><code>journaler_prezero_periods</code> ：将 MDS 日志写入位置的条带化周期数归零</p><h3 id="清洗"><a href="#清洗" class="headerlink" title="清洗"></a>清洗</h3><p><code>mon_scrub_interval</code> ：清理 MON 数据库的频率</p><ul><li>大于 mon_scrub_timeout</li></ul><p><code>mon_scrub_timeout</code>：当监视器仲裁参与者对最新数据块没有响应时，重新启动清理操作的超时时间。</p><ul><li>进行scrub操作时可以等待的时间长度</li></ul><p><code>mon_scrub_timeout</code> 需要大于 <code>osd_heartbeat_grace</code> 和 <code>osd_recovery_timeout</code>，以确保在执行 scrub 操作时不会因为心跳超时而中断。scrub 操作是一个耗时的过程，它涉及到对 OSD 上的数据进行完整性检查和修复，这可能会占用大量的系统资源</p><ol><li><strong>心跳超时（osd_heartbeat_grace）</strong>：当一个 OSD 在 <code>osd_heartbeat_grace</code> 指定的时间内没有发送心跳，Ceph 可能会认为该 OSD 已经失败，并开始执行故障转移。如果在执行 scrub 操作时 OSD 的心跳超时，scrub 操作可能会因为故障转移而中断。因此，<code>mon_scrub_timeout</code> 需要足够长，以确保在 scrub 操作完成之前，OSD 不会因为心跳超时而失败。</li><li><strong>恢复超时（osd_recovery_timeout）</strong>：如果一个 OSD 正在执行恢复操作（例如，从副本故障中恢复），Ceph 可能会等待一段时间（<code>osd_recovery_timeout</code>）以确保恢复操作完成。如果在执行 scrub 操作时 OSD 正在恢复，scrub 操作可能会因为恢复操作的超时而中断。因此，<code>mon_scrub_timeout</code> 需要足够长，以确保在 scrub 操作完成之前，OSD 不会因为恢复操作的超时而失败。</li></ol><p><code>mon_scrub_max_keys</code> ：每个清理 chunk/step 的最大键数</p><p><code>mon_warn_pg_not_scrubbed_ratio</code> ：超过最大清洗间隔的百分比，以发出警告</p><p><code>mon_warn_pg_not_deep_scrubbed_ratio</code> ：超过最大深度清洗间隔的百分比，以发出警告</p><p><code>mon_scrub_inject_crc_mismatch</code> ：将 CRC 错配注入 Mon Scrub 的概率</p><ul><li>在 scrub 过程中故意注入 CRC 不匹配错误</li></ul><p><code>mon_scrub_inject_missing_keys</code> ：将丢失的keys注入 Mon Scrub 的概率</p><ul><li>在 mon scrub 过程中注入丢失的 keys 的概率</li></ul><p><code>mon_sync_debug</code> ：在 Mon 同步期间启用额外调试</p><p><code>mon_inject_sync_get_chunk_delay</code> ：同步期间注入延迟（秒）</p><p><code>osd_max_scrubs</code> ：单个 OSD 上的最大并发清理次数</p><p>从源码看，不应该为负数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/scrubber/osd_scrub_sched.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScrubQueue::can_inc_scrubs</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">  <span class="comment">// consider removing the lock here. Caller already handles delayed</span></span><br><span class="line">  <span class="comment">// inc_scrubs_local() failures</span></span><br><span class="line">  std::lock_guard lck&#123;resource_lock&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (scrubs_local + scrubs_remote &lt; cct-&gt;_conf-&gt;osd_max_scrubs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dout</span>(<span class="number">20</span>) &lt;&lt; <span class="string">&quot; == false. &quot;</span> &lt;&lt; scrubs_local &lt;&lt; <span class="string">&quot; local + &quot;</span> &lt;&lt; scrubs_remote</span><br><span class="line">	   &lt;&lt; <span class="string">&quot; remote &gt;= max &quot;</span> &lt;&lt; cct-&gt;_conf-&gt;osd_max_scrubs &lt;&lt; dendl;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScrubQueue::inc_scrubs_local</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (scrubs_local + scrubs_remote &lt; cct-&gt;_conf-&gt;osd_max_scrubs) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScrubQueue::inc_scrubs_remote</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (scrubs_local + scrubs_remote &lt; cct-&gt;_conf-&gt;osd_max_scrubs) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>osd_scrub_begin_hour</code> ：将擦洗限制在一天中的这个小时或更晚，全天使用 osd_scrub_begin_hour=0 和 osd_scrub_end_hour=0</p><ul><li>与 osd_scrub_end_hour 一起定义了一个可以发生清理的时间窗口。</li><li>但无论时间窗口是否允许，只要归置组的清理间隔超过 osd_scrub_max_interval，都会执行清理。</li></ul><p><code>osd_scrub_end_hour</code> ：将擦洗时间限制在一天中早于此时间，全天使用 osd_scrub_begin_hour=0 和 osd_scrub_end_hour=0</p><p><code>osd_scrub_begin_week_day</code> ：将擦洗限制在一周中的这一天或之后</p><ul><li>0 = 星期日，1 = 星期一，以此类推。整周使用 osd_scrub_begin_week_day=0 osd_scrub_end_week_day=0</li></ul><p><code>osd_scrub_end_week_day</code> ：将擦洗时间限制在早于一周中的这天</p><ul><li>0 = 星期日，1 = 星期一，以此类推。整周使用 osd_scrub_begin_week_day=0 osd_scrub_end_week_day=0。</li><li>但是，当PG的清理间隔超过osd_scrub_max_interval时，无论时间窗口是否允许，都会执行清理。</li></ul><p><code>osd_scrub_during_recovery</code> ：允许在 OSD 上的 PG 正在进行恢复时进行清理</p><p><code>osd_scrub_load_threshold</code> ：当系统负载除以 CPU 数量低于此值时，允许清理</p><ul><li>标准化最大负载。当系统负载高于此数字时，Ceph 将不会进行清理</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/scrubber/osd_scrub_sched.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScrubQueue::scrub_load_below_threshold</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="number">1.</span> 调用getloadavg函数获取系统最近<span class="number">1</span>分钟、<span class="number">5</span>分钟和<span class="number">15</span>分钟的平均负载，存储在loadavgs数组中。</span><br><span class="line">        如果无法获取平均负载，则打印错误信息并返回<span class="literal">false</span>。</span><br><span class="line">	<span class="number">2.</span> 计算每个CPU的平均负载，如果系统有多个CPU，则将总平均负载除以CPU数量；如果系统没有可用的CPU，则直接使用总平均负载。</span><br><span class="line">	<span class="number">3.</span> 如果每个CPU的平均负载低于配置文件中设定的osd_scrub_load_threshold阈值，则打印相关信息并返回<span class="literal">true</span>。</span><br><span class="line">	<span class="number">4.</span> 如果当前平均负载低于每日平均负载且低于<span class="number">15</span>分钟平均负载，则打印相关信息并返回<span class="literal">true</span>。</span><br><span class="line">	<span class="number">5.</span> 如果以上条件都不满足，则打印相关信息并返回<span class="literal">false</span>。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要大于0<ul><li>当设置为0时，理论上意味着只要系统有任何负载（即使非常轻微）， Scrub操作就不会启动，这显然是不合理的限制。</li><li>如果设置为负数，则逻辑上更加无法解释，因为系统负载（如CPU负载平均值）总是非负的，负的阈值无法用来进行有效的比较判断。</li></ul></li></ul><p><code>osd_scrub_min_interval</code> ：当Ceph存储集群负载较低时，每个PG的两次清理的最小时间间隔</p><p><code>osd_scrub_max_interval</code> ：当Ceph存储集群负载较低时，每个PG的两次清理的最大时间间隔</p><ul><li>osd_scrub_min_interval &lt; osd_scrub_max_interval</li></ul><p><code>osd_scrub_chunk_min</code> ：单个块中要清理的最小对象数</p><ul><li>在单个操作期间要清理的对象存储块的最小数量。 Ceph 在清理期间阻止写入单个块。</li></ul><p><code>osd_scrub_chunk_max</code> ：单个块中要清理的最大对象数</p><p><code>osd_scrub_sleep</code> ：在清理过程中注入延迟的持续时间</p><ul><li>清理下一组对象（下一个块）之前的睡眠时间（以秒为单位）。增加此值将减慢清理的总体速度，从而减少清理对客户端操作的影响。</li><li>当使用 mClock 调度程序时，此设置将被忽略。</li></ul><p><code>osd_deep_scrub_interval</code> ：深度擦洗每个 PG（即验证数据校验和）的最短时间间隔</p><ul><li>osd_deep_scrub_interval大于等于 osd_scrub_max_interval</li></ul><p><code>osd_scrub_interval_randomize_ratio</code> ：清洗间隔的随机变化率</p><ul><li>这通过随机改变擦洗间隔来防止擦洗“踩踏”，以便它们在一周内很快均匀分布</li><li>在为 PG 安排下一个清理作业时，向 osd_scrub_min_interval 添加随机延迟。这个随机延迟是一个小于 osd_scrub_min_interval <em>osd_scrub_interval_randomized_ratio 的随机值。默认设置在整个允许的时间窗口 [1, 1.5] </em>osd_scrub_min_interval 内展开清理。</li></ul><p><code>osd_deep_scrub_stride</code> ：深度清理期间一次从对象读取的字节数</p><p><code>osd_scrub_auto_repair</code> ：自动修复擦洗过程中检测到的损坏对象。</p><ul><li>但是，如果发现超过 osd_scrub_auto_repair_num_errors 个错误，则不会执行修复。</li></ul><p><code>osd_scrub_auto_repair_num_errors</code> ：要自动修复的最大检测到的错误数</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><code>osd_op_num_shards</code> ：为给定 OSD 分配的 shards 数量。每个 SHARD 都有自己的处理队列。OSD上的PG在 shard 中均匀分布。</p><ul><li>重启后生效</li><li>如果非零，此设置将覆盖 _ssd 和 _hdd。</li></ul><p><code>osd_op_num_shards_hdd</code> ：为给定 OSD（对于机械硬盘）分配的 shard 数量。</p><ul><li>重启后生效</li></ul><p><code>osd_op_num_shards_ssd</code> ：为给定 OSD（对于固态硬盘）分配的 shard 数量。</p><ul><li>重启后生效</li></ul><p><code>osd_op_queue</code> ：要使用的操作优先级队列算法</p><ul><li><p>设置了用于对每个 OSD 内的操作进行优先级排序的队列类型。两个队列都具有严格的子队列，该子队列在正常队列之前出队。普通队列在不同的实现中是不同的。</p><ul><li><p>WeightedPriorityQueue (wpq) 根据其优先级使操作出队，以防止任何队列饥饿。当少数 OSD 比其他 OSD 过载时，WPQ 应该会有所帮助。</p></li><li><p>mClockQueue (mclock_scheduler) 根据操作所属的类（恢复、清理、snaptrim、客户端操作、osd 子操作）对操作进行优先级排序。</p><p><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/rados/configuration/osd-config-ref/#qos-based-on-mclock">QoS Based on mClock</a>.</p></li><li><p>debug_random ：调试用，完全随机</p></li></ul></li><li><p>重启后生效</p></li></ul><p><code>osd_op_queue_cut_off</code> ：高优先级 OPS 和低优先级 OPS 之间的阈值</p><ul><li>使用严格优先级排序的高优先级 OPS 和使用可能包含或可能不包含优先级的公平性算法的低优先级 OPS 之间的阈值</li></ul><p><strong>优先级相关</strong></p><p>值越大，优先级越大</p><p><code>osd_client_op_priority</code> ：为客户端操作设置的优先级。该值与下面的osd_recovery_op_priority 相关。默认情况下强烈支持客户端操作而不是恢复。</p><ul><li>63</li></ul><p><code>osd_recovery_op_priority</code> ：相对于客户端操作的恢复操作的优先级（如果池的 recovery_op_priority 未指定）。默认值优先考虑客户端操作（见上文）而不是恢复操作。</p><ul><li>您可以通过降低该值以提高客户端操作的优先级，或通过增加该值以有利于恢复，来调整客户端影响与恢复集群运行状况的时间之间的权衡。</li><li>3</li></ul><p><code>osd_scrub_priority</code> ：工作队列中清理操作的优先级</p><ul><li>当池未指定 scrub_priority 值时，计划清理的默认工作队列优先级。当清理阻塞客户端操作时，可以将其提高到 osd_client_op_priority 的值</li><li>5</li></ul><p><code>osd_requested_scrub_priority</code> ：为工作队列中的用户清理请求设置优先级。</p><ul><li>当清理阻碍客户端操作时，如果该值小于 osd_client_op_priority，则可以将其提升至 osd_client_op_priority 的值。</li></ul><p><code>osd_snap_trim_priority</code> ：为快照修剪工作队列设置的优先级。</p><p><code>osd_snap_trim_sleep</code> ：下次对齐修剪前的睡眠时间（以秒为单位）（覆盖以下值）</p><ul><li><p>不为0，则下列参数不生效</p></li><li><p><code>osd_snap_trim_sleep_hdd</code> ：HDD 下次对齐修剪前的睡眠时间（以秒为单位）</p></li><li><code>osd_snap_trim_sleep_ssd</code> ：SSD下次对齐修剪前的睡眠时间（以秒为单位）</li><li><code>osd_snap_trim_sleep_hybrid</code> ：当数据在 HDD 上而日志在 SSD 上时，在下一次快照修剪之前进入睡眠状态的时间（以秒为单位）</li></ul><p><strong>操作时长</strong></p><p><code>osd_op_thread_timeout</code> ：Ceph OSD 守护进程操作线程超时（以秒为单位）</p><ul><li>控制的是单个操作线程的超时，可能会导致线程被终止。</li></ul><p><code>osd_op_thread_suicide_timeout</code> ：</p><ul><li>osd_op_thread_timeout 定义了单个操作线程的超时时间。这是单个操作线程等待超时的时间量。 osd_op_thread_suicide_timeout 定义了整个 OSD 操作线程的超时时间。这是 OSD 在认为情况严重并关闭或“自杀”之前等待的时间量。 本质上，如果一个单独的线程超时，其他线程还有一段缓冲时间来完成它们的操作，在此之前，由于长时间的没有响应，整个 OSD 守护进程不会决定关闭。因此，使 osd_op_thread_timeout 小于 osd_op_thread_suicide_timeout 可以确保系统在单个线程超时的情况下有机会恢复，而不会过早地终止整个守护进程。</li></ul><p><code>osd_op_complaint_time</code> ：经过指定的秒数后，操作将变得值得投诉。</p><ul><li>控制的是整个操作的投诉阈值，仅用于生成警告。</li></ul><p><code>osd_op_history_size</code> ：要跟踪的已完成操作的最大数量。</p><ul><li>默认值是20，意味着OSD会记录最近完成的20个操作的信息。</li></ul><p><code>osd_op_history_duration</code> ：要跟踪的最早完成的操作。</p><ul><li>这个参数的默认值是600秒（10分钟），意味着OSD会记录过去10分钟内完成的操作的信息。</li></ul><p><code>osd_op_log_threshold</code> ：一次显示多少个操作日志。</p><p><code>osd_enable_op_tracker</code></p><p><code>osd_target_transaction_size</code> ：设置了 OSD 在处理 I/O 请求时目标事务的大小（以字节为单位），影响 OSD 将多个小的 I/O 操作打包成一个事务来进行处理的行为。这对于优化性能和资源使用非常重要。</p><h3 id="snap"><a href="#snap" class="headerlink" title="snap"></a>snap</h3><p><code>osd_max_snap_prune_intervals_per_epoch</code> ：用于控制每个 epoch（周期）内 OSD 可以修剪（prune）快照（snapshots）的最大间隔次数。这对于管理和优化快照的删除过程非常重要，特别是在有大量快照的场景中。</p><p><code>osd_rollback_to_cluster_snap</code> ：操作跟踪器是一个调试工具，有助于跟踪和识别在 OSD（对象存储守护进程）中长时间运行或卡住的操作。启用操作跟踪器后，您可以获取每个操作的详细信息，这对于诊断性能问题或其他 Ceph 集群中的问题非常有用。</p><h3 id="mclock"><a href="#mclock" class="headerlink" title="mclock"></a>mclock</h3><p><code>osd_async_recovery_min_cost</code> ：当前日志条目差异和历史丢失对象数量的混合度量，在适当的情况下，我们切换到使用异步恢复</p><p><code>osd_push_per_object_cost</code> ：服务 push 操作的开销</p><p><code>osd_mclock_profile</code> ：要使用的 mclock 配置文件</p><ul><li><p>此选项指定要启用的 mclock 配置文件 - 内置配置文件集或自定义配置文件中的一个。</p></li><li><p>仅在 osd_op_queue = mclock_scheduler 时需要考虑</p></li><li><p>为custom时，才可修改 预留、权重、限制</p><p><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/rados/configuration/mclock-config-ref/#steps-to-enable-mclock-profile:~:text=Care%20must%20be%20taken%20to%20change%20the%20reservations%20of%20other%20services%20like%20recovery%20and%20background%20best%20effort%20accordingly%20to%20ensure%20that%20the%20sum%20of%20the%20reservations%20do%20not%20exceed%20the%20maximum%20proportion%20(1.0">预留和小于1</a>%20of%20the%20IOPS%20capacity%20of%20the%20OSD)</p><ul><li><p><code>osd_mclock_scheduler_client_res</code> ：为每个客户端的 IO 比例（默认）预留。默认值 0 指定可能的最低预留。任何大于 0 且最高为 1.0 的值都指定要为每个客户端保留的最小 IO 比例，以 OSD 最大 IOPS 容量的一小部分为单位。</p><p>仅当 osd_op_queue = mclock_scheduler 时才生效</p></li><li><p><code>osd_mclock_scheduler_client_wgt</code> ：每个客户端预留的IO权重。</p><p>可以大于1，是相对值</p></li><li><p><code>osd_mclock_scheduler_client_lim</code> ：每个客户端的 IO 预留的 limit（默认值）。默认值 0 指定不强制执行限制，这意味着每个客户端都可以使用 OSD 的最大可能 IOPS 容量。任何大于 0 且最高为 1.0 的值都指定每个客户端收到的预留 IO 上限，以 OSD 最大 IOPS 容量的一小部分表示。</p></li><li><p><code>osd_mclock_scheduler_background_recovery_res</code> ：为后台 recovery 预留的 IO 比例（默认）。默认值 0 指定可能的最低预留。任何大于 0 且最高为 1.0 的值都指定为后台恢复操作保留的最小 IO 比例，以 OSD 最大 IOPS 容量的一小部分为单位。</p></li><li><p><code>osd_mclock_scheduler_background_recovery_wgt</code> ：每次进行后台恢复的 IO 预留权重</p></li><li><p><code>osd_mclock_scheduler_background_recovery_lim</code> ：每个客户端的后台恢复预留的 limit（默认值）。默认值 0 指定无限制强制执行，这意味着后台恢复操作可以使用 OSD 的最大可能 IOPS 容量。任何大于 0 且最高为 1.0 的值都指定后台恢复操作收到的预留 IO 上限，以 OSD 最大 IOPS 容量的一小部分表示</p></li><li><p><code>osd_mclock_scheduler_background_best_effort_res</code> ：为后台best_effort保留的 IO 比例（默认）。默认值 0 指定可能的最低预留。任何大于 0 且最高为 1.0 的值都指定为后台best_effort操作保留的最小 IO 比例，以 OSD 最大 IOPS 容量的一小部分为单位。</p></li><li><p><code>osd_mclock_scheduler_background_best_effort_wgt</code> ：每次进行后台 best_effort 的 IO 预留权重</p></li><li><p><code>osd_mclock_scheduler_background_best_effort_lim</code> ：每个客户端的后台best_effort 预留的 limit（默认值）。默认值 0 指定无限制强制执行，这意味着后台恢复操作可以使用 OSD 的最大可能 IOPS 容量。任何大于 0 且最高为 1.0 的值都指定后台恢复操作收到的预留 IO 上限，以 OSD 最大 IOPS 容量的一小部分表示</p></li></ul></li></ul><p><code>osd_mclock_max_capacity_iops_hdd</code> ：此选项指定每个 OSD 的最大 OSD 随机写入 IOPS 上限。在启用 dmclock 配置文件时参与 QoS 计算。</p><ul><li>仅 osd_op_queue = mclock_scheduler 考虑</li></ul><p><code>osd_mclock_max_capacity_iops_ssd</code> ：每个 OSD（对于固态介质）要考虑的最大随机写入 IOPS 上限（块大小为 4 KiB）</p><p><code>osd_mclock_max_sequential_bandwidth_hdd</code> ：OSD 考虑的最大顺序带宽（以字节/秒为单位）（对于旋转媒体）</p><p><code>osd_mclock_max_sequential_bandwidth_ssd</code> ：OSD 考虑的最大顺序带宽（以字节/秒为单位）（对于固态媒体）</p><p><code>osd_mclock_force_run_benchmark_on_init</code> ：在 OSD 初始化/启动时强制运行 OSD 基准测试</p><p><code>osd_mclock_skip_benchmark</code> ：跳过 OSD 初始化/启动的 OSD 基准测试</p><p><code>osd_mclock_iops_capacity_threshold_hdd</code> ：阈值 IOPS 容量（块大小为 4KiB），超过该容量将忽略 OSD（针对旋转媒体）的 OSD 基准测试结果</p><p><code>osd_mclock_iops_capacity_threshold_ssd</code> ：阈值 IOPS 容量（块大小为 4KiB），超过该容量将忽略 OSD（对于固态介质）的 OSD 基准测试结果</p><h3 id="backfilling"><a href="#backfilling" class="headerlink" title="backfilling"></a>backfilling</h3><p><code>osd_max_backfills</code> ：每个 OSD 本地和远程的回填或恢复的最大并发数</p><ul><li>允许回填到单个 OSD 或从单个 OSD 回填的最大数量。请注意，这对于读取和写入操作是分开应用的。</li><li>每个 OSD 可以有osd_max_backfills本地预留和相同的远程预留。因此，值 1 允许此 OSD 作为 1 个 PG 主节点参与恢复，并作为另一个恢复 PG 的 1 个分片参与。</li></ul><p><code>osd_backfill_scan_min</code> ：每次回填扫描的最小对象数。</p><p><code>osd_backfill_scan_max</code> ：每次回填扫描的最大对象数。</p><p><code>osd_backfill_retry_interval</code> ：回填 重试请求之前等待的秒数。</p><h3 id="osdmap"><a href="#osdmap" class="headerlink" title="osdmap"></a>osdmap</h3><p><code>osd_map_dedup</code> ：控制 OSD map是否进行冗余和去重</p><ul><li>OSD map 是集群的核心数据结构，它存储了数据在 OSD 上的分布信息。</li><li>如果 <code>osd_map_dedup</code> 设置为 <code>true</code>，则 OSD 映射可能会进行冗余和去重，以减少存储空间的使用并提高数据的冗余度。如果设置为 <code>false</code>，则 OSD 映射可能不会进行冗余和去重，这可能会导致存储空间的浪费。</li></ul><p><code>osd_map_cache_size</code> ：要保留缓存的 OSD map的数量。</p><p><code>osd_map_message_max</code> 和 <code>osd_map_message_max_bytes</code> 是两个高级配置参数，它们与 OSD Map 的消息传递相关。</p><ul><li><p><code>osd_map_message_max</code> 参数用于设置在单个消息中可以包含的最大 OSD map条目数量。</p><p>当 OSD 映射发生变化时，如 OSD 加入或离开集群，这些变化需要通过消息传递给集群中的其他守护进程。通过限制单个消息中的 OSD 映射数量，可以控制消息的大小，从而影响网络带宽的使用和集群的通信效率。</p></li><li><p><code>osd_map_message_max_bytes</code> 参数用于设置在单个消息中可以包含的 OSD map 的总字节数。</p><p>这个参数用于控制消息的大小，以影响网络带宽的使用和集群的通信效率。</p></li></ul><p><code>mon_max_snap_prune_per_epoch</code> ：在单个OSDMap epoch 中处理的最大裁剪快照数</p><p><code>mon_min_osdmap_epochs</code> ：OSDMap要存储的最小 epoch 数</p><h3 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h3><p><code>osd_recovery_delay_start</code> ：对等互连完成后，Ceph 将延迟指定的秒数，然后再开始恢复 RADOS 对象。</p><p><code>osd_mclock_override_recovery_settings</code> ：设置此选项将覆盖 mClock 调度程序的 recovery/backfill 的limit值。</p><ul><li><p>此选项设置为 true 后，将启用mClock调度程序活动时的max recovery active和max backfills 的limit值的覆盖。当mClock调度程序处于活动状态时，这些选项不可修改。如果没有设置 为true 而尝试修改这些值，将重置 recovery 或 backfilling 参数为其默认值。</p></li><li><p>osd_max_backfills</p></li><li>osd_recovery_max_active：同一时刻每个 OSD 活动的恢复请求数。更多请求将加速恢复，但请求会增加集群的负载。<ul><li>每个 OSD 的同时活动恢复操作数（如果非零，则覆盖 _ssd 和 _hdd）</li><li><code>osd_recovery_max_active_hdd</code> ：每个 OSD 的同时活动恢复操作数（对于硬盘）</li><li><code>osd_recovery_max_active_ssd</code> ：每个 OSD 的同时活动恢复操作数（对于固态）</li></ul></li></ul><p><code>osd_recovery_max_chunk</code> ：恢复操作可以携带的数据块的最大总大小。</p><p><code>osd_recovery_max_single_start</code> ：当 OSD 恢复时，每个 OSD 新启动的恢复操作的最大数量。</p><p><code>osd_recover_clone_overlap</code> ：在恢复期间保留克隆重叠。应始终设置为 true。</p><ul><li><code>osd_recover_clone_overlap_limit</code></li></ul><p><code>osd_recovery_sleep</code> ：在下一次恢复或回填操作之前的睡眠时间（以秒为单位），增加此值将减慢恢复操作，而客户端操作受影响较小。<strong>可以为0</strong></p><ul><li><p><code>osd_recovery_sleep_hdd</code> ：在下一次恢复或回填 HDD 操作之前的睡眠时间（以秒为单位）</p></li><li><p><code>osd_recovery_sleep_ssd</code> ：SSD 下次恢复或回填操作之前的睡眠时间（以秒为单位）</p></li><li><p><code>osd_recovery_sleep_hybrid</code> ：当数据在 HDD 上且日志在 SSD 上时，在下一次恢复或回填操作之前休眠的时间（以秒为单位）</p><p>当 OSD 数据位于 HDD 上并且 OSD 日志/WAL+DB 位于 SSD 上时，在下一次恢复或回填操作之前休眠的时间（以秒为单位）。</p></li></ul><p><code>osd_min_recovery_priority</code> ：低于该优先级不执行恢复的最小优先级</p><ul><li>此处的目的是防止集群执行低于此阈值的任何低优先级工作（例如，重新平衡），并仅专注于更高优先级的工作（例如，复制降级对象）</li></ul><p><code>osd_recovery_priority</code> ：工作队列中恢复的优先级</p><ul><li>与 pool 的recovery_priority无关</li></ul><h3 id="tiering分层"><a href="#tiering分层" class="headerlink" title="tiering分层"></a>tiering分层</h3><p><code>osd_agent_max_ops</code> ：分层代理的最大并发分层操作</p><ul><li>高速模式下每个分层代理同时刷新操作的最大数量。</li></ul><p><code>osd_agent_max_low_ops</code> ：分层代理的最大并发 低优先级 分层操作</p><ul><li>始终大于0，<strong>0 或负值</strong>: 这会导致代理不能执行任何刷新操作，可能会阻止数据的有效传输或存储，导致系统性能和稳定性问题。</li><li><strong>0</strong>：表示没有操作同时进行，这可能会影响系统的效率，因为分层代理将不会执行任何刷新操作。</li><li><strong>负数</strong>：在大多数系统中，负数通常没有意义，并且可能会引起错误或异常行为，因为它们不符合操作数量的逻辑概念。</li></ul><h3 id="PG相关"><a href="#PG相关" class="headerlink" title="PG相关"></a>PG相关</h3><p><code>mon_max_pg_per_osd</code> ：集群允许的每个 OSD 的最大 PG 数</p><ul><li>如果每个 OSD 的 PG 数量超过此值，则在“ceph 状态”中将显示运行状况警告。这也用于自动化 PG 管理，作为一些池的pg_num可以缩小以增加其他池pg_num的阈值。</li><li>在Ceph存储集群中，PG（Placement Group，放置组）是数据分布和负载均衡的基本单元。每个OSD（Object Storage Daemon，对象存储守护进程）可以负责多个PG，但过多的PG可能会导致单个OSD过载，影响性能。</li><li>这个参数限制了每个 OSD 可以容纳的最大 PG 数量。在配置 <code>osd_pool_default_pg_num</code> 时，需要考虑到这个限制，以避免超过每个 OSD 的 PG 数量</li><li>这个参数还用于Ceph的自动PG管理。当需要增加某些池的PG数量时，如果超过了这个阈值，Ceph的自动平衡器可能会缩减其他池的PG数量（即减少<code>pg_num</code>），以释放资源，从而允许增加其他池的PG数量。</li></ul><p><code>mon_target_pg_per_osd</code> ：自动化 PG 管理为每个 OSD 创建如此多的 PG</p><ul><li>当创建池时，automated PG management将尝试达到这么多PG，</li><li>一些场景中，可能超过这个目标达到 <code>mon_max_pg_per_osd</code> 的限制</li><li>更小的 pg_per_osd 可能被创建，如果集群违背充分利用</li></ul><p><code>mon_max_pool_pg_num</code> ：每个池的归置组的最大数量。</p><p><code>mon_pg_stuck_threshold</code> ：在这段时间之后，PGS 可以被视为stuck inactive, unclean 等的秒数</p><ul><li><code>dump_stuck</code> 有更详细介绍</li></ul><p><code>mon_pg_warn_min_per_osd</code> ：在我们警告管理员之前，每个 （in） osd 的最小 PG 数量</p><ul><li>如果 OSD 中每个 PG 的平均数量低于此数字，则引发 HEALTH_WARN。非正数会禁用此功能</li></ul><p><code>osd_max_pg_per_osd_hard_ratio</code> ：如果 OSD 服务的 PG 数量超过 osd_max_pg_per_osd_hard_ratio * mon_max_pg_per_osd，则 OSD 将停止创建新 PG。</p><ul><li>在 OSD 拒绝创建新 PG 之前，集群允许每个 OSD 的 PG 数量的比率。</li></ul><p><code>mon_pg_warn_min_objects</code> ：当集群中的RADOS对象总数低于此数字，则不发出警告</p><p><code>mon_pg_warn_min_pool_objects</code> ：不要对 RADOS 对象计数低于此数字的池发出警告</p><p><code>mon_pg_check_down_all_threshold</code> ：OSD <code>down</code> 的阈值，之后我们检查所有 PG 是否已过时。</p><p><code>mon_pg_warn_max_object_skew</code> ：每个PG中，最大偏移的平均数</p><ul><li>如果任何池的每个 PG 的平均 RADOS 对象计数大于 mon_pg_warn_max_object_skew 乘以所有池的每个 PG 的平均 RADOS 对象计数，则引发 HEALTH_WARN。</li><li>零或非正数会禁用此功能。请注意，此选项适用于 ceph-mgr 守护进程。</li></ul><p><code>mon_delta_reset_interval</code> ：“CEPH 状态”下费率计算的窗口持续时间</p><ul><li>在我们将 PG 增量重置为 0 之前，不活动的秒数。我们跟踪每个池的已用空间的增量，因此，例如，我们可以更轻松地了解恢复进度或缓存层的性能。但是，如果某个池没有报告任何活动，我们只需重置该池的增量历史记录。</li></ul><p><code>osd_max_pgls</code> ：要列出的归置组的最大数量。请求大量数据的客户端可能会占用 Ceph OSD 守护进程。</p><p><code>osd_pool_default_pg_num</code> ：新池的 PG 数</p><ul><li>默认值“osd_pool_default_pg_autoscale_mode”为“on”，除非用户指定pg_num，否则新池的 PG 数将从 1 pg 开始。</li></ul><p><code>osd_pool_default_pgp_num</code></p><p><code>osd_pool_default_pg_autoscale_mode</code> ：新池的默认 PG 自动缩放行为</p><ul><li>在默认值为“on”的情况下，自动缩放程序将启动一个具有 1 pg 的新池，除非用户指定pg_num。</li></ul><p><code>osd_calc_pg_upmaps_local_fallback_retries</code> 和 <code>osd_calc_pg_upmaps_aggressively</code> 这两个 Ceph 配置参数都涉及到 OSD 在处理 PG 映射时的行为，但它们控制的是不同的方面，并没有直接的依赖关系。</p><ul><li><code>osd_calc_pg_upmaps_aggressively</code> 是一个布尔值选项，用于指示 OSD 是否应该更加积极地计算 PG 的映射。当这个选项被启用时，OSD 会尝试更多的可能性来寻找可以优化的 PG 映射，可能会进行更加深入的搜索和更多的重映射尝试。<ul><li>启用这个选项也可能增加OSD的计算开销，因为更积极的计算需要更多的CPU资源。</li><li>通常，只有在执行特定的维护任务或在特定情况下，例如在添加或移除OSD之后，重新平衡PGs时，才会考虑更改此设置。</li></ul></li><li><code>osd_calc_pg_upmaps_local_fallback_retries</code> 是一个无符号整数值选项，它限制了在每个迭代周期中，为特定的过满或欠满 OSD 尝试取消映射或重新映射的最大 PG 数量。这个选项是为了防止在单个迭代中尝试过多的 PG 重映射操作，从而避免对 OSD 造成过大的压力和性能影响。</li></ul><p>虽然这两个选项都涉及到 PG 映射的优化过程，但它们的作用点是不同的。<code>osd_calc_pg_upmaps_aggressively</code> 决定了 PG 映射优化的策略是否更加积极，而 <code>osd_calc_pg_upmaps_local_fallback_retries</code> 则是在这个策略执行时，限制了每个迭代中可以进行的最大操作数。因此，即使 <code>osd_calc_pg_upmaps_aggressively</code> 被启用，<code>osd_calc_pg_upmaps_local_fallback_retries</code> 仍然可以限制重映射的频率，以保护系统资源。</p><p><code>osd_min_pg_log_entries</code> ：修剪日志文件时要维护的 PG log 的最小数量。</p><p><code>osd_max_pg_log_entries</code> ：修剪日志文件时要维护的 PG log 的最大数量。</p><p><code>osd_pg_max_concurrent_snap_trims</code> ：PG的并行快照裁剪的数量</p><p><code>osd_pg_epoch_persisted_max_stale</code> ：</p><p><code>osd_target_pg_log_entries_per_osd</code> ：OSD 上总 PG 条目的目标数 - 每个 pg 受以下最小和最大选项的限制</p><p><code>osd_min_pg_log_entries</code> ：PG log中要维护的最小条目数</p><p><code>osd_max_pg_log_entries</code> ：PG log中要维护的最大条目数</p><p><code>osd_pg_log_dups_tracked</code> ：有多少个版本回退跟踪以检测重复操作;这与常规 PG 日志条目和其他最小 DUP 检测条目相结合</p><p><code>osd_object_clean_region_max_num_intervals</code> ：clean_offsets 中的间隔数</p><ul><li>部分恢复使用多个区间来记录对象的干净部分。当区间数量大于 osd_object_clean_region_max_num_intervals 时，将裁剪最小区间（0将恢复整个对象数据区间）。</li></ul><p><code>osd_pg_log_trim_min</code> ：一次要修剪的最小日志条目数。这使我们能够在更大的批次中进行修剪，而不是在每次写入时进行修剪</p><p><code>osd_pg_object_context_cache_count</code> 是 Ceph 分布式存储系统中的一个配置选项，用于设置每个 OSD（对象存储守护进程）中 PG（放置组）对象上下文缓存的条目数。该缓存用于存储对象上下文，以加速对对象的重复访问，提高性能。</p><p><code>osd_loop_before_reset_tphandle</code> 是 Ceph 分布式存储系统中的一个配置选项，用于控制在 OSD（对象存储守护进程）的主循环中，在重置线程池句柄之前允许的循环次数。该配置项主要用于调试和性能优化。</p><p><code>mon_reweight_max_change</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/PGMap.cc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reweight::by_utilization</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> OSDMap &amp;osdmap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PGMap &amp;pgm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> oload,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> max_changef,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> max_osds,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> by_pg, <span class="type">const</span> set&lt;<span class="type">int64_t</span>&gt; *pools,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> no_increasing,</span></span></span><br><span class="line"><span class="params"><span class="function">    mempool::osdmap::map&lt;<span class="type">int32_t</span>, <span class="type">uint32_t</span>&gt;* new_weights,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::stringstream *ss,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::string *out_str,</span></span></span><br><span class="line"><span class="params"><span class="function">    ceph::Formatter *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">验证输入：检查 oload 参数是否超过<span class="number">100</span>%，因为它被用作与平均使用率相乘的阈值。</span><br><span class="line"></span><br><span class="line">计算平均使用率：</span><br><span class="line"></span><br><span class="line">根据 PG 数量（by_pg=<span class="literal">true</span>）或直接依据磁盘使用量（by_pg=<span class="literal">false</span>）计算 OSD 的平均使用率。</span><br><span class="line">统计每个 OSD 的 PG 数量（如果按 PG 计算）或直接统计 OSD 的磁盘使用情况。</span><br><span class="line"></span><br><span class="line">计算调整因子：确定哪些 OSD 超过了平均使用率乘以 oload 的阈值，以及哪些 OSD 使用率低于平均值且允许增加权重（除非 no_increasing 设置为真）。</span><br><span class="line"></span><br><span class="line">调整权重：对使用率过高的 OSD 降低权重，对使用率较低的 OSD（在一定条件下）增加权重，同时限制调整幅度不超过 max_changef 指定的百分比，并确保调整的 OSD 数量不超过 max_osds。</span><br><span class="line"></span><br><span class="line">应用变更并输出结果：将新的权重应用于临时的 OSD 映射，并总结映射统计信息到输出字符串或通过格式化器输出。最后，返回实际调整了权重的 OSD 数量。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pool相关"><a href="#pool相关" class="headerlink" title="pool相关"></a>pool相关</h3><p><code>osd_pool_default_type</code> ：要创建的池的默认类型</p><p><code>osd_pool_default_flags</code> ：(整数) 新创建的存储池将设置的标志</p><ul><li>为新创建的存储池指定一组标志。这些标志可以影响存储池的行为和性能，包括但不限于数据放置策略、副本行为、回收站特性等。</li><li>简化和标准化创建过程。例如，如果你经常使用某些特定的标志组合，你可以将其设置为默认值，以便在创建新池时自动应用这些设置。</li></ul><p><code>osd_default_data_pool_replay_window</code> ：OSD 等待客户端重播请求的时间（以秒为单位）。</p><p><code>osd_pool_default_size</code> ：指定了新创建存储池的默认副本数量，就是池副本数。</p><ul><li><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/quincy/rados/configuration/pool-pg-config-ref/#manual-tuning:~:text=%23%20By%20default%2C%20Ceph%20makes%203%20replicas%20of%20RADOS%20objects.%20If%20you%20want%20to%20maintain%20four%0A%09%23%20copies%20of%20an%20object%20the%20default%20value%2D%2Da%20primary%20copy%20and%20three%20replica%0A%09%23%20copies%2D%2Dreset%20the%20default%20values%20as%20shown%20in%20%27osd_pool_default_size%27">https://docs.ceph.com/en/quincy/rados/configuration/pool-pg-config-ref/#manual-tuning:~:text=%23%20By%20default%2C%20Ceph%20makes%203%20replicas%20of%20RADOS%20objects.%20If%20you%20want%20to%20maintain%20four%0A%09%23%20copies%20of%20an%20object%20the%20default%20value%2D%2Da%20primary%20copy%20and%20three%20replica%0A%09%23%20copies%2D%2Dreset%20the%20default%20values%20as%20shown%20in%20%27osd_pool_default_size%27</a>.</li></ul><p><code>osd_pool_default_min_size</code> ：对于新创建的复制池，在 degraded 状态下允许写入的最小副本数。在数据恢复过程中，只要达到了这个数量的副本，写操作就可以正常进行。如果未满足最小值，Ceph 将不会向客户端确认 I/O，这可能会导致数据丢失。</p><ul><li><p>这个值应该小于或等于 <code>osd_pool_default_size</code>。</p></li><li><p>在 Ceph 中，复制池（replicated pools）是通过在多个 OSD 上保存数据的副本来实现数据冗余的。如果一个池中的一个或多个副本因为某种原因（如 OSD 故障）而不可用，那么这个池就被认为是处于降级状态。</p></li><li>如果池的副本数（<code>osd_pool_default_size</code>）设置为3，而 <code>osd_pool_default_min_size</code> 设置为2，那么即使有一个副本不可用，写操作仍然可以继续进行，因为仍然有两个可用的副本。</li><li>如果 <code>osd_pool_default_min_size</code> 被设置为0，对于任何新创建的复制池，最小写副本数将是池的副本数的一半，向下取整。</li></ul><p><code>osd_pool_default_read_lease_ratio</code> ：池的默认read_lease_ratio，作为 osd_heartbeat_grace 的倍数</p><ul><li>应该小于或等于1.0，以确保在我们决定将一个对等OSD标记为宕机时，读取租约已经过期。</li></ul><h4 id="CRUSH"><a href="#CRUSH" class="headerlink" title="CRUSH"></a>CRUSH</h4><p><code>osd_crush_chooseleaf_type</code>：选择合适的CRUSH leaf 类型</p><ul><li>0 单节点集群</li><li>1 单机架上的多节点集群</li><li>2 对于一个机箱中具有多个主机的多节点、多机箱集群</li><li>3 跨机架的多主机集群</li></ul><p><code>osd_crush_initial_weight</code> ：设置新创建OSD的CRUSH权重</p><ul><li><p>如果 &gt;= 0，则新创建的 OSD 的初始 CRUSH 权重</p></li><li><p>如果此值为负数，则使用 OSD 的大小（以 TiB 为单位）。</p></li></ul><p><code>osd_pool_default_crush_rule</code> ：为新创建的池设置默认的 CRUSH 规则。</p><ul><li>每个存储池都可以有自己的 CRUSH 规则，CRUSH（Controlled Replication Under Scalable Hashing）规则是 Ceph 中用于数据分布和副本放置的算法，决定了数据及其副本如何在整个集群中的不同 OSD（对象存储守护进程）上分布。</li><li>当创建新的存储池时，如果没有明确指定 CRUSH 规则系统将使用由 <code>osd_pool_default_crush_rule</code> 参数指定的默认规则。</li><li>默认值 -1 表示“选择具有最小数字 ID 的规则并使用它”。这是为了在没有规则 0 的情况下创建池。</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><code>osd_tier_default_cache_hit_set_type</code> ：指定缓存命中集合的类型</p><ul><li><strong>枚举值</strong>：<code>bloom</code>, <code>explicit_hash</code>, <code>explicit_object</code></li><li><p>与缓存相关的策略，用于确定如何跟踪和优化缓存命中</p></li><li><p><code>osd_pool_default_hit_set_bloom_fpp</code> ：Bloom 过滤器（Bloom Filter）的误报率（False Positive Probability，FPP）</p><ul><li>Bloom 过滤器是一种概率型数据结构，用于检测一个元素是否存在于集合中。设置较低的 FPP 可以减少误报率，但可能会增加内存消耗。</li></ul></li></ul><p><code>osd_pool_default_cache_target_dirty_ratio</code> ：用于配置缓存中脏数据的最大比例。</p><ul><li>脏数据是指那些已经从源头数据源中更新，但尚未同步到后端存储的数据。</li><li>当缓存达到这个脏数据比例时，可能会触发缓存刷新操作</li></ul><p><code>osd_pool_default_cache_target_dirty_high_ratio</code> ：</p><ul><li>配置缓存中脏数据的高比例阈值。当缓存中的脏数据比例超过这个阈值时，可能会采取某些措施，例如减少写入操作，以避免缓存进一步过载。</li></ul><p><code>osd_pool_default_cache_target_full_ratio</code> ：</p><ul><li>用于配置缓存达到满载的比例阈值。当缓存中的数据达到这个阈值时，可能会采取某些措施，例如减少写入操作，以避免缓存过载。</li></ul><p><code>osd_pool_default_cache_min_evict_age</code> ：配置缓存中对象的最低可清除年龄</p><ul><li>设置合适的年龄阈值可以帮助确保缓存中的数据是最常访问的，同时保持足够的缓存空间来存储新数据。</li></ul><p><code>osd_pool_default_cache_max_evict_check_size</code>：配置缓存中在清除操作中需要检查的最大对象或数据块大小。</p><ul><li>当缓存中的对象或数据块的大小达到或超过这个阈值时，它们可能会被优先考虑清除，以释放缓存空间。</li></ul><p><code>osd_pool_default_cache_min_flush_age</code></p><ul><li>用于配置缓存中对象的最低可刷新时长。这意味着当一个对象在缓存中的存在时间达到或超过这个年龄时，它可能会被刷新到后端存储。</li></ul><p><code>osd_hit_set_namespace</code> ：</p><p><code>osd_hit_set_min_size</code> 和 <code>osd_hit_set_max_size</code> 是两个高级配置参数，它们与缓存策略中的命中集合（hit set）大小有关</p><ul><li><p>命中集合是用于缓存优化的一种数据结构，它包含了最近访问的对象信息。</p></li><li><p><code>osd_hit_set_min_size</code> 可能用于配置缓存中命中集合的最小大小。设置最小大小可以帮助确保缓存中的数据是最常访问的。</p></li><li><code>osd_hit_set_max_size</code> 可能用于配置缓存中命中集合的最大大小。设置最大大小可以帮助确保缓存不会因为命中集合过大而影响性能。</li></ul><p><code>osd_pool_use_gmt_hitset</code> ：用于控制 OSD 在处理 hitset（命中集合）时间戳时是否使用 UTC 时间。</p><ul><li>Hitset 是 Ceph 中用于跟踪对象访问频率的数据结构，它们用于实现缓存剔除策略。</li><li>此设置仅用于与 hammer（及更早）版本的集群兼容。在 Ceph 的某些旧版本（如 hammer 版本）中，hitset 时间戳默认使用本地时间。然而，为了提高跨时区的可移植性和一致性，Ceph 后来切换到了使用 UTC 时间。</li><li>由于这个设置是用于开发者级别的，并且只是为了保持与旧版本的兼容性，大多数新的 Ceph 集群都会使用 UTC 时间戳，因此这个参数通常会被设置为 <code>false</code>。如果你正在运行一个较新的 Ceph 版本，并且不需要与旧版本兼容，那么你可以忽略这个参数。</li></ul><p><code>osd_tier_default_cache_min_read_recency_for_promote</code> ：对象必须出现在其中才能升级的最近命中集数（读取时）</p><h4 id="上层存储"><a href="#上层存储" class="headerlink" title="上层存储"></a>上层存储</h4><p><code>osd_tier_promote_max_objects_sec</code> ：配置 Ceph 存储集群中每秒最多可以提升到上层存储（如 SSD 或 NVMe）的对象数量。</p><ul><li>当文件或对象满足提升条件时，比如它们在缓存中的命中率较低，或者它们的访问频率下降，它们可能会被提升到更快的存储层。</li></ul><p><code>osd_tier_promote_max_bytes_sec</code> ：配置 Ceph 存储集群中每秒最多可以提升到上层存储的对象的总大小</p><ul><li>当文件或对象的总大小达到或超过这个阈值时，它们可能会被提升到更快的存储层。</li></ul><p><code>osd_tier_default_cache_min_read_recency_for_promote</code> ：配置缓存中对象被提升到后端存储的读最小最近访问时间。</p><ul><li>当一个对象在缓存中的最后一次读访问时间达到或超过这个阈值时，它可能会被提升到后端存储。</li></ul><p><code>osd_tier_default_cache_min_read_recency_for_promote</code> ：配置缓存中对象被提升到后端存储的写最小最近访问时间。</p><ul><li>当一个对象在缓存中的最后一次写访问时间达到或超过这个阈值时，它可能会被提升到后端存储。</li></ul><p><code>osd_tier_default_cache_hit_set_grade_decay_rate</code> ：配置缓存中命中集合等级的衰减速度。</p><ul><li>命中集合等级是用于缓存优化的一种数据结构，它反映了对象在缓存中的访问频率和重要性。设置衰减率可以帮助确保缓存中的数据是最常访问的。</li><li>这个参数对于优化缓存性能和容量管理非常重要。设置合适的衰减率可以帮助确保缓存中的空间被有效利用，同时保持足够的缓存空间来存储新数据。</li></ul><p><code>osd_tier_default_cache_hit_set_search_last_n</code> ：配置缓存中命中集合搜索操作中要考虑的最近访问的对象数量。</p><ul><li>确保最近访问的对象被优先考虑。</li></ul><h4 id="纠删码池"><a href="#纠删码池" class="headerlink" title="纠删码池"></a>纠删码池</h4><p><code>osd_pool_default_ec_fast_read</code> ：指定新创建的纠删码池是否默认启用快速读取功能。</p><ul><li>纠删码池是一种数据保护机制，它通过在多个 OSD 上分布数据块和校验块来提供容错能力。</li><li>快速读取功能允许 Ceph 在读取数据时跳过一些校验块的解码过程，从而可能提高读取性能，但可能会降低数据的局部性。</li><li>如果将此参数设置为 <code>true</code>，那么所有新创建的擦除编码池都将默认启用快速读取。如果设置为 <code>false</code>，则新池将不启用此功能。对于现有的池，这个设置不会产生影响，它们需要单独配置 <code>ec_fast_read</code> 参数。</li></ul><p><code>osd_pool_erasure_code_stripe_unit</code> ：设置纠删码池的对象条带块的默认大小（以字节为单位）。</p><ul><li>每个大小为 S 的对象将存储为 N 个条带，每个数据块接收条带单位字节。</li><li>N * stripe_unit 个字节的每个条带将被单独编码/解码。此选项可以被纠删码配置文件中的 stripe_unit 设置覆盖。</li></ul><p><code>osd_pool_default_erasure_code_profile</code> ：新纠缠码池的默认纠删码配置文件</p><p><code>osd_erasure_code_plugins</code> ：要加载的纠删码插件</p><h3 id="osd-other"><a href="#osd-other" class="headerlink" title="osd_other"></a>osd_other</h3><p><code>osd_rocksdb_iterator_bounds_enabled</code> ：omap 迭代器边界是否应用于 rocksdb 迭代器 ReadOptions</p><p><code>osd_default_notify_timeout</code> ：通知传播超时的默认秒数。如果客户端未指定其他值，则使用</p><p><code>osd_check_for_log_corruption</code> ：检查日志文件是否损坏。计算成本可能很高。</p><p><code>osd_delete_sleep</code> ：在下一次删除事务之前休眠的时间（以秒为单位）。这会限制 PG 删除过程。</p><ul><li><code>osd_delete_sleep_hdd</code></li><li><code>osd_delete_sleep_ssd</code></li><li><code>osd_delete_sleep_hybrid</code> ：当 OSD 数据位于 HDD 上且 OSD 日志或 WAL+DB 位于 SSD 上时，下一个删除事务之前休眠的时间（以秒为单位）</li></ul><p><code>osd_command_max_records</code> ：限制要返回的丢失对象的数量。</p><ul><li>不能小于等于0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PrimaryLogPG.cc</span></span><br><span class="line"><span class="built_in">do_command</span>()&#123;</span><br><span class="line">    逻辑不符：该配置项通常用于限制某个操作（如列出对象）能够返回的最大记录数量，如果设置成非正数，意味着不会返回任何结果或者逻辑上不期望的结果，这与大多数应用场景相违背。</span><br><span class="line"></span><br><span class="line">潜在的编程逻辑错误：在提供的代码片段中，若osd_command_max_records小于等于<span class="number">0</span>，循环<span class="keyword">for</span> (; p != needs_recovery_map.<span class="built_in">end</span>() &amp;&amp; num &lt; cct-&gt;_conf-&gt;osd_command_max_records; ++p)将不会执行，因为初始时num为<span class="number">0</span>，导致条件num &lt; cct-&gt;_conf-&gt;osd_command_max_records始终为真（如果配置值是非正数），但循环却因无法进入而实际上什么也不做，这可能并非设计意图。</span><br><span class="line"></span><br><span class="line">最佳实践：通常，此类配置应设定为一个正整数，以合理控制响应的数据量，防止因一次性返回太多数据而导致的性能问题或其他副作用。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>osd_numa_prefer_iface</code> ：首选与存储相同的 numa 节点上的网络接口上的 IP</p><p><code>osd_numa_auto_affinity</code> ：当存储和网络匹配时，自动将关联设置为 NUMA 节点</p><p><code>osd_numa_node</code> ：为 NUMA 节点设置相关性（-1 表示无）</p><ul><li>默认值为-1</li></ul><p><code>osd_smart_report_timeout</code> ：smarctl 运行超时（以秒为单位）</p><h3 id="osd-fail"><a href="#osd-fail" class="headerlink" title="osd fail"></a>osd fail</h3><p><code>osd_failsafe_full_ratio</code> 是 Ceph 分布式存储系统中的一个配置选项，用于设置一个 OSD（对象存储守护进程）达到故障保护满状态的比例阈值。当 OSD 的存储利用率达到或超过这个比例时，Ceph 会采取保护措施来防止数据写入，以避免数据丢失或集群崩溃。</p><p><code>osd_fast_shutdown</code> ：快速、即时关机</p><ul><li>如果将其设置为 false，则 OSD 在收到 SIGINT 或 SIGTERM 或因任何其他原因关闭时，会降低所有状态的拆解速度。这种缓慢的关机主要用于使用 valgrind 进行内存泄漏检查</li></ul><p><code>osd_fast_shutdown_notify_mon</code> ：告诉 mon 有关立即关机时 OSD 关机的信息</p><ul><li>告诉monitor正在立即挂机，有助于处理记录日志消息——来自集群中其他OSD的立即故障报告</li></ul><p><code>osd_fast_fail_on_connection_refused</code> ：如果启用此选项，则已连接的对等点和 MON 会立即将崩溃的 OSD 标记为down（假设崩溃的 OSD 主机仍然存在）。禁用它以恢复旧的行为，但代价是当 OSD 在 I/O 操作过程中崩溃时可能会出现长时间的 I/O 停顿。</p><h2 id="KVStore"><a href="#KVStore" class="headerlink" title="KVStore"></a>KVStore</h2><h3 id="leveldb"><a href="#leveldb" class="headerlink" title="leveldb"></a>leveldb</h3><h3 id="rocksdb-1"><a href="#rocksdb-1" class="headerlink" title="rocksdb"></a>rocksdb</h3><p>RocksDB 是一个高性能的键值存储引擎，广泛应用于 Ceph 的 OSD（对象存储守护进程）中，以管理元数据和小对象</p><p><code>rocksdb_cache_row_ratio</code> 是 Ceph 分布式存储系统中的一个配置选项，用于控制在使用 RocksDB 作为底层存储引擎时缓存中行数据的比例。</p><p><code>rocksdb_cache_shard_bits</code> 参数是用来控制内存中缓存（通常是LRU缓存）的分片数量的。这个值决定了缓存是如何被分割成多个子缓存区域（shards）的，每个shard独立管理自己的部分内存，这样可以减少多线程环境下的锁竞争，提高并发性能。</p><p><code>rocksdb_delete_range_threshold</code> ：当删除多个keys时，调用DeleteRange 所需的keys数量</p><p><code>rocksdb_bloom_bits_per_key</code> ：用于 RocksDB 的 bloom 过滤器的每个键的位数。</p><ul><li>RocksDB bloom 过滤器可用于快速回答给定 RocksDB SST 文件中是否存在key或绝对不存在的问题，而无需将所有key读入内存。</li><li>使用更高的位值可降低误报的可能性，但会牺牲额外的磁盘空间和内存消耗，从而将筛选器加载到 RAM 中。当前默认值 20 被发现在进行 getattr 调用时（例如在 bluestore 中创建新对象期间）提供了显着的性能提升，当与 rocksdb 分区索引过滤器结合使用时，不会产生明显的内存开销或缓存污染。有关更多信息，请参阅：https：github.comfacebookrocksdbwikiPartitioned-Index-Filters。</li></ul><p><code>rocksdb_cache_index_and_filter_blocks</code> ：是否在块缓存中缓存索引和过滤器</p><ul><li>默认情况下，RocksDB 会在打开 SST 文件时将 SST 文件的索引和绽放过滤器加载到内存中，并在关闭 SST 文件时将其从内存中删除。因此，索引和 bloom filter 的内存消耗与允许保持打开状态的并发 SST 文件数直接相关。此选项将缓存的指示和过滤器存储在块缓存中，它们直接与其他缓存数据竞争。默认情况下，我们将此选项设置为 true，以更好地考虑和绑定 rocksdb 内存使用情况，并将过滤器保留在内存中，即使 SST 文件已关闭。</li></ul><p><code>rocksdb_cache_index_and_filter_blocks_with_high_priority</code> ：是否在块缓存中缓存高优先级的索引和过滤器</p><ul><li>将 rocksdb_cache_index_and_filter_blocks 设置为 true 的缺点是，常规数据可能会将索引和筛选器从内存中推出。将此选项设置为 true 意味着它们的缓存优先级高于其他数据，并且通常应保留在块缓存中</li></ul><p><code>rocksdb_pin_l0_filter_and_index_blocks_in_cache</code> ：是否将 0 级索引和绽放过滤器固定在块缓存中</p><ul><li>将 rocksdb_cache_index_and_filter_blocks 设置为 true 的缺点是，常规数据可能会将索引和筛选器从内存中推出。将此选项设置为 true 意味着 0 级 SST 文件的索引和过滤器将始终固定在块缓存中</li></ul><p><code>rocksdb_index_type</code> ：SST 文件的索引类型：binary_search、hash_search、two_level</p><ul><li>此选项控制表索引类型。</li><li>binary_search 是一个节省空间的索引块，针对基于块搜索的索引进行了优化。</li><li>hash_search可能会提高前缀查找性能，但代价是磁盘和内存使用率更高，压缩速度可能更慢。</li><li>two_level 是一种实验性索引类型，它使用两个二进制搜索索引，并与分区筛选器结合使用。请参见：http:rocksdb.orgblog20170512partitioned-index-filter.html</li></ul><p><code>rocksdb_cache_type</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/kv/RocksDBStore.cc</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;rocksdb::Cache&gt; <span class="title">RocksDBStore::create_block_cache</span><span class="params">(<span class="type">const</span> std::string&amp; cache_type, <span class="type">size_t</span> cache_size, <span class="type">double</span> cache_prio_high)</span> </span>&#123;</span><br><span class="line">	  std::shared_ptr&lt;rocksdb::Cache&gt; cache;</span><br><span class="line">      <span class="keyword">auto</span> shard_bits = cct-&gt;_conf-&gt;rocksdb_cache_shard_bits;</span><br><span class="line">      <span class="keyword">if</span> (cache_type == <span class="string">&quot;binned_lru&quot;</span>) &#123;</span><br><span class="line">        cache = rocksdb_cache::<span class="built_in">NewBinnedLRUCache</span>(cct, cache_size, shard_bits, <span class="literal">false</span>, cache_prio_high);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache_type == <span class="string">&quot;lru&quot;</span>) &#123;</span><br><span class="line">        cache = rocksdb::<span class="built_in">NewLRUCache</span>(cache_size, shard_bits);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache_type == <span class="string">&quot;clock&quot;</span>) &#123;</span><br><span class="line">        cache = rocksdb::<span class="built_in">NewClockCache</span>(cache_size, shard_bits);</span><br><span class="line">        <span class="keyword">if</span> (!cache) &#123;</span><br><span class="line">          derr &lt;&lt; <span class="string">&quot;rocksdb_cache_type &#x27;&quot;</span> &lt;&lt; cache</span><br><span class="line">               &lt;&lt; <span class="string">&quot;&#x27; chosen, but RocksDB not compiled with LibTBB. &quot;</span></span><br><span class="line">               &lt;&lt; dendl;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        derr &lt;&lt; <span class="string">&quot;unrecognized rocksdb_cache_type &#x27;&quot;</span> &lt;&lt; cache_type &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; dendl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rocksdb_cf_compact_on_deletion_sliding_window</code> ：启用rocksdb_cf_compact_on_deletion时要使用的滑动窗口</p><p><code>rocksdb_cf_compact_on_deletion_trigger</code> ：启用rocksdb_cf_compact_on_deletion时要使用的触发器</p><h2 id="bdev块设备"><a href="#bdev块设备" class="headerlink" title="bdev块设备"></a>bdev块设备</h2><p><code>bdev_debug_inflight_ios</code> 是 Ceph 分布式存储系统中的一个配置选项，用于启用或禁用块设备（bdev）层的调试信息，特别是关于正在进行的 I/O 操作的信息。启用此选项后，Ceph 将记录有关当前进行的 I/O 操作的详细调试信息，这对于诊断和解决 I/O 相关问题非常有用。</p><p><code>bdev_aio</code> 是 Ceph 分布式存储系统中的一个配置选项，用于控制 OSD（对象存储守护进程）是否使用 AIO（异步输入/输出）操作进行块设备的 I/O 操作。使用 AIO 可以提高 I/O 操作的性能，因为它允许非阻塞的 I/O 操作，从而更好地利用多核处理器和高性能存储设备。</p><p><code>bdev_aio_poll_ms</code> 参数指定了 OSD 在处理 AIO 请求时应等待的毫秒数，如果在这段时间内 I/O 操作没有完成，OSD 将进行轮询以检查 I/O 是否完成。这个参数的设置可以影响 Ceph OSD 的性能，因为它决定了在同步等待和轮询检查之间如何平衡。</p><ul><li><code>bdev_aio_poll_ms = 10</code> 意味着 OSD 在处理 AIO 请求时会等待 10 毫秒，然后进行轮询以查看 I/O 是否已经完成。</li><li><code>bdev_aio_poll_ms</code> 是 Ceph 分布式存储系统中的一个配置选项，用于设置异步输入/输出（AIO）操作的轮询时间间隔（以毫秒为单位）。该选项控制 OSD（对象存储守护进程）在处理 AIO 操作时的轮询频率。通过调整轮询时间间隔，可以优化 I/O 操作的性能和资源使用。</li></ul><p><code>bdev_aio_max_queue_depth</code></p><p><code>bdev_aio_reap_max</code> 是 Ceph 分布式存储系统中的一个配置选项，用于控制每次从异步输入/输出（AIO）完成队列中收割（reap）完成的 I/O 操作的最大数量。通过调整此参数，可以优化 I/O 操作的性能和系统资源的使用。</p><p><code>bdev_flock_retry</code> ：重试 flock 的次数</p><ul><li>获取块设备锁定时重试的次数。systemd-udevd 等程序可能会与 Ceph 竞争此锁。0 表示“无限”。</li></ul><h2 id="crimson"><a href="#crimson" class="headerlink" title="crimson"></a>crimson</h2><p><code>crimson_osd_obc_lru_size</code>：</p><ul><li><strong>解释</strong>：这个参数定义了对象上下文（Object Context, OBC）在 OSD 内存中缓存的最大数量。OBC 是对对象元数据和状态的缓存，LRU（Least Recently Used）策略用于确定哪些对象应从缓存中移除。</li><li><strong>作用</strong>：通过调整这个参数，你可以控制 OSD 内存使用的大小。较大的值会增加缓存命中率，可能提高性能，但也会增加内存使用量。</li><li>0 for unlimited</li></ul><p><code>crimson_osd_scheduler_concurrency</code>：</p><ul><li><strong>解释</strong>：这个参数定义了 Crimson OSD 的调度器并发度，决定了调度器可以同时处理的请求数量。</li><li><strong>作用</strong>：调整此参数可以影响 OSD 的并行处理能力。较高的并发度可以提高系统的吞吐量，但可能会增加上下文切换和资源竞争，从而影响性能。</li><li>0 for unlimited</li></ul><p><code>crimson_alien_op_num_threads</code>：</p><ul><li><strong>解释</strong>：这个参数定义了处理“外来操作”（alien operations）线程的数量。外来操作是指那些需要跨多个核或 CPU 处理的操作。</li><li><strong>作用</strong>：通过调整这个参数，你可以控制处理外来操作的线程数，从而影响这些操作的并发处理能力。较多的线程可以提高处理能力，但也可能增加线程调度和同步的开销。</li></ul><p><code>crimson_alien_thread_cpu_cores</code>：</p><ul><li><strong>解释</strong>：这个参数指定了用于外来操作线程的 CPU 核心数。它决定了哪些 CPU 核心将用于处理这些操作。</li><li><strong>作用</strong>：通过绑定外来操作线程到特定的 CPU 核心，你可以提高缓存命中率并减少上下文切换，从而提高系统性能。</li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/3896019113/" title="Ceph参数注解-OSD">https://amostian.github.io/posts/3896019113/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 存储</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 分布式存储</a> <a href="/tags/Ceph/" rel="tag"><i class="fa fa-tags"></i> Ceph</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2576505844/" rel="prev" title="Ceph文档-存储集群-综述"><i class="fa fa-chevron-left"></i> Ceph文档-存储集群-综述</a></div><div class="post-nav-item"><a href="/posts/3896019113/" rel="next" title="Ceph参数注解-MON">Ceph参数注解-MON <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OSD"><span class="nav-text">OSD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%90%8E%E7%AB%AF"><span class="nav-text">存储后端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Bluestore"><span class="nav-text">Bluestore</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-text">自动调整缓存大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E8%B0%83%E6%95%B4%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-text">手动调整缓存大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-text">校验和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="nav-text">压缩算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rocksdb"><span class="nav-text">rocksdb</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6Throttling"><span class="nav-text">流量控制Throttling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%86%E9%85%8D"><span class="nav-text">对象的最小分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BlueFS"><span class="nav-text">BlueFS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#blob-size"><span class="nav-text">blob_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bluestore-extent-map-shard"><span class="nav-text">bluestore_extent_map_shard</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bluestore-avl"><span class="nav-text">bluestore_avl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bluestore-volume"><span class="nav-text">bluestore_volume</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filestore"><span class="nav-text">Filestore</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#journal"><span class="nav-text">journal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E6%B4%97"><span class="nav-text">清洗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-text">操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#snap"><span class="nav-text">snap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mclock"><span class="nav-text">mclock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#backfilling"><span class="nav-text">backfilling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#osdmap"><span class="nav-text">osdmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recovery"><span class="nav-text">recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tiering%E5%88%86%E5%B1%82"><span class="nav-text">tiering分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PG%E7%9B%B8%E5%85%B3"><span class="nav-text">PG相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pool%E7%9B%B8%E5%85%B3"><span class="nav-text">pool相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CRUSH"><span class="nav-text">CRUSH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E5%AD%98%E5%82%A8"><span class="nav-text">上层存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A0%E5%88%A0%E7%A0%81%E6%B1%A0"><span class="nav-text">纠删码池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#osd-other"><span class="nav-text">osd_other</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#osd-fail"><span class="nav-text">osd fail</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVStore"><span class="nav-text">KVStore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#leveldb"><span class="nav-text">leveldb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rocksdb-1"><span class="nav-text">rocksdb</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bdev%E5%9D%97%E8%AE%BE%E5%A4%87"><span class="nav-text">bdev块设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#crimson"><span class="nav-text">crimson</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">216</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">81</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1150.8k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">46:51</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>