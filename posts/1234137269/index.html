<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="[TOC] OSD是Ceph集群的基础存储单元。单个OSD管理一个或多个本地物理存储设备。 OSD运行期间，需占用一定的CPU、内存和网络资源，是数据落盘、数据读取、数据自动平衡、数据恢复和状态检测等功能的实现主体。  软件层面，OSD运行期间是一个独立的进程 功能：接收libRADOS层发送的操作请求，将其转化为事务，向下发送给存储后端  写请求，将写事务转发给其他从OSD   状态检测功能：通"><meta property="og:type" content="article"><meta property="og:title" content="4.OSD"><meta property="og:url" content="https://amostian.github.io/posts/1234137269/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="[TOC] OSD是Ceph集群的基础存储单元。单个OSD管理一个或多个本地物理存储设备。 OSD运行期间，需占用一定的CPU、内存和网络资源，是数据落盘、数据读取、数据自动平衡、数据恢复和状态检测等功能的实现主体。  软件层面，OSD运行期间是一个独立的进程 功能：接收libRADOS层发送的操作请求，将其转化为事务，向下发送给存储后端  写请求，将写事务转发给其他从OSD   状态检测功能：通"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/image-20241027165843851.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/image-20231110013613380.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/image-20231106120050563.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/image-20241110113539497.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/Weightedpriority.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/PG%E4%B8%8EPGLog%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/ObjectContext%E4%B8%8EOI%E5%92%8CSS%E5%B1%9E%E6%80%A7.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/OpContext.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/image-20241111170439441.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/image-20241111170445890.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/PG%E4%BA%8B%E5%8A%A1%E5%88%B0ObjectStore%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/ObjectStore%E4%BA%8B%E5%8A%A1%E5%90%84%E9%83%A8%E5%88%86%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB.png"><meta property="og:image" content="https://amostian.github.io/posts/1234137269/InPriogress%E4%B8%8ERepGather%E5%85%B3%E8%81%94.png"><meta property="article:published_time" content="2024-11-07T14:27:19.000Z"><meta property="article:modified_time" content="2025-02-27T02:15:34.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="存储"><meta property="article:tag" content="分布式存储"><meta property="article:tag" content="Ceph"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/1234137269/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA.png"><link rel="canonical" href="https://amostian.github.io/posts/1234137269/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>4.OSD | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">68</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">83</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">236</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/1234137269/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">4.OSD</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-11-07 22:27:19" itemprop="dateCreated datePublished" datetime="2024-11-07T22:27:19+08:00">2024-11-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2025-02-27 10:15:34" itemprop="dateModified" datetime="2025-02-27T10:15:34+08:00">2025-02-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/" itemprop="url" rel="index"><span itemprop="name">Ceph</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">11k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>31 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>[TOC]</p><p>OSD是Ceph集群的基础存储单元。单个OSD管理一个或多个本地物理存储设备。</p><p>OSD运行期间，需占用一定的CPU、内存和网络资源，是数据落盘、数据读取、数据自动平衡、数据恢复和状态检测等功能的实现主体。</p><ul><li><p>软件层面，OSD运行期间是一个独立的进程</p><p>功能：接收libRADOS层发送的操作请求，将其转化为事务，向下发送给存储后端</p><ul><li>写请求，将写事务转发给其他从OSD</li></ul></li><li><p>状态检测功能：通过与MonClient与Monitor建立通信连接，上报自身状态；从Monitor获取MAP等信息</p></li><li><p>OSD间关系：</p><p>多副本模式需要多个OSD协同工作</p><p>在某个OSD设备出现故障时，需要向集群内其他OSD设备进行数据迁移</p></li></ul><span id="more"></span><h2 id="4-1-OSD中的数据"><a href="#4-1-OSD中的数据" class="headerlink" title="4.1 OSD中的数据"></a>4.1 OSD中的数据</h2><h3 id="4-1-1-Ceph视角的数据"><a href="#4-1-1-Ceph视角的数据" class="headerlink" title="4.1.1 Ceph视角的数据"></a>4.1.1 Ceph视角的数据</h3><p>Ceph是一种对象存储系统，上层应用的数据实质上由多个RADOS对象按一定规则组成</p><p>OSD对外提供RADOS对象的读写服务，将来自客户端的数据写请求转换为对RADOS对象操作的事务，并将这些对象写入存储后端</p><blockquote><p>对象是数据及其元数据的组合，由一个全局唯一的标识符表示</p></blockquote><p>对象存储的优势：</p><ul><li>大小无限制：基于文件的存储中，文件大小是有限制的，而对象存储没有大小限制</li><li>存储为对象有利于非结构化数据的管理与访问</li></ul><blockquote><p>在RADOS系统和OSD层面，对象大小由 <code>osd_max_object_size</code> 控制，上层应用的数据块会被拆分成不超过此大小的RADOS对象</p></blockquote><h3 id="4-1-2-OSD中的对象"><a href="#4-1-2-OSD中的对象" class="headerlink" title="4.1.2 OSD中的对象"></a>4.1.2 OSD中的对象</h3><h4 id="对象的标识符"><a href="#对象的标识符" class="headerlink" title="对象的标识符"></a>对象的标识符</h4><p>对象由 <code>oid</code> 标识</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/<span class="keyword">include</span>/object.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">object_t</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅id不能充分标识一个对象，在需要由数据结构 <code>hobject_t</code> 表示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/common/hobject.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hobject_t</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="type">object_t</span> oid;</span><br><span class="line">    	<span class="type">snapid_t</span> snap;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">  		<span class="type">uint32_t</span> hash;		<span class="comment">//对象的排序依据</span></span><br><span class="line">  	<span class="type">bool</span> max;</span><br><span class="line">  		<span class="type">uint32_t</span> nibblewise_key_cache;</span><br><span class="line">  		<span class="type">uint32_t</span> hash_reverse_bits;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">  		<span class="type">int64_t</span> pool;		<span class="comment">//表示所属的池名</span></span><br><span class="line">  		string nspace;		</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">  		string key;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>?未引用所属的PG信息：一个池的PG数可调，在对象中直接引用会增加PG调整的复杂度</p></blockquote><h4 id="对象的表示"><a href="#对象的表示" class="headerlink" title="对象的表示"></a>对象的表示</h4><p>上层应用的数据在RADOS层被分为三种类型。其中仅对象内容数据直接保存在磁盘上，元数据保存在RocksDB内。</p><p><img src="/posts/1234137269/对象的表示.png" alt="对象的表示"></p><h5 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h5><p><strong>OI属性</strong> 记录对象的基本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/osd_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">object_info_t</span> &#123;</span><br><span class="line">    <span class="type">hobject_t</span> soid;		<span class="comment">//id</span></span><br><span class="line">    <span class="comment">// 版本信息</span></span><br><span class="line">    <span class="type">eversion_t</span> version, prior_version;</span><br><span class="line">    <span class="type">version_t</span> user_version;</span><br><span class="line">    <span class="type">osd_reqid_t</span> last_reqid;</span><br><span class="line">    <span class="type">uint64_t</span> size;		<span class="comment">//大小</span></span><br><span class="line">    <span class="type">utime_t</span> mtime;		<span class="comment">//修改时间</span></span><br><span class="line">    <span class="type">utime_t</span> local_mtime; <span class="comment">// local mtime</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note: these are currently encoded into a total 16 bits; see</span></span><br><span class="line">    <span class="comment">// encode()/decode() for the weirdness.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">        FLAG_LOST     = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</span><br><span class="line">        FLAG_WHITEOUT = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,  <span class="comment">// object logically does not exist</span></span><br><span class="line">        FLAG_DIRTY    = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,  <span class="comment">// object has been modified since last flushed or undirtied</span></span><br><span class="line">        FLAG_OMAP     = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// has (or may have) some/any omap data</span></span><br><span class="line">        FLAG_DATA_DIGEST = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// has data crc</span></span><br><span class="line">        FLAG_OMAP_DIGEST = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// has omap crc</span></span><br><span class="line">        FLAG_CACHE_PIN = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,    <span class="comment">// pin the object in cache tier</span></span><br><span class="line">        FLAG_MANIFEST = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,	<span class="comment">// has manifest</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        FLAG_USES_TMAP = <span class="number">1</span>&lt;&lt;<span class="number">8</span>,  <span class="comment">// deprecated; no longer used.</span></span><br><span class="line">    &#125; <span class="type">flag_t</span>;</span><br><span class="line">    <span class="type">flag_t</span> flags;	<span class="comment">//对象状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> truncate_seq, truncate_size;</span><br><span class="line">    map&lt;pair&lt;<span class="type">uint64_t</span>, <span class="type">entity_name_t</span>&gt;, <span class="type">watch_info_t</span>&gt; watchers;</span><br><span class="line">    <span class="comment">//校验和</span></span><br><span class="line">    __u32 data_digest;  <span class="comment">///&lt; data crc32c</span></span><br><span class="line">    __u32 omap_digest;  <span class="comment">///&lt; omap crc32c</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SS属性</strong> 记录对象的快照信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/osd_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SnapSet</span> &#123;</span><br><span class="line">  <span class="type">snapid_t</span> seq;</span><br><span class="line">  <span class="type">bool</span> head_exists;</span><br><span class="line">  vector&lt;<span class="type">snapid_t</span>&gt; snaps;    <span class="comment">// descending</span></span><br><span class="line">  vector&lt;<span class="type">snapid_t</span>&gt; clones;   <span class="comment">// ascending</span></span><br><span class="line">  map&lt;<span class="type">snapid_t</span>, interval_set&lt;<span class="type">uint64_t</span>&gt; &gt; clone_overlap;  <span class="comment">// overlap w/ next newest</span></span><br><span class="line">  map&lt;<span class="type">snapid_t</span>, <span class="type">uint64_t</span>&gt; clone_size;</span><br><span class="line">  map&lt;<span class="type">snapid_t</span>, vector&lt;<span class="type">snapid_t</span>&gt;&gt; clone_snaps; <span class="comment">// descending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OMAP属性</strong> ：保存数据一致性的重要参照信息</p><ul><li>保存PGLOG日志</li></ul><h5 id="head对象与克隆对象"><a href="#head对象与克隆对象" class="headerlink" title="head对象与克隆对象"></a>head对象与克隆对象</h5><p>head对象是原始对象，克隆对象是对head对象在某时刻的快照</p><ul><li>一个head对象可以有多个克隆对象</li><li>head对象和克隆对象具有相同的 <code>(object_t) oid</code> ，区别在于OI属性中 <code>(hobject_t) soid</code> 下的 <code>(snapid_t) snap</code> 字段<ul><li>克隆对象 snap 字段为 <code>CEPH_NOSNAP</code></li><li>克隆对象的 snap 字段为快照序号</li></ul></li><li>二者在 SS 属性上也有差别</li></ul><h3 id="4-1-3-对象的组织与管理"><a href="#4-1-3-对象的组织与管理" class="headerlink" title="4.1.3 对象的组织与管理"></a>4.1.3 对象的组织与管理</h3><p>所有对象存放在物理上隔离的线性地址空间</p><p>存储池，是存储应用层可见的对象组织与管理单元，是对象的一种逻辑分区</p><p><img src="/posts/1234137269/image-20241027165843851.png" alt="image-20241027165843851"></p><p>存储池落盘过程会被分割为多个PG，交叉分布在集群内的OSD设备上</p><p>PG，是Ceph中最末级的数据组织单元，其内直接存放RADOS对象。可见范围为 liobRADOS层与RADOS层。</p><ul><li>一个存储池的PG数由人工控制，但不能指定具体存放在哪个PG</li><li>PGID由对象名hash值取模 <strong>计算</strong> 确定，也即存储池的划分</li></ul><p><strong>数据存放、迁移和同步都是以PG为单位</strong></p><ul><li>基于OSDMAP使用CRUSH算法计算PG存放于哪个OSD设备</li><li>OSD设备发生故障时，导致OSDMAP变化，此时RADOS系统自动将故障OSD上的PG迁移到其他OSD设备上。</li></ul><h4 id="存储池"><a href="#存储池" class="headerlink" title="存储池"></a>存储池</h4><p>Ceph集群部署完成后，会创建一些默认的存储池（rbd）</p><p>池根据ceph.conf中配置的副本数创建指定数量的副本池，保障数据的高可用性，比如：复制或纠删码技术（二选一）</p><ul><li>纠删码：将数据分解成块编码，然后以分布式的方式存储</li></ul><p>当数据写入池时，Ceph池会映射到一个CRUSH规则集，CRUSH规则集为Ceph池提供了新的功能</p><ul><li>缓冲池：创建一个使用SSD的faster池或SSD、SAS和SATA硬盘组成的混合池</li><li>支持快照：<code>ceph osd pool mksnap</code></li><li>为对象设置所有者和访问权限：给池分配一个用户ID标识该池的所有者</li></ul><h4 id="PG"><a href="#PG" class="headerlink" title="PG"></a>PG</h4><p>PG是一组对象的逻辑集合（不属于同一个RADOS对象），可以减少系统管理大量对象带来的资源占用</p><p>一般来说，增加池的PG数可以降低每个OSD的负担，但PG数不能无限增大，需要根据集群规模调整，建议每个OSD放置50~100个PG</p><blockquote><p><strong>PG数的计算</strong></p><script type="math/tex;mode=display">PG数= 2^{\big\lceil\log_2(OSD总数\times 100/最大副本数)\big\rceil}\\
每个池平均PG数=2^{\log_2\big\lceil PG总数/池数\big\rceil}=2^{\big\lceil\log_2(OSD总数\times 100/最大副本数/池数)\big\rceil}</script></blockquote><p>多副本模式下，PG会被复制到不同OSD设备上提高系统可靠性</p><p><img src="/posts/1234137269/image-20231110013613380.png" alt="image-20231110013613380"></p><h2 id="4-2-OSD组件"><a href="#4-2-OSD组件" class="headerlink" title="4.2 OSD组件"></a>4.2 OSD组件</h2><h3 id="4-2-1-PG"><a href="#4-2-1-PG" class="headerlink" title="4.2.1 PG"></a>4.2.1 PG</h3><p>PG在OSD中的实现分为两部分：</p><ul><li><p>一部分是描述对象隶属关系的末级数据组织结构，</p></li><li><p>另一部分是实现PG功能、处理各类操作请求的程序实例，</p><p>在OSD中，实现为基于PG类派生的程序实例</p></li></ul><h4 id="对象的组织结构——Collection"><a href="#对象的组织结构——Collection" class="headerlink" title="对象的组织结构——Collection"></a>对象的组织结构——Collection</h4><p>同一PG的对象具有相同的Collection实例 <code>coll_t</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/osd_types.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">coll_t</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">type_t</span> &#123;</span><br><span class="line">    TYPE_META = <span class="number">0</span>,</span><br><span class="line">    TYPE_LEGACY_TEMP = <span class="number">1</span>,  <span class="comment">/* no longer used */</span></span><br><span class="line">    TYPE_PG = <span class="number">2</span>,</span><br><span class="line">    TYPE_PG_TEMP = <span class="number">3</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">type_t</span> type;</span><br><span class="line">  <span class="type">spg_t</span> pgid;</span><br><span class="line">  <span class="type">uint64_t</span> removal_seq;  <span class="comment">// note: deprecated, not encoded</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> _str_buff[<span class="type">spg_t</span>::calc_name_buf_size];</span><br><span class="line">  <span class="type">char</span> *_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>(spg_t) pgid=&#123;m_pool=[池ID],m_seed=[PG ID]&#125;</code> 是一个二维结构</li></ul><h5 id="PG的元数据"><a href="#PG的元数据" class="headerlink" title="PG的元数据"></a>PG的元数据</h5><p>作为对象管理单元的PG，其本身也是一个对象，该对象的对象名 <code>hoid.name=null</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pgmeta_oid &#123;</span><br><span class="line">    (<span class="type">hobject_t</span>) hoid&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> POOL_META = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> POOL_TEMP_START = <span class="number">-2</span>;</span><br><span class="line">        oid = &#123;</span><br><span class="line">            name = <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        max = <span class="literal">false</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FileStore为存储后端，PG元数据的对象保存在 <code>[PGID]_head</code></li><li>BlueStore为存储后端，PG元数据对象为BlueStore自定义的由onode承载的数据集合，存储在RocksDB</li></ul><hr><p>PG元数据有 <code>PG_INFO</code> 、<code>PGLOG</code> 、<code>missing</code> 列表。</p><ul><li><p><code>PG_INFO</code> 中存放了PG的日志状态、版本号等基本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/osd_types.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pg_info_t</span> &#123;</span><br><span class="line">    <span class="type">spg_t</span> pgid;</span><br><span class="line">    <span class="type">eversion_t</span> last_update;      <span class="comment">///&lt; last object version applied to store.</span></span><br><span class="line">    <span class="type">eversion_t</span> last_complete;    <span class="comment">///&lt; last version pg was complete through.</span></span><br><span class="line">    <span class="type">epoch_t</span> last_epoch_started;  <span class="comment">///&lt; last epoch at which this pg started on this osd</span></span><br><span class="line">    <span class="type">epoch_t</span> last_interval_started; <span class="comment">///&lt; first epoch of last_epoch_started interval</span></span><br><span class="line">    <span class="type">version_t</span> last_user_version; <span class="comment">///&lt; last user object version applied to store</span></span><br><span class="line">    <span class="type">eversion_t</span> log_tail;         <span class="comment">///&lt; oldest log entry.</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">hobject_t</span> last_backfill;     <span class="comment">///&lt; objects &gt;= this and &lt; last_complete may be missing</span></span><br><span class="line">    <span class="type">bool</span> last_backfill_bitwise;  <span class="comment">///&lt; true if last_backfill reflects a bitwise (vs nibblewise) sort</span></span><br><span class="line">    interval_set&lt;<span class="type">snapid_t</span>&gt; purged_snaps;</span><br><span class="line">    <span class="type">pg_stat_t</span> stats;</span><br><span class="line">    <span class="type">pg_history_t</span> history;</span><br><span class="line">    <span class="type">pg_hit_set_history_t</span> hit_set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>PGLOG</code>、 <code>missing</code> 列表保存各PG副本间数据一致性的信息，以OMAP属性的方式保存在PG元数据对象中</p><p>PGLOG为故障数据的检测与恢复提供了对照标准</p><p>PGLOG由PG的副本维护，每个PG副本都有相应的PGLOG日志，并由各自的副本维护。</p><p>落盘时存放在元数据xxx实例的OMAP属性内，运行时作为PG实例的数据载入内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pg_log_entry_t</span> &#123;</span><br><span class="line">    <span class="comment">//对象的唯一标识，记录对象ID、所属存储池ID、快照版本等</span></span><br><span class="line">    <span class="type">hobject_t</span>  soid;</span><br><span class="line">    <span class="type">osd_reqid_t</span> reqid;  <span class="comment">// caller+tid to uniquely identify request</span></span><br><span class="line">    mempool::osd_pglog::vector&lt;pair&lt;<span class="type">osd_reqid_t</span>, <span class="type">version_t</span>&gt; &gt; extra_reqids;</span><br><span class="line">    <span class="type">eversion_t</span> version, prior_version, reverting_to;	<span class="comment">//对象版本号</span></span><br><span class="line">    <span class="type">version_t</span> user_version; <span class="comment">// the user version for this entry</span></span><br><span class="line">    <span class="type">utime_t</span>     mtime;  <span class="comment">// this is the _user_ mtime, mind you</span></span><br><span class="line">    <span class="type">int32_t</span> return_code; <span class="comment">// only stored for ERRORs for dup detection</span></span><br><span class="line"></span><br><span class="line">    __s32      op;	<span class="comment">//操作类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的字段是 version（对象版本）、op（操作类型）、soid（对象ID及相关信息）</p><p>PGLOG通过 <code>soid</code> 关联到对象，通过 <code>version</code> 与对象 SS属性中的同名字段比较，确定对象的状态</p></li></ul><h4 id="PG与PGP"><a href="#PG与PGP" class="headerlink" title="PG与PGP"></a>PG与PGP</h4><p>PGP是为定位设置的PG，对于一个池而言 <code>pgp_num=pg_num</code></p><p>对于再平衡操作：当某个池的 <code>PG_num</code> 增加，这个池的每个PG会被一分为二，但先不进行再平衡。等到 <code>pgp_num</code> 被增加时，PG才开始从源OSD迁移到其他OSD，正式开始再平衡</p><h4 id="PG-peer-和up、acting集合"><a href="#PG-peer-和up、acting集合" class="headerlink" title="PG peer  和up、acting集合"></a>PG peer 和up、acting集合</h4><p>acting集合负责PG的一组OSD，up集合中的第一个OSD为主OSD，其余为第二、第三…OSD</p><ul><li><p>对于某些PG而言，某个OSD为主OSD，但同时对于其他PG来说，该OSD可能为非主OSD</p></li><li><p>主OSD的守护进程负责该PG与第二第三OSD间的 <strong>peer操作</strong></p><p>该PG的所有对象及其元数据状态</p><p>存放该PG的所有OSD间的确认操作</p></li></ul><p><img src="/posts/1234137269/image-20231106120050563.png" alt="image-20231106120050563"></p><p>处于up状态的主OSD会保持在up与acting集合中</p><ul><li>正常状态acting集合和up集合一样</li><li>up[]：是一个特定CRUSH规则集下的一个特定OSD map版本的所有相关OSD的有序列表</li><li>acting[]：特定PG map版本的OSD集合</li></ul><p>一旦变为down，首先会将其从up集合中移除，再从acting集合中移除。第二OSD会被晋升为主OSD。Ceph会将出错OSD上的PG恢复到新的OSD上，并将该OSD添加到up集合和acting集合中</p><h3 id="4-2-2-op-shardedwq"><a href="#4-2-2-op-shardedwq" class="headerlink" title="4.2.2 op_shardedwq"></a>4.2.2 op_shardedwq</h3><p>Ceph OSD处理OP，snap trim，scrub的是相同的work queue - <code>osd::op_shardedwq</code></p><h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p>这里主要涉及到两个数据结构：</p><ol><li><code>class PGQueueable</code></li><li><code>class ShardedOpWQ</code></li></ol><h5 id="class-PGQueueable"><a href="#class-PGQueueable" class="headerlink" title="class PGQueueable"></a>class PGQueueable</h5><p>这个是封装PG一些请求的class，相关的操作有：</p><ol><li><code>OpRequestRef</code></li><li><code>PGSnapTrim</code></li><li><code>PGScrub</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/osd/PGQueueable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PGQueueable</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::variant&lt;</span><br><span class="line">    OpRequestRef,</span><br><span class="line">    PGSnapTrim,</span><br><span class="line">    PGScrub</span><br><span class="line">    &gt; QVariant;   <span class="comment">// 定义队列处理的三种请求</span></span><br><span class="line">    </span><br><span class="line">    QVariant qvariant;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">    <span class="type">unsigned</span> priority;</span><br><span class="line">    <span class="type">utime_t</span> start_time;</span><br><span class="line">    <span class="type">entity_inst_t</span> owner;</span><br><span class="line">    <span class="type">epoch_t</span> map_epoch;    <span class="comment">///&lt; an epoch we expect the PG to exist in</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// cppcheck-suppress noExplicitConstructor</span></span><br><span class="line">    <span class="built_in">PGQueueable</span>(OpRequestRef op)    <span class="comment">// 处理OpRequest</span></span><br><span class="line">        : <span class="built_in">qvariant</span>(op), <span class="built_in">cost</span>(op-&gt;<span class="built_in">get_req</span>()-&gt;<span class="built_in">get_cost</span>()),</span><br><span class="line">          <span class="built_in">priority</span>(op-&gt;<span class="built_in">get_req</span>()-&gt;<span class="built_in">get_priority</span>()),</span><br><span class="line">          <span class="built_in">start_time</span>(op-&gt;<span class="built_in">get_req</span>()-&gt;<span class="built_in">get_recv_stamp</span>()),</span><br><span class="line">          <span class="built_in">owner</span>(op-&gt;<span class="built_in">get_req</span>()-&gt;<span class="built_in">get_source_inst</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">PGQueueable</span>(       <span class="comment">// 处理PGSnapTrim</span></span><br><span class="line">        <span class="type">const</span> PGSnapTrim &amp;op, <span class="type">int</span> cost, <span class="type">unsigned</span> priority, <span class="type">utime_t</span> start_time,</span><br><span class="line">        <span class="type">const</span> <span class="type">entity_inst_t</span> &amp;owner)</span><br><span class="line">        : <span class="built_in">qvariant</span>(op), <span class="built_in">cost</span>(cost), <span class="built_in">priority</span>(priority), <span class="built_in">start_time</span>(start_time),</span><br><span class="line">          <span class="built_in">owner</span>(owner) &#123;&#125;</span><br><span class="line">    <span class="built_in">PGQueueable</span>(       <span class="comment">// 处理PGScrub</span></span><br><span class="line">        <span class="type">const</span> PGScrub &amp;op, <span class="type">int</span> cost, <span class="type">unsigned</span> priority, <span class="type">utime_t</span> start_time,</span><br><span class="line">        <span class="type">const</span> <span class="type">entity_inst_t</span> &amp;owner)</span><br><span class="line">        : <span class="built_in">qvariant</span>(op), <span class="built_in">cost</span>(cost), <span class="built_in">priority</span>(priority), <span class="built_in">start_time</span>(start_time),</span><br><span class="line">          <span class="built_in">owner</span>(owner) &#123;&#125;</span><br><span class="line">    <span class="built_in">PGQueueable</span>(	<span class="comment">//处理PGRecovery</span></span><br><span class="line">    <span class="type">const</span> PGRecovery &amp;op, <span class="type">int</span> cost, <span class="type">unsigned</span> priority, <span class="type">utime_t</span> start_time,</span><br><span class="line">    <span class="type">const</span> <span class="type">entity_inst_t</span> &amp;owner, <span class="type">epoch_t</span> e)</span><br><span class="line">    : <span class="built_in">qvariant</span>(op), <span class="built_in">cost</span>(cost), <span class="built_in">priority</span>(priority), <span class="built_in">start_time</span>(start_time),</span><br><span class="line">      <span class="built_in">owner</span>(owner), <span class="built_in">map_epoch</span>(e) &#123;&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(OSD *osd, PGRef &amp;pg, ThreadPool::TPHandle &amp;handle)</span> </span>&#123;</span><br><span class="line">        <span class="function">RunVis <span class="title">v</span><span class="params">(osd, pg, handle)</span></span>;</span><br><span class="line">        boost::<span class="built_in">apply_visitor</span>(v, qvariant);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="class-ShardedOpWQ"><a href="#class-ShardedOpWQ" class="headerlink" title="class ShardedOpWQ"></a>class ShardedOpWQ</h5><p>这个是OSD中shard相关线程的work queue类，用来处理<code>PGQueueable</code>封装的三类PG操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OSD</span> : <span class="keyword">public</span> Dispatcher, <span class="keyword">public</span> <span class="type">md_config_obs_t</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">PGQueueable</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ShardedOpWQ</span>: <span class="keyword">public</span> ShardedThreadPool::ShardedWQ &lt; pair &lt;PGRef, PGQueueable&gt; &gt; &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ShardData</span> &#123;</span><br><span class="line">            Mutex sdata_lock;</span><br><span class="line">            Cond sdata_cond;</span><br><span class="line">            Mutex sdata_op_ordering_lock;</span><br><span class="line">            map&lt;PG*, list&lt;PGQueueable&gt; &gt; pg_for_processing;</span><br><span class="line">            std::unique_ptr&lt;OpQueue&lt; pair&lt;PGRef, PGQueueable&gt;, <span class="type">entity_inst_t</span>&gt;&gt; pqueue;</span><br><span class="line">            <span class="built_in">ShardData</span>(</span><br><span class="line">                string lock_name, string ordering_lock,</span><br><span class="line">                <span class="type">uint64_t</span> max_tok_per_prio, <span class="type">uint64_t</span> min_cost, CephContext *cct,</span><br><span class="line">                io_queue opqueue)</span><br><span class="line">                : <span class="built_in">sdata_lock</span>(lock_name.<span class="built_in">c_str</span>(), <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, cct),</span><br><span class="line">                  <span class="built_in">sdata_op_ordering_lock</span>(ordering_lock.<span class="built_in">c_str</span>(), <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, cct) &#123;</span><br><span class="line">                <span class="keyword">if</span> (opqueue == weightedpriority) &#123;</span><br><span class="line">                    pqueue = std::unique_ptr</span><br><span class="line">                             &lt;WeightedPriorityQueue&lt; pair&lt;PGRef, PGQueueable&gt;, <span class="type">entity_inst_t</span>&gt;&gt;(</span><br><span class="line">                                 <span class="keyword">new</span> WeightedPriorityQueue&lt; pair&lt;PGRef, PGQueueable&gt;, <span class="type">entity_inst_t</span>&gt;(</span><br><span class="line">                                     max_tok_per_prio, min_cost));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opqueue == prioritized) &#123;</span><br><span class="line">                    pqueue = std::unique_ptr</span><br><span class="line">                             &lt;PrioritizedQueue&lt; pair&lt;PGRef, PGQueueable&gt;, <span class="type">entity_inst_t</span>&gt;&gt;(</span><br><span class="line">                                 <span class="keyword">new</span> PrioritizedQueue&lt; pair&lt;PGRef, PGQueueable&gt;, <span class="type">entity_inst_t</span>&gt;(</span><br><span class="line">                                     max_tok_per_prio, min_cost));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        vector&lt;ShardData*&gt; shard_list;</span><br><span class="line">        OSD *osd;</span><br><span class="line">        <span class="type">uint32_t</span> num_shards;   <span class="comment">// 值为cct-&gt;_conf-&gt;osd_op_num_shards</span></span><br><span class="line">...</span><br><span class="line">        <span class="type">void</span> _process(<span class="type">uint32_t</span> thread_index, heartbeat_handle_d *hb);</span><br><span class="line">        <span class="type">void</span> _enqueue(pair &lt;PGRef, PGQueueable&gt; item);</span><br><span class="line">        <span class="type">void</span> _enqueue_front(pair &lt;PGRef, PGQueueable&gt; item);</span><br><span class="line">...</span><br><span class="line">    &#125; op_shardedwq;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>op_shardedwq</code>对应的thread pool为：<code>osd_op_tp</code></p><p><code>osd_op_tp</code>的初始化在OSD的初始化类中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">osd_op_tp</span>(cct, <span class="string">&quot;OSD::osd_op_tp&quot;</span>, <span class="string">&quot;tp_osd_tp&quot;</span>,</span><br><span class="line">          cct-&gt;_conf-&gt;osd_op_num_threads_per_shard * cct-&gt;_conf-&gt;osd_op_num_shards),</span><br></pre></td></tr></table></figure><p>这里相关的配置参数有：</p><ol><li><code>osd_op_num_threads_per_shard</code>，默认值为 2</li><li><code>osd_op_num_shards</code>，默认值为 5</li></ol><p>PG会根据一定的映射模式映射到不同的shard上，然后由该shard对应的thread处理请求；</p><h5 id="ShardedOpWQ的处理函数"><a href="#ShardedOpWQ的处理函数" class="headerlink" title="ShardedOpWQ的处理函数"></a>ShardedOpWQ的处理函数</h5><p>该sharded的work queue的process函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/osd/OSD.cc</span></span><br><span class="line"><span class="type">void</span> OSD::ShardedOpWQ::_process(<span class="type">uint32_t</span> thread_index, heartbeat_handle_d *hb ) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    pair&lt;PGRef, PGQueueable&gt; item = sdata-&gt;pqueue-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line"> </span><br><span class="line">    boost::optional&lt;PGQueueable&gt; qi;  </span><br><span class="line">    <span class="comment">// [lookup +] lock pg (if we have it)</span></span><br><span class="line">  	<span class="keyword">if</span> (!pg) &#123;</span><br><span class="line">    	pg = osd-&gt;_lookup_lock_pg(item.first);</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;<span class="comment">// 获取pg lock</span></span><br><span class="line">    	pg-&gt;<span class="built_in">lock</span>();</span><br><span class="line">  	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    op-&gt;<span class="built_in">run</span>(osd, item.first, tp_handle);    <span class="comment">// 根据不同类型操作调用不同函数</span></span><br><span class="line">...</span><br><span class="line">    sdata-&gt;sdata_op_ordering_lock.<span class="built_in">Unlock</span>();    <span class="comment">// 释放lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出在调用实际的处理函数前，就先获取了PG lock；处理返回后释放PG lock；</p><p><code>osd::opshardedwq</code>的 <code>_process()</code> 函数会根据request的类型，调用不同的函数处理：</p><ol><li><code>OSD::dequeue_op()</code></li><li><code>ReplicatedPG::snap_trimmer()</code></li><li><code>PG::scrub()</code></li></ol><p>在文件src/osd/PGQueueable.cc中有这三类操作的不同处理函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PGQueueable::RunVis::<span class="built_in">operator</span>()(<span class="type">const</span> OpRequestRef &amp;op) &#123;</span><br><span class="line">  osd-&gt;<span class="built_in">dequeue_op</span>(pg, op, handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> PGQueueable::RunVis::<span class="built_in">operator</span>()(<span class="type">const</span> PGSnapTrim &amp;op) &#123;</span><br><span class="line">  pg-&gt;<span class="built_in">snap_trimmer</span>(op.epoch_queued);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> PGQueueable::RunVis::<span class="built_in">operator</span>()(<span class="type">const</span> PGScrub &amp;op) &#123;</span><br><span class="line">  pg-&gt;<span class="built_in">scrub</span>(op.epoch_queued, handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> PGQueueable::RunVis::<span class="built_in">operator</span>()(<span class="type">const</span> PGRecovery &amp;op) &#123;</span><br><span class="line">  osd-&gt;<span class="built_in">do_recovery</span>(pg.<span class="built_in">get</span>(), op.epoch_queued, op.reserved_pushes, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PG-lock粒度"><a href="#PG-lock粒度" class="headerlink" title="PG lock粒度"></a>PG lock粒度</h4><p>从函数<code>OSD::ShardedOpWQ::_process()</code>中看出，thread在区分具体的PG请求前就获取了PG lock，在return前释放PG lock；这个PG lock的粒度还是挺大的，若snap trim和scrub占用了PG lock太久，会影响到OSD PG正常的IO操作；</p><p>OSD PG相关的OP类型有（<code>OSD::dequeue_op()</code>函数处理）：</p><ul><li><code>CEPH_MSG_OSD_OP</code></li><li><code>MSG_OSD_SUBOP</code></li><li><code>MSG_OSD_SUBOPREPLY</code></li><li><code>MSG_OSD_PG_BACKFILL</code></li><li><code>MSG_OSD_REP_SCRUB</code></li><li><code>MSG_OSD_PG_UPDATE_LOG_MISSING</code></li><li><code>MSG_OSD_PG_UPDATE_LOG_MISSING_REPLY</code></li></ul><h5 id="osd-snap-trim-sleep和osd-scrub-sleep配置"><a href="#osd-snap-trim-sleep和osd-scrub-sleep配置" class="headerlink" title="osd_snap_trim_sleep和osd_scrub_sleep配置"></a><code>osd_snap_trim_sleep</code>和<code>osd_scrub_sleep</code>配置</h5><p>从上面看<code>g_conf-&gt;osd_snap_trim_sleep</code>和<code>g_conf-&gt;osd_scrub_sleep</code>配置为非0后，能让snap trim和scrub在每次执行前睡眠一段时间（不是random时间），这样能一定程度上降低这两个操作对PG IO ops的影响（获取PG lock）；</p><p>如果设置了<code>osd_snap_trim_sleep</code>或<code>osd_scrub_sleep</code>为非0，处理的线程会sleep，这样虽说释放了PG lock，但是占用了一个PG的一个处理线程，所以才有贴出来的ceph bug - <a target="_blank" rel="noopener" href="http://tracker.ceph.com/issues/19497">http://tracker.ceph.com/issues/19497</a></p><p>现在我们配置的是：</p><ol><li><code>osd_op_num_shards = 30</code></li><li><code>osd_op_num_threads_per_shard = 2</code> //默认值</li></ol><p>所以一旦某个shard对应的一个thread被占用了，对应处理该shard的只有一个thread了，这样就有可能影响映射到该shard上的PG的正常IO了。</p><p><a target="_blank" rel="noopener" href="https://www.yangguanjun.com/2018/10/25/ceph-bluestore-rocksdb-analyse/">https://www.yangguanjun.com/2018/10/25/ceph-bluestore-rocksdb-analyse/</a></p><h2 id="4-3-操作请求在OSD中的处理过程"><a href="#4-3-操作请求在OSD中的处理过程" class="headerlink" title="4.3 操作请求在OSD中的处理过程"></a>4.3 操作请求在OSD中的处理过程</h2><p>客户端使用CRUSH算法寻址，确定对象所在的主副本OSD编号和从副本OSD编号。——<a href="2.libRADOS.md">libRADOS层功能</a></p><p>客户端与主OSD建立TCP网络连接，进行身份认证后，发送写操作请求给主OSD</p><p>主OSD完成数据的本地写入和从OSD的数据写入</p><p>向客户端反馈写入结果</p><blockquote><p>OSD执行写操作请求的过程是数据结构变换的过程，先后经过 <code>Message</code> 、<code>OpRequest</code>、<code>OpContext</code>、<code>PGTransaction</code>、<code>ObjectStore::Transaction</code> 等数据结构的转换。</p><p>转换过程需要 <code>ObjectContext</code> 、<code>PG</code> 、<code>OSDMAP</code> 等资源数据结构的支持</p></blockquote><p>写操作请求在OSD中被转换为ObjectStore事务，提交到本地后端存储和从副本OSD落盘</p><h3 id="4-3-1-操作请求置入工作队列"><a href="#4-3-1-操作请求置入工作队列" class="headerlink" title="4.3.1 操作请求置入工作队列"></a>4.3.1 操作请求置入工作队列</h3><p>这部分的数据结构转换与工作队列的入队，由Message线程完成</p><p><img src="/posts/1234137269/image-20241110113539497.png" alt="image-20241110113539497"></p><h4 id="1-写请求转换为Message"><a href="#1-写请求转换为Message" class="headerlink" title="1. 写请求转换为Message"></a>1. 写请求转换为Message</h4><p>客户端基于OSDMAP利用CRUSH算法计算出目标PG和OSD后，将操作请求封装为消息结构 <code>Message</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/msg/Message.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> : <span class="keyword">public</span> RefCountedObject &#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">    ceph_msg_header  header;      <span class="comment">// headerelope</span></span><br><span class="line">    ceph_msg_footer  footer;</span><br><span class="line">    bufferlist       payload;  <span class="comment">// &quot;front&quot; unaligned blob</span></span><br><span class="line">    bufferlist       middle;   <span class="comment">// &quot;middle&quot; unaligned blob</span></span><br><span class="line">    bufferlist       data;     <span class="comment">// data payload (page-alignment will be preserved where possible)</span></span><br><span class="line">    </span><br><span class="line">    ConnectionRef connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>header为消息头，存放其他部分的数据长度信息</p><ul><li><code>(_le64) header.tid</code> 存放操作的事务ID，在一次<strong>会话中依据请求顺序递增</strong>，初始值为1，</li></ul></li><li><p>data保存了操作请求的内容数据</p></li><li><p>footer为消息尾，存放数据的CRC校验和</p></li><li><p>connection，记录客户端的网络地址。</p><p>客户端与主OSD建立初始会话时，OSD端网络通信线程会创建并记录connection</p><p>客户端并不指定连接，当操作请求的数据包到达OSD后再由Message结构填充对connection的引用</p></li><li><p>payload为负载信息，也即操作请求的元数据</p><p>对负载的封装由 <em>src/messages/MOSDOp.h</em> 中的 <code>void encode_payload(uint64_t features)</code> 完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode_payload</span><span class="params">(<span class="type">uint64_t</span> features)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// latest v8 encoding with hobject_t hash separate from pgid, no reassert version</span></span><br><span class="line">	header.version = HEAD_VERSION;</span><br><span class="line">	<span class="comment">//由请求前端指定</span></span><br><span class="line">	::<span class="built_in">encode</span>(pgid, payload);</span><br><span class="line">	::<span class="built_in">encode</span>(hobj.<span class="built_in">get_hash</span>(), payload);</span><br><span class="line">	::<span class="built_in">encode</span>(osdmap_epoch, payload);</span><br><span class="line">	::<span class="built_in">encode</span>(flags, payload);</span><br><span class="line">	::<span class="built_in">encode</span>(reqid, payload);</span><br><span class="line">	<span class="built_in">encode_trace</span>(payload, features);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由后端分发线程编码</span></span><br><span class="line">    ::<span class="built_in">encode</span>(client_inc, payload);</span><br><span class="line">    ::<span class="built_in">encode</span>(mtime, payload);</span><br><span class="line">    ::<span class="built_in">encode</span>(<span class="built_in">get_object_locator</span>(), payload);</span><br><span class="line">    ::<span class="built_in">encode</span>(hobj.oid, payload);</span><br><span class="line">    __u16 num_ops = ops.<span class="built_in">size</span>();</span><br><span class="line">    ::<span class="built_in">encode</span>(num_ops, payload);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ops.<span class="built_in">size</span>(); i++)</span><br><span class="line">        ::<span class="built_in">encode</span>(ops[i].op, payload);	<span class="comment">//对操作的再次转换与封装</span></span><br><span class="line">    </span><br><span class="line">    ::<span class="built_in">encode</span>(hobj.snap, payload);</span><br><span class="line">    ::<span class="built_in">encode</span>(snap_seq, payload);</span><br><span class="line">    ::<span class="built_in">encode</span>(snaps, payload);</span><br><span class="line">    </span><br><span class="line">    ::<span class="built_in">encode</span>(retry_attempt, payload);</span><br><span class="line">    ::<span class="built_in">encode</span>(features, payload);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要包括：</p><ul><li>PGID</li><li>对象名 <code>hobj.oid</code></li><li><p>操作类型编码 <code>(__le16) op</code></p><ul><li>由 <em>src/include/rados.h</em> 的 <code>static inline int ceph_osd_op_uses_extent(int op)</code> 定义RADOS支持的操作类型</li></ul></li><li><p><code>osd_reqid_t reqid; // reqid explicitly set by sender</code></p><p>由libRADOS层的 <code>Objecter::Op</code> 中的 <code>prepare_mutate_op()</code> 指定</p></li></ul></li></ul><h4 id="2-将Message结构转换为OpRequest"><a href="#2-将Message结构转换为OpRequest" class="headerlink" title="2. 将Message结构转换为OpRequest"></a>2. 将Message结构转换为OpRequest</h4><p>OSD进程内的网络通信线程将Message结构转换为OpRequest结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/OpRequest.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OpRequest</span> : <span class="keyword">public</span> TrackedOp &#123;</span><br><span class="line">    Message *request; <span class="comment">/// the logical request we are tracking</span></span><br><span class="line">    <span class="type">osd_reqid_t</span> reqid;</span><br><span class="line">    <span class="type">entity_inst_t</span> req_src_inst;</span><br><span class="line">    <span class="type">uint8_t</span> hit_flag_points;</span><br><span class="line">    <span class="type">uint8_t</span> latest_flag_point;</span><br><span class="line">    <span class="type">utime_t</span> dequeued_time;</span><br><span class="line">    <span class="type">bool</span> check_send_map = <span class="literal">true</span>; <span class="comment">///&lt; true until we check if sender needs a map</span></span><br><span class="line">    <span class="type">epoch_t</span> sent_epoch = <span class="number">0</span>;     <span class="comment">///&lt; client&#x27;s map epoch</span></span><br><span class="line">    <span class="type">epoch_t</span> min_epoch = <span class="number">0</span>;      <span class="comment">///&lt; min epoch needed to handle this msg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OpRequest.reqid</code> 是 <code>OpRequest</code> 的唯一标识，用于后续操作请求的查重</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">osd_reqid_t</span>&#123;</span><br><span class="line">    <span class="type">entity_name_t</span> name;	<span class="comment">//等于 Message.header.src</span></span><br><span class="line">    <span class="type">ceph_tid_t</span> tid;		<span class="comment">//等于 Message.header.tid</span></span><br><span class="line">    <span class="type">int32_t</span> inc;		<span class="comment">//等于 Message.payload.reqid.inc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>操作请求 <code>Message.payload</code> 中的 <code>(_le64) reqid.tid</code> ，不足以标识OpRequest。</li></ul><h4 id="3-使用OSD全局工作队列控制系统QoS"><a href="#3-使用OSD全局工作队列控制系统QoS" class="headerlink" title="3. 使用OSD全局工作队列控制系统QoS"></a>3. 使用OSD全局工作队列控制系统QoS</h4><p>将操作请求置入全局工作队列 <code>(OSD::ShardedOpWQ) op_shadredwq</code> 工作队列组</p><ul><li>客户端的各类操作请求都将进入该队列组等待处理</li></ul><p>QoS的控制方法有四种</p><ul><li>prioritized：基于优先级</li><li>WeightedPriority：基于权重</li><li>基于时间标签dmClock的方法<ul><li>mclock_opclass：</li><li>mclock_client</li></ul></li></ul><h5 id="Weightedpriority（默认）"><a href="#Weightedpriority（默认）" class="headerlink" title="Weightedpriority（默认）"></a>Weightedpriority（默认）</h5><p>其工作队列组是一种四级结构，前两级想独一固定，用于对 <code>OpRequest</code> 划分类别</p><ul><li>第一级，基于PG 的分片</li><li>第二级，对优先级分类</li><li>第三、四级分别存放客户端和具体操作请求</li></ul><p><img src="/posts/1234137269/Weightedpriority.png" alt="Weightedpriority"></p><p><strong>基于PG的分片</strong></p><p>一个分片可对应多个PG的操作请求，但一个PG的所有 <code>OpRequest</code> 只会置入同一个分片</p><ul><li>目的：确保同一PG内的 <code>OpRequest</code> 顺序执行</li></ul><p><strong>基于优先级的OpRequest分类</strong></p><p>不同操作请求类型有相应的优先级</p><p>优先级分为 normal(不大于63) 和 strict(大于63)两类，二者在请求出队方面有区别</p><ul><li><p>strict级别：严格按照操作请求的优先级出队</p></li><li><p>normal级别：以优先级为权重计算出队概率，优先级越大，该客户端队列被选中的概率越大。</p><p>客户端队列内部，采用 Round-Robin轮询调度，每个客户端队列依次被选中</p><p>将其内的操作请求队列头部的 <code>OpRequest</code> 出队</p></li></ul><h5 id="写请求在全局工作队列的入队过程"><a href="#写请求在全局工作队列的入队过程" class="headerlink" title="写请求在全局工作队列的入队过程"></a>写请求在全局工作队列的入队过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#src/osd/OSD.cc???可能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OSDService::enqueue_back</span><span class="params">(<span class="type">spg_t</span> pgid, PGQueueable qi)</span></span>&#123;</span><br><span class="line">  osd-&gt;op_shardedwq.<span class="built_in">queue</span>(<span class="built_in">make_pair</span>(pgid, qi));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>基于PGID计算所属的分片：使用 <code>OpRequest.request.pgid.m_seed</code> (PGID)与 <code>op_shardedwq</code> 的分片总数取模，得到具体的分片 shard</p></li><li><p>确定操作请求的优先级并放入相应的队列。</p><p><code>OpRequest.request.header.priority</code></p></li><li><p>确定请求所在的客户端队列：使用 <code>OpRequest.request.header.src</code> 和 <code>OpRequest.request.connection-&gt;peer_addr</code> 构成的结构体</p></li><li><p>将 <code>OpRequest</code> 直接置入第四级操作请求队列</p></li></ol><p><strong>Message</strong> 线程将 <code>OpRequest</code> 入队后立即返回，其出队与后续处理由专门的PG线程负责，涉及 <strong>一次线程切换</strong></p><h4 id="请求出队过程"><a href="#请求出队过程" class="headerlink" title="请求出队过程"></a>请求出队过程</h4><p><code>PGQueueable</code> 负责各类操作（op、snap_trimmer、scrub、recovery）的出队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/OSD.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OSD::dequeue_op</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PGRef pg, </span></span></span><br><span class="line"><span class="params"><span class="function">    OpRequestRef op,</span></span></span><br><span class="line"><span class="params"><span class="function">    ThreadPool::TPHandle &amp;handle)</span></span>&#123;</span><br><span class="line">        op-&gt;<span class="built_in">set_dequeued_time</span>(now);</span><br><span class="line">        ...</span><br><span class="line">        pg-&gt;<span class="built_in">do_request</span>(op, handle);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            PrimaryLogPG::do_request(OpRequestRef&amp; op,ThreadPool::TPHandle &amp;handle)</span></span><br><span class="line"><span class="comment">            按操作类型从全局工作队列将操作出对，IO请求为do_op</span></span><br><span class="line"><span class="comment">            prepare_lat是OpRequest的出队时长</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># src/osd/PrimaryLogPG.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimaryLogPG::do_op</span><span class="params">(OpRequestRef&amp; op)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execute_ctx</span>(ctx);</span><br><span class="line">    <span class="type">utime_t</span> prepare_latency = <span class="built_in">ceph_clock_now</span>();</span><br><span class="line">  	prepare_latency -= op-&gt;<span class="built_in">get_dequeued_time</span>();</span><br><span class="line">  	osd-&gt;logger-&gt;<span class="built_in">tinc</span>(l_osd_op_prepare_lat, prepare_latency);</span><br><span class="line">  	<span class="keyword">if</span> (op-&gt;<span class="built_in">may_read</span>() &amp;&amp; op-&gt;<span class="built_in">may_write</span>()) &#123;</span><br><span class="line">  	  osd-&gt;logger-&gt;<span class="built_in">tinc</span>(l_osd_op_rw_prepare_lat, prepare_latency);</span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op-&gt;<span class="built_in">may_read</span>()) &#123;</span><br><span class="line"> 	   osd-&gt;logger-&gt;<span class="built_in">tinc</span>(l_osd_op_r_prepare_lat, prepare_latency);</span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op-&gt;<span class="built_in">may_write</span>() || op-&gt;<span class="built_in">may_cache</span>()) &#123;</span><br><span class="line">   	 osd-&gt;logger-&gt;<span class="built_in">tinc</span>(l_osd_op_w_prepare_lat, prepare_latency);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-PG事务生成前的OSD处理阶段"><a href="#4-3-2-PG事务生成前的OSD处理阶段" class="headerlink" title="4.3.2 PG事务生成前的OSD处理阶段"></a>4.3.2 PG事务生成前的OSD处理阶段</h3><h4 id="1-判断操作的可调度性-操作请求查重、对象是否处于降级状态"><a href="#1-判断操作的可调度性-操作请求查重、对象是否处于降级状态" class="headerlink" title="1. 判断操作的可调度性(操作请求查重、对象是否处于降级状态)"></a>1. 判断操作的可调度性(操作请求查重、对象是否处于降级状态)</h4><p>进行 <code>OpRequest</code> 的查重工作，防止重复处理相同的请求</p><ul><li><code>OpRequest</code> 由 <code>OpRequest.reqid</code> 唯一标识</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PG.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PG::check_in_progress_op</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">osd_reqid_t</span> &amp;r,	<span class="comment">//形参r为 OpRequest.reqid</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">eversion_t</span> *version,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">version_t</span> *user_version,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> *return_code)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        projected_log.<span class="built_in">get_request</span>(r, version, user_version, return_code) ||</span><br><span class="line">        pg_log.<span class="built_in">get_log</span>().<span class="built_in">get_request</span>(r, version, user_version, return_code)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若存在重复操作请求，则反馈 <code>version</code> 和 <code>user_version</code></p><p><code>version</code> 是操作请求的版本信表示，正常情况其在PG内随着操作请求的提交而顺序、连续递增</p><ul><li>是PGLOG进行peering一致性校验的标识信息</li></ul><p><code>user_version</code> 是客户端可见的版本标识</p><ul><li>由PGLOG记录</li></ul></li><li><p>查重依据是内存中的 <code>(IndexLog) pg.projected_log</code> 和 <code>(IndexLog) pg.pg_log.log</code></p><p><code>IndexLog</code> 类用于在内存中创建日志的索引，索引的键是对象ID（oid）。</p><ul><li><p><code>pg.projected_log</code> 记录 <code>OpRequest</code> 的处理过程，根据 <code>OpRequest</code> 的处理进度动态添加和删除其中的记录条目</p></li><li><p><code>pg.pg_log.log</code> 包含实际的PGLOG，但并不会遍历实际的PGLOG队列，而是根据三个映射查重：caller_ops、extra_caller_ops、dup_index</p><p>三个map映射仅记录日志的地址值，不存放日志内容，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PGLog.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexedLog</span> : <span class="keyword">public</span> <span class="type">pg_log_t</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> ceph::unordered_map&lt;<span class="type">hobject_t</span>,<span class="type">pg_log_entry_t</span>*&gt; objects;  <span class="comment">// ptrs into log.  be careful!</span></span><br><span class="line">    <span class="keyword">mutable</span> ceph::unordered_map&lt;<span class="type">osd_reqid_t</span>,<span class="type">pg_log_entry_t</span>*&gt; caller_ops;</span><br><span class="line">    <span class="keyword">mutable</span> ceph::unordered_multimap&lt;<span class="type">osd_reqid_t</span>,<span class="type">pg_log_entry_t</span>*&gt; extra_caller_ops;</span><br><span class="line">    <span class="keyword">mutable</span> ceph::unordered_map&lt;<span class="type">osd_reqid_t</span>,<span class="type">pg_log_dup_t</span>*&gt; dup_index;</span><br></pre></td></tr></table></figure><p><img src="/posts/1234137269/PG与PGLog的关联关系.png" alt="PG与PGLog的关联关系"></p></li></ul></li></ul><h5 id="重复操作请求处理"><a href="#重复操作请求处理" class="headerlink" title="重复操作请求处理"></a>重复操作请求处理</h5><p>到PG的 <code>(xlist&lt;RepGather *&gt;) repop_queue</code> 中查询该 <code>OpRequest</code> 的完成状态</p><ul><li>若上次操作请求以完成，则应答客户端并返回</li><li>若未完成，则进入 <code>pg.waiting_for_ondisk</code> 队列，后续满足相关限制条件后，PG会将其出队，重新进入全局的 <code>op_shardedwq</code> 工作队列组，直至该请求执行完成</li></ul><h5 id="降级对象处理"><a href="#降级对象处理" class="headerlink" title="降级对象处理"></a>降级对象处理</h5><p>对于没有完成 revovery 操作的对象，将该操作置于内部队列，阻塞此次写请求，直至完成 revovery 后继续执行</p><h4 id="2-确定待操作对象是否存在，并获取目标对象的上下文信息"><a href="#2-确定待操作对象是否存在，并获取目标对象的上下文信息" class="headerlink" title="2. 确定待操作对象是否存在，并获取目标对象的上下文信息"></a>2. 确定待操作对象是否存在，并获取目标对象的上下文信息</h4><p><code>ObjectContext</code> 收集了对象的OI和SS属性</p><ul><li><p><code>(ObjectState) Obs</code> 在对象OI属性的基础上新增了表示对象存在性的字段 <code>ObjectContext.Obs.exists</code> 、读写事务所、用户自定义属性信息缓存等数据——<strong>拥有对象全部元数据</strong></p><p><img src="/posts/1234137269/ObjectContext与OI和SS属性.png" alt="ObjectContext与OI和SS属性"></p></li></ul><p>由函数 <code>PrimaryLogPG::get_object_context()</code> 读取OI和SS属性</p><ul><li><p>对于已存在的对象，该对象的 <code>ObjectContext</code> 会被缓存</p><p>会被存放在PG的 <code>(ShardedLRU&lt;hobj_t, ObjectContext&gt;) PG.object_contexts</code> 结构中，即该对象的 <code>ObjectContext.Obs.exists=true</code> 。</p></li><li><p>对于新创建的对象，<code>PG.object_contexts</code> 中并没有 <code>ObjectContext</code></p><p>在查找 <code>ObjectContext</code> 的过程中会调用 <code>PGBackend:objects_getattr()</code> 向存储后端查找对象的 OI属性（ <code>_</code> 属性）。即一次元数据的读取操作</p><p>判定该对象不存在后，会创建 <code>ObjectContext</code> 结构，并设置 <code>ObjectContext.Obs.exists=false</code></p></li></ul><h4 id="3-汇集请求涉及的结构，形成OpContext"><a href="#3-汇集请求涉及的结构，形成OpContext" class="headerlink" title="3. 汇集请求涉及的结构，形成OpContext"></a>3. 汇集请求涉及的结构，形成OpContext</h4><blockquote><p>在OSD中，带Context的结构多数用于数据汇集并根据上下文环境进行操作转换</p></blockquote><p>OpContext将操作请求 <code>OpRequest</code> 、目标对象上下文 <code>ObjectContext</code> 、快照对象上下文 <code>SnapContext</code> 汇集起来；</p><p>并预留一些内存数据结构：本次操作相关PGLOG的 <code>vector&lt;pg_log_entry_t&gt; log</code> 、存放对象预期状态的 <code>(ObjectState) new_obs</code> 、存放快照预期状态的 <code>(SnapSet) new_snapset</code> 等。</p><p>预留PG事务智能指针 <code>(PGTransactionUPtr) op_t</code> ，用于存放PG事务</p><p><img src="/posts/1234137269/OpContext.png" alt="OpContext"></p><p><code>(OpContext) ctx</code> 是将写请求转换为事务的基础数据，<strong>在PG处理阶段，写请求依次被转换为PG事务、Objector事务</strong>。<strong>Objector事务被提交给副本PG和后端存储，进行数据落盘</strong>。</p><h3 id="4-3-3-在PG处理线程中生成PG事务"><a href="#4-3-3-在PG处理线程中生成PG事务" class="headerlink" title="4.3.3 在PG处理线程中生成PG事务"></a>4.3.3 在PG处理线程中生成PG事务</h3><p>一个写请求经过本阶段的处理，会产生 <code>create</code> 、<code>clone</code>(与快照相关)、<code>PGLOG更新</code> 、<code>对象属性更新</code> 等多个事务执行单元。这些事务执行单元被封装到一个PG事务中。</p><h4 id="PG事务介绍"><a href="#PG事务介绍" class="headerlink" title="PG事务介绍"></a>PG事务介绍</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PGTransaction.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PGTransaction</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">hobject_t</span>, ObjectContextRef&gt; obc_map;</span><br><span class="line">    map&lt;<span class="type">hobject_t</span>, ObjectOperation&gt; op_map;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>针对某个目标对象的所有事务执行单元封装在一个 <code>ObjectOperation</code> 实例中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PGTransaction.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectOperation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Init</span>&#123;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">None</span> &#123;&#125;;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">Create</span> &#123;&#125;;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">Clone</span> &#123; <span class="type">hobject_t</span> source;&#125;;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">Rename</span> &#123; <span class="type">hobject_t</span> source; <span class="comment">// must be temp object&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">using</span> InitType = boost::variant&lt;Init::None, Init::Create, Init::Clone, Init::Rename&gt;;</span><br><span class="line">    std::map&lt;string, boost::optional&lt;bufferlist&gt; &gt; attr_updates;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">OmapUpdateType</span> &#123;Remove, Insert&#125;;</span><br><span class="line">    std::vector&lt;std::pair&lt;OmapUpdateType, bufferlist&gt; &gt; omap_updates;</span><br><span class="line">        </span><br><span class="line">    boost::optional&lt;pair&lt;set&lt;<span class="type">snapid_t</span>&gt;, set&lt;<span class="type">snapid_t</span>&gt; &gt; &gt; updated_snaps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BufferUpdate</span> &#123;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">Write</span> &#123;bufferlist buffer; <span class="type">uint32_t</span> fadvise_flags;&#125;;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">Zero</span> &#123; <span class="type">uint64_t</span> len;&#125;;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">CloneRange</span> &#123; <span class="type">hobject_t</span> from;<span class="type">uint64_t</span> offset;<span class="type">uint64_t</span> len;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">using</span> BufferUpdateType = boost::variant&lt;BufferUpdate::Write, BufferUpdate::Zero, BufferUpdate::CloneRange&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>结构</p><ul><li><p><code>xxxType</code> 按操作类型封装了事务的执行单元，同一类操作放在同一个联合体中</p><p>空操作、create、clone、rename放在一个联合体中</p><p>write、zero、cloneRange放在一个联合体中</p></li><li><p>定义各事务执行单元的参数</p></li><li><p><code>bufferlist</code> 保存存放数据的内存地址</p></li></ul></li></ul></li></ul><ul><li><p>为将事务封装到相应的事务执行单元结构中，还定义了相应的接口函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#src/osd/PGTransaction.h</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;hoid</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clone</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;target,       <span class="comment">///&lt; [in] obj to clone to</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;source        <span class="comment">///&lt; [in] obj to clone from</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rename</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;target,       <span class="comment">///&lt; [in] source (must be a temp object)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;source        <span class="comment">///&lt; [in] to, must not exist, be non-temp</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;hoid          <span class="comment">///&lt; [in] obj to remove</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setattrs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;hoid,         <span class="comment">///&lt; [in] object to write</span></span></span></span><br><span class="line"><span class="params"><span class="function">    map&lt;string, bufferlist&gt; &amp;attrs <span class="comment">///&lt; [in] attrs, may be cleared</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">hobject_t</span> &amp;hoid,         <span class="comment">///&lt; [in] object to write</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> off,                  <span class="comment">///&lt; [in] off at which to write</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> len,                  <span class="comment">///&lt; [in] len to write from bl</span></span></span></span><br><span class="line"><span class="params"><span class="function">    bufferlist &amp;bl,                <span class="comment">///&lt; [in] bl to write will be claimed to len</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> fadvise_flags = <span class="number">0</span>     <span class="comment">///&lt; [in] fadvise hint</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="事务转换过程"><a href="#事务转换过程" class="headerlink" title="事务转换过程"></a>事务转换过程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PrimaryLogPG.cc</span></span><br><span class="line"><span class="comment">//由PrimaryLogPG::do_op 主调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimaryLogPG::execute_ctx</span><span class="params">(OpContext *ctx)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">prepare_transaction</span>(ctx);</span><br><span class="line">    ...</span><br><span class="line">  	<span class="type">bool</span> pending_async_reads = !ctx-&gt;pending_async_reads.<span class="built_in">empty</span>();</span><br><span class="line">  	<span class="keyword">if</span> (result == -EINPROGRESS || pending_async_reads) &#123;</span><br><span class="line">        <span class="comment">// come back later.</span></span><br><span class="line">        <span class="keyword">if</span> (pending_async_reads) &#123;</span><br><span class="line">            <span class="comment">//list&lt;pair&lt;OpRequestRef, OpContext*&gt; &gt; in_progress_async_reads;</span></span><br><span class="line">            in_progress_async_reads.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(op, ctx));</span><br><span class="line">            ctx-&gt;<span class="built_in">start_async_reads</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//prepare_transaction(OpContext)将操作请求分解为事务执行单元并封装为PG事务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PrimaryLogPG::prepare_transaction</span><span class="params">(OpContext *ctx)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// prepare the actual mutation</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">do_osd_ops</span>(ctx, *ctx-&gt;ops);</span><br><span class="line">    <span class="comment">// clone, if necessary</span></span><br><span class="line">  	<span class="keyword">if</span> (soid.snap == CEPH_NOSNAP)</span><br><span class="line">    	<span class="built_in">make_writeable</span>(ctx);</span><br><span class="line">    <span class="built_in">finish_ctx</span>(ctx,</span><br><span class="line">               ctx-&gt;new_obs.exists ? <span class="type">pg_log_entry_t</span>::MODIFY :</span><br><span class="line">               <span class="type">pg_log_entry_t</span>::DELETE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>do_osd_ops()</code> ：写请求的基础性转换：是否执行 create()操作、执行普通的 write() 操作还是 truncate() 操作</li><li><code>make_writeable()</code> ：处理快照相关的操作，根据 <code>SnapContext</code> 和 <code>SnapSet</code> 判断是否执行 clone()操作及相关属性的设置</li><li><code>finish_ctx()</code> ：生成PGLOG日志更新的 omap_setkeys()操作、更新OI属性和SS属性的 setattrs()操作</li></ul><h5 id="do-osd-ops——操作请求的基础处理"><a href="#do-osd-ops——操作请求的基础处理" class="headerlink" title="do_osd_ops——操作请求的基础处理"></a>do_osd_ops——操作请求的基础处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PrimaryLogPG.cc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PrimaryLogPG::do_osd_ops</span><span class="params">(OpContext *ctx, vector&lt;OSDOp&gt;&amp; ops)</span></span>&#123;</span><br><span class="line">    <span class="comment">//此函数中的事务指PG事务</span></span><br><span class="line">    PGTransaction* t = ctx-&gt;<span class="type">op_t</span>.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对不同类型的请求分别处理，如 <code>CEPH_OSD_OP_XXX</code></p><ul><li>在 <em>src/include/rados.h</em> 中定义</li></ul><p>对于一个写请求</p><ol><li><p>首先，判断写请求本质上是否为一种 truncate()操作，</p></li><li><p>然后根据 <code>ctx.obs.exists</code> 判断是否执行 create()操作</p><ul><li>是，设置 <code>PGTransaction::ObjectOperation::Init</code> 类型为Create，最终在Objector事务中增加 <code>OP_TOUCH</code> 这一事务执行单元，告知后端存储在执行事务时先进行创建操作</li></ul></li><li><p>最终调用 <code>PGTransaction::write()</code> 函数将代写的数据、参数、对象id等作为一个 Write执行单元封装进PG事务。</p></li><li><p>还会更新对象OI属性的校验和信息，并暂存在 <code>ctx-&gt;new_obs</code> 中，用于后续的 setattrs()操作，更新事务执行单元</p></li></ol><h5 id="make-writeable——快照功能的处理流程"><a href="#make-writeable——快照功能的处理流程" class="headerlink" title="make_writeable——快照功能的处理流程"></a>make_writeable——快照功能的处理流程</h5><p><img src="/posts/1234137269/image-20241111170439441.png" alt="image-20241111170439441"></p><p><img src="/posts/1234137269/image-20241111170445890.png" alt="image-20241111170445890"></p><h5 id="finish-ctx——生成OI属性更新的事务执行单元与PGLOG日志"><a href="#finish-ctx——生成OI属性更新的事务执行单元与PGLOG日志" class="headerlink" title="finish_ctx——生成OI属性更新的事务执行单元与PGLOG日志"></a>finish_ctx——生成OI属性更新的事务执行单元与PGLOG日志</h5><p>更新OI属性中表示对象新版本号的 <code>ctx-&gt;new_obs.oi.version</code> 、表示对象老版本号的 <code>ctx-&gt;new_obs.oi.prior_version</code> 、记录本次请求的事务id <code>ctx-&gt;new_obs.oi.last_reqid</code> ，全部暂存于 <code>ctx_new_obs</code> 中</p><p>生成更新对象OI属性与SS属性的 setattr()事务执行单元。</p><ul><li><p>依据 <code>ctx-&gt;new_obs</code> 和 <code>ctx-&gt;new_snapset</code> 的新属性信息，生成 setattrs事务执行单元</p><p>无论是否有存储池快照，都会用 <code>new_snapset</code> 对SS属性进行更新</p></li></ul><p>生成本次操作请求对应的PGLOG，暂存在 <code>ctx-&gt;log</code> 中</p><ul><li>由于PGLOG由各PG独立维护，所以不需要将其封装入事务</li></ul><h3 id="4-3-4-关联从副本事务的回调函数，并向从副本提交事务"><a href="#4-3-4-关联从副本事务的回调函数，并向从副本提交事务" class="headerlink" title="4.3.4 关联从副本事务的回调函数，并向从副本提交事务"></a>4.3.4 关联从副本事务的回调函数，并向从副本提交事务</h3><p>这一阶段涉及的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由PrimaryLogPG::do_op 主调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimaryLogPG::execute_ctx</span><span class="params">(OpContext *ctx)</span></span>&#123;</span><br><span class="line">	<span class="comment">//操作请求转换为PG事务</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">prepare_transaction</span>(ctx);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// issue replica writes</span></span><br><span class="line">    <span class="type">ceph_tid_t</span> rep_tid = osd-&gt;<span class="built_in">get_tid</span>();</span><br><span class="line">    RepGather *repop = <span class="built_in">new_repop</span>(ctx, obc, rep_tid);</span><br><span class="line">	<span class="comment">//向所有从副本提交操作请求，以及操作的context</span></span><br><span class="line">    <span class="built_in">issue_repop</span>(repop, ctx);</span><br><span class="line">    <span class="comment">//接收从副本的执行情况</span></span><br><span class="line">    <span class="built_in">eval_repop</span>(repop);		</span><br><span class="line">    repop-&gt;<span class="built_in">put</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># src/osd/PrimaryLogPG.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimaryLogPG::issue_repop</span><span class="params">(RepGather *repop, OpContext *ctx)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Context *on_all_commit = <span class="keyword">new</span> <span class="built_in">C_OSD_RepopCommit</span>(<span class="keyword">this</span>, repop);</span><br><span class="line">    Context *on_all_applied = <span class="keyword">new</span> <span class="built_in">C_OSD_RepopApplied</span>(<span class="keyword">this</span>, repop);</span><br><span class="line">    Context *onapplied_sync = <span class="keyword">new</span> <span class="built_in">C_OSD_OndiskWriteUnlock</span>(</span><br><span class="line">        ctx-&gt;obc,</span><br><span class="line">        ctx-&gt;clone_obc,</span><br><span class="line">        unlock_snapset_obc ? ctx-&gt;snapset_obc : <span class="built_in">ObjectContextRef</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    pgbackend-&gt;<span class="built_in">submit_transaction</span>(</span><br><span class="line">        soid,</span><br><span class="line">        ctx-&gt;delta_stats,</span><br><span class="line">        ctx-&gt;at_version,</span><br><span class="line">        std::<span class="built_in">move</span>(ctx-&gt;<span class="type">op_t</span>),</span><br><span class="line">        pg_trim_to,</span><br><span class="line">        min_last_complete_ondisk,</span><br><span class="line">        ctx-&gt;log,</span><br><span class="line">        ctx-&gt;updated_hset_history,</span><br><span class="line">        onapplied_sync,</span><br><span class="line">        on_all_applied,</span><br><span class="line">        on_all_commit,</span><br><span class="line">        repop-&gt;rep_tid,</span><br><span class="line">        ctx-&gt;reqid,</span><br><span class="line">        ctx-&gt;op	<span class="comment">//操作请求</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># src/osd/ReplicatedBackend.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReplicatedBackend::submit_transaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">hobject_t</span> &amp;soid,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">object_stat_sum_t</span> &amp;delta_stats,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">eversion_t</span> &amp;at_version,</span></span></span><br><span class="line"><span class="params"><span class="function">  PGTransactionUPtr &amp;&amp;<span class="type">_t</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">eversion_t</span> &amp;trim_to,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">eversion_t</span> &amp;roll_forward_to,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> vector&lt;<span class="type">pg_log_entry_t</span>&gt; &amp;_log_entries,</span></span></span><br><span class="line"><span class="params"><span class="function">  boost::optional&lt;<span class="type">pg_hit_set_history_t</span>&gt; &amp;hset_history,</span></span></span><br><span class="line"><span class="params"><span class="function">  Context *on_local_applied_sync,</span></span></span><br><span class="line"><span class="params"><span class="function">  Context *on_all_acked,</span></span></span><br><span class="line"><span class="params"><span class="function">  Context *on_all_commit,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">ceph_tid_t</span> tid,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">osd_reqid_t</span> reqid,</span></span></span><br><span class="line"><span class="params"><span class="function">  OpRequestRef orig_op)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将PG事务转换为ObjectStore事务</span></span><br><span class="line">    <span class="built_in">generate_transaction</span>(</span><br><span class="line">        t,	<span class="comment">//PGTransactionUPtr t(std::move(_t));</span></span><br><span class="line">        coll,</span><br><span class="line">        (<span class="built_in">get_osdmap</span>()-&gt;require_osd_release &lt; CEPH_RELEASE_KRAKEN),</span><br><span class="line">        log_entries,</span><br><span class="line">        &amp;<span class="type">op_t</span>,	<span class="comment">//ObjectStore::Transaction op_t;</span></span><br><span class="line">        &amp;added,</span><br><span class="line">        &amp;removed</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义从副本操作请求与回调函数的关联结构</span></span><br><span class="line">    InProgressOp &amp;op = in_progress_ops.<span class="built_in">insert</span>(</span><br><span class="line">        <span class="built_in">make_pair</span>(</span><br><span class="line">            tid,</span><br><span class="line">            <span class="built_in">InProgressOp</span>(</span><br><span class="line">                tid, </span><br><span class="line">                on_all_commit, on_all_acked,orig_op, at_version)</span><br><span class="line">        )</span><br><span class="line">    ).first-&gt;second;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//向从副本提交ObjectStore事务</span></span><br><span class="line">    <span class="built_in">issue_op</span>(</span><br><span class="line">        soid,</span><br><span class="line">        at_version,</span><br><span class="line">        tid,</span><br><span class="line">        reqid,</span><br><span class="line">        trim_to,</span><br><span class="line">        at_version,</span><br><span class="line">        added.<span class="built_in">size</span>() ? *(added.<span class="built_in">begin</span>()) : <span class="built_in">hobject_t</span>(),</span><br><span class="line">        removed.<span class="built_in">size</span>() ? *(removed.<span class="built_in">begin</span>()) : <span class="built_in">hobject_t</span>(),</span><br><span class="line">        log_entries,</span><br><span class="line">        hset_history,</span><br><span class="line">        &amp;op,</span><br><span class="line">        <span class="type">op_t</span></span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/1234137269/PG事务到ObjectStore事务的转换过程.png" alt="PG事务到ObjectStore事务的转换过程"></p><h4 id="将PG事务转换为ObjectStore事务"><a href="#将PG事务转换为ObjectStore事务" class="headerlink" title="将PG事务转换为ObjectStore事务"></a>将PG事务转换为ObjectStore事务</h4><p>PG事务仅从客户端角度将请求分解为不同的事务执行单元，但本地持久化还需要考虑副本策略等特性，因此还需要将PG事务进一步转换为ObjectStore事务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/os/ObjectStore.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TransactionData data;				<span class="comment">// 该事务实例内，PG事务执行单元的数量，最大数据长度的信息</span></span><br><span class="line">    map&lt;<span class="type">coll_t</span>, __le32&gt; coll_index;		<span class="comment">//通过该索引查找collection信息</span></span><br><span class="line">    map&lt;<span class="type">ghobject_t</span>, __le32&gt; object_index;	<span class="comment">//通过该索引查找对象信息</span></span><br><span class="line"></span><br><span class="line">    __le32 coll_id &#123;<span class="number">0</span>&#125;;		<span class="comment">//本事务实例涉及的collection 索引数量</span></span><br><span class="line">    __le32 object_id &#123;<span class="number">0</span>&#125;;	<span class="comment">//本事务实例涉及的对象索引数量</span></span><br><span class="line"></span><br><span class="line">    bufferlist data_bl;		<span class="comment">//存储操作数据的bufferlist</span></span><br><span class="line">    bufferlist op_bl;		<span class="comment">//存储事务执行单元操作码的 bufferlist</span></span><br><span class="line"></span><br><span class="line">    bufferptr op_ptr;</span><br><span class="line"></span><br><span class="line">    list&lt;Context *&gt; on_applied;	<span class="comment">//on_appilied回调函数</span></span><br><span class="line">    list&lt;Context *&gt; on_commit;	<span class="comment">//on_commited回调函数</span></span><br><span class="line">    list&lt;Context *&gt; on_applied_sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>op_bl</code> 结构记录各执行单元的操作码、cid索引、oid索引</p><ul><li><p><code>coll_index</code> 记录了事务执行单元涉及的collection</p></li><li><p><code>object_index</code> 记录了目标对象的基本信息</p></li><li><p><code>data_bl</code> 记存放具体数据，包括要写入对象的内容数据和元数据</p><p>数据按照 <code>op_bl</code> 内事务执行单元的顺序依次编码进 <code>data_bl</code></p><p>一个事务执行单元可以对应多个数据条目</p></li></ul><p><img src="/posts/1234137269/ObjectStore事务各部分逻辑关系.png" alt="ObjectStore事务各部分逻辑关系"></p><p>事务使用 bufferlist 组织，便于将其打包进网络操作请求 <code>Message</code> 中</p><p>将 <code>PGTransaction</code> 转换为 <code>ObjectStore::Transaction</code> 的函数为 <code>PGTransaction::safe_create_traverse()</code></p><ul><li>对于多副本模式，PG事务已经按照顺序组织好操作数据，此处仅涉及不同结构成员的相互赋值</li><li>对于纠删码模式，需要将PG事务内的操作数据进一步运算转换</li></ul><h4 id="形成操作请求与回调函数的关联结构"><a href="#形成操作请求与回调函数的关联结构" class="headerlink" title="形成操作请求与回调函数的关联结构"></a>形成操作请求与回调函数的关联结构</h4><h5 id="RepGather"><a href="#RepGather" class="headerlink" title="RepGather"></a>RepGather</h5><blockquote><p>写操作请求的执行状态分为4个</p><ul><li><p>applied和committed表示写请求落盘的不同阶段</p><ul><li><p>applied 表示数据已进入日志盘</p></li><li><p>commited 表示数据已完成实际落盘</p><p>实际应用中，以commited为主，在相应的回调函数 on_committed() 中向客户端反馈写请求的执行结果</p></li></ul></li><li><p>success和finish用于请求的后处理</p><ul><li>success用于 Watch/Notify 相关操作</li><li>finish用于清理和资源回收</li></ul></li></ul></blockquote><p>RepGather 以<code>OpContext</code> 中的部分成员为标识符，定义了四种副本执行状态及相应的回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PrimaryLogPG.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RepGather</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">hobject_t</span> hoid;</span><br><span class="line">    OpRequestRef op;</span><br><span class="line">    <span class="type">bool</span> rep_aborted, rep_done;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> all_applied;	<span class="comment">//表示所有副本appiled的状态</span></span><br><span class="line">    <span class="type">bool</span> all_committed;	<span class="comment">//表示所有副本committed的状态</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> applies_with_commit;</span><br><span class="line"></span><br><span class="line">    list&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; on_applied;</span><br><span class="line">    list&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; on_committed;</span><br><span class="line">    list&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; on_success;</span><br><span class="line">    list&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; on_finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>PrimaryLogPG::execute_ctx()</code> 中，向从副本提交事务后，<code>eval_repop(RepGather)</code> 实现了各副本执行情况的汇集、判断和回调函数的调用执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PrimaryLogPG.cc</span></span><br><span class="line"><span class="comment">// 在新生成repop结构时，会将其置入repop_queue，用于操作请求查重</span></span><br><span class="line"><span class="function">PrimaryLogPG::RepGather *<span class="title">PrimaryLogPG::new_repop</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    OpContext *ctx, ObjectContextRef obc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">ceph_tid_t</span> rep_tid)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RepGather *repop = <span class="keyword">new</span> <span class="built_in">RepGather</span>(</span><br><span class="line">        ctx, rep_tid, info.last_complete, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//xlist&lt;RepGather*&gt; repop_queue</span></span><br><span class="line">	repop_queue.<span class="built_in">push_back</span>(&amp;repop-&gt;queue_item); </span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> repop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关联原始操作请求与回调函数"><a href="#关联原始操作请求与回调函数" class="headerlink" title="关联原始操作请求与回调函数"></a>关联原始操作请求与回调函数</h5><p><code>InProgressOp</code> 记录了请求ID与回调函数，用于从副本应答请求时，定位<strong>原始</strong>的写操作请求和回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/ReplicatedBackend.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplicatedBackend</span>: <span class="keyword">public</span> PGBackend&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">InProgressOp</span> &#123;</span><br><span class="line">    <span class="type">ceph_tid_t</span> tid;	<span class="comment">//本次操作请求的id</span></span><br><span class="line">    OpRequestRef op;</span><br><span class="line">    set&lt;<span class="type">pg_shard_t</span>&gt; waiting_for_commit;</span><br><span class="line">    set&lt;<span class="type">pg_shard_t</span>&gt; waiting_for_applied;</span><br><span class="line">    Context *on_commit;</span><br><span class="line">    Context *on_applied;</span><br><span class="line">    <span class="type">eversion_t</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  map&lt;<span class="type">ceph_tid_t</span>, InProgressOp&gt; in_progress_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InProgressOp</code> 属于 <code>PGBackend</code> 类，该类用于屏蔽多副本PG与纠删码PG的差异</p><ul><li>多副本PG被实现为 <code>ReplicatedBackend</code> 类</li><li>纠删码PG被实现为 <code>ECBackend</code> 类</li><li>在 PrimaryLogPG中，对副本PG的使用都是调用二者的父类 <code>PGBackend</code></li></ul><p>PG后续收到从副本反馈的执行结果反馈时，从 <code>pg-&gt;pgbackend.in_progress_ops</code> 中查找对应的 <code>InProgressOp</code> 。</p><ul><li><p>查找：后续从副本反馈执行结果时，依据<code>tid</code> 定位InProgressOp，进而由RepGather汇集执行状态</p><p>tid由主OSD维护，在OSD范围内递增，用于在本OSD范围内表示操作</p></li></ul><blockquote><p><strong><code>InProgressOp</code> 以回调程序对象的形式关联到 <code>RepGather</code></strong></p><p>一个预定义的回调程序对象如 <code>C_OSD_RepopCommit</code> ，可见，回调函数对象的构造需要与一个 <code>RepGather</code> 实例关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PrimaryLogPG.cc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C_OSD_RepopCommit</span> : <span class="keyword">public</span> Context &#123;</span><br><span class="line"> PrimaryLogPGRef pg;</span><br><span class="line"> boost::intrusive_ptr&lt;PrimaryLogPG::RepGather&gt; repop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C_OSD_RepopCommit</span>(PrimaryLogPG *pg, PrimaryLogPG::RepGather *repop): <span class="built_in">pg</span>(pg), <span class="built_in">repop</span>(repop) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/posts/1234137269/InPriogress与RepGather关联.png" alt="InPriogress与RepGather关联"></p></blockquote><h5 id="向从副本提交ObjectStore事务和PGLOG日志"><a href="#向从副本提交ObjectStore事务和PGLOG日志" class="headerlink" title="向从副本提交ObjectStore事务和PGLOG日志"></a>向从副本提交ObjectStore事务和PGLOG日志</h5><p>由 <code>PrimaryLogPG::issue_op()</code> 向所有从副本提交 ObjectStore 事务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">issue_op</span>(</span><br><span class="line">    soid,</span><br><span class="line">    at_version,</span><br><span class="line">    tid,	<span class="comment">//ceph_tid_t</span></span><br><span class="line">    reqid,</span><br><span class="line">    trim_to,</span><br><span class="line">    at_version,</span><br><span class="line">    added.<span class="built_in">size</span>() ? *(added.<span class="built_in">begin</span>()) : <span class="built_in">hobject_t</span>(),</span><br><span class="line">    removed.<span class="built_in">size</span>() ? *(removed.<span class="built_in">begin</span>()) : <span class="built_in">hobject_t</span>(),</span><br><span class="line">    log_entries,	<span class="comment">//PGLOG数据</span></span><br><span class="line">    hset_history,</span><br><span class="line">    &amp;op,</span><br><span class="line">    <span class="type">op_t</span>);<span class="comment">//ObjectStore事务</span></span><br></pre></td></tr></table></figure><ul><li>操作类型为 <code>MSG_OSD_REPOP</code></li><li><code>log_entries</code> 为PGLOG数据，由于各副本PG独立维护PGLOG，所以需要作为独立结构发送给从副本处理</li><li><code>op_t</code> 为ObjectStore事务</li></ul><p><code>issue_op()</code> 内部：</p><ol><li>先生成 <code>MSG_OSD_REPOP</code> 类型的网络请求</li><li>调用 <code>send_message_osd_cluster()</code> 将请求发送给该PG的所有副本</li></ol><p>从副本收到请求后，</p><ol><li>将 <code>PGLOG</code> 中的数据先根据本地的执行情况处理，</li><li>再和 <code>ObjectStore</code> 事务结合，完成本地的落盘，向主副本反馈执行结果</li></ol><h3 id="4-3-5-主副本操作请求落盘"><a href="#4-3-5-主副本操作请求落盘" class="headerlink" title="4.3.5 主副本操作请求落盘"></a>4.3.5 主副本操作请求落盘</h3><p>向从副本提交操作请求后，</p><ol><li><p>首先，主副本PG调用 <code>PG::write_if_dirty()</code> ，在本地立即将PGLOG <code>(pg_info_t) PG.info</code> 封装进 <code>ObjectStore::Transaction</code></p><ul><li><p><code>PG.info</code> 是确定确定权威PGLOG的判定标准</p></li><li><p>封装过程需要调用 <code>ObjectStore::Transaction::omap_setkeys()</code> 函数</p><p>将暂存于 <code>ctx-&gt;log</code> 中的日志信息封装进ObjectStore事务，作为一个 <code>omap_setkeys</code> 的事务执行单元</p><p>该 <code>omap_setkeys</code> 事务执行单元对应的OID为PG元数据对象， <code>Transaction.object_index</code> 增加该元数据对象的信息</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/PG.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PG::write_if_dirty</span><span class="params">(ObjectStore::Transaction&amp; t)</span></span>&#123;</span><br><span class="line">    map&lt;string,bufferlist&gt; km;</span><br><span class="line">    <span class="keyword">if</span> (dirty_big_info || dirty_info)</span><br><span class="line">        <span class="built_in">prepare_write_info</span>(&amp;km);</span><br><span class="line">    pg_log.<span class="built_in">write_log_and_missing</span>(t, &amp;km, coll, pgmeta_oid, pool.info.<span class="built_in">require_rollback</span>());</span><br><span class="line">    <span class="keyword">if</span> (!km.<span class="built_in">empty</span>())</span><br><span class="line">        t.<span class="built_in">omap_setkeys</span>(coll, pgmeta_oid, km);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>ObjectStore::Transaction</code> 的回调函数，同样以回调程序对象的方式与 <code>InProgressOp</code> 关联</p><p>后续在本地事务完成落盘后，直接通过 <code>InprogressOp</code> 回调 <code>eval_repop(RepGather)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/ReplicatedBackend</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReplicatedBackend::submit_transaction</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ObjectStore::Transaction <span class="type">op_t</span>;</span><br><span class="line">    InProgressOp &amp;op = in_progress_ops.<span class="built_in">insert</span>(</span><br><span class="line">    	<span class="built_in">make_pair</span>(</span><br><span class="line">      		tid,</span><br><span class="line">      		<span class="built_in">InProgressOp</span>(tid, on_all_commit, on_all_acked,orig_op, at_version)</span><br><span class="line">     	)</span><br><span class="line">    ).first-&gt;second;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">op_t</span>.<span class="built_in">register_on_applied_sync</span>(on_local_applied_sync);</span><br><span class="line">    <span class="type">op_t</span>.<span class="built_in">register_on_applied</span>(</span><br><span class="line">        parent-&gt;<span class="built_in">bless_context</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">C_OSD_OnOpApplied</span>(<span class="keyword">this</span>, &amp;op)));</span><br><span class="line">    <span class="type">op_t</span>.<span class="built_in">register_on_commit</span>(</span><br><span class="line">        parent-&gt;<span class="built_in">bless_context</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">C_OSD_OnOpCommit</span>(<span class="keyword">this</span>, &amp;op)));</span><br><span class="line">    </span><br><span class="line">    vector&lt;ObjectStore::Transaction&gt; tls;</span><br><span class="line">    tls.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(<span class="type">op_t</span>));</span><br><span class="line">    </span><br><span class="line">    parent-&gt;<span class="built_in">queue_transactions</span>(tls, op.op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完成上述操作后，调用 <code>ObjectStore::queue_transactions()</code> 接口将事务提交到本地存储后端</p><p>OSD存储后端对该接口有不同的实现方式，存储后端通过该函数：接收并执行提交过来的事务，将数据落盘，存入OSD</p></li><li><p>事务在本地执行，所以事务执行完成后，以进程内函数回调的形式反馈执行结果</p><p>BlueStore为存储后端时，由 finalize 线程回调，与PG工作线程属于同一进程的不同线程</p><ul><li><p>通过 <code>ObjectStore::Transaction</code> 的回调函数引用 <code>InProgressOp</code></p></li><li><p>通过 <code>InProgressOp</code> 的回调函数引用 <code>RepGather</code> ，汇集执行结果</p><p>由于本地直接回调，不需要在 in_progress_ops 列表中查找 InProgressOp 结构</p></li><li><p>执行 <code>eval_repop()</code> 函数</p></li></ul></li></ol><h3 id="4-3-6-从副本处理与主副本后处理"><a href="#4-3-6-从副本处理与主副本后处理" class="headerlink" title="4.3.6 从副本处理与主副本后处理"></a>4.3.6 从副本处理与主副本后处理</h3><h4 id="从副本处理"><a href="#从副本处理" class="headerlink" title="从副本处理"></a>从副本处理</h4><p>从副本接收到 <code>MSG_OSD_REPOP</code> 消息后</p><ol><li>进入从副本的OSD全局队列，并被分配到所属PG的子队列中</li><li>由PG将其出队</li><li><code>xxxPGBackend</code> 根据消息类型 <code>MSG_OSD_REPOP</code> 将其提交给 <code>xxxPGBackend::do_repop()</code> 处理</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/osd/ReplicatedBackend.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReplicatedBackend::do_repop</span><span class="params">(OpRequestRef op)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">RepModifyRef <span class="title">rm</span><span class="params">(std::make_shared&lt;RepModify&gt;())</span></span>;</span><br><span class="line">    rm-&gt;op = op;</span><br><span class="line">    rm-&gt;ackerosd = ackerosd;</span><br><span class="line">    rm-&gt;last_complete = <span class="built_in">get_info</span>().last_complete;</span><br><span class="line">    rm-&gt;epoch_started = <span class="built_in">get_osdmap</span>()-&gt;<span class="built_in">get_epoch</span>();</span><br><span class="line">    ...</span><br><span class="line">    parent-&gt;<span class="built_in">log_operation</span>(	<span class="comment">//将PGLOG封装为一个新的事务 rm-&gt;localt</span></span><br><span class="line">        log,</span><br><span class="line">        m-&gt;updated_hit_set_history,</span><br><span class="line">        m-&gt;pg_trim_to,</span><br><span class="line">        m-&gt;pg_roll_forward_to,</span><br><span class="line">        update_snaps,</span><br><span class="line">        rm-&gt;localt);</span><br><span class="line">    </span><br><span class="line">    rm-&gt;opt.<span class="built_in">register_on_commit</span>(</span><br><span class="line">        parent-&gt;<span class="built_in">bless_context</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">C_OSD_RepModifyCommit</span>(<span class="keyword">this</span>, rm)));</span><br><span class="line">    rm-&gt;localt.<span class="built_in">register_on_applied</span>(</span><br><span class="line">        parent-&gt;<span class="built_in">bless_context</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">C_OSD_RepModifyApply</span>(<span class="keyword">this</span>, rm)));</span><br><span class="line">    vector&lt;ObjectStore::Transaction&gt; tls;</span><br><span class="line">    tls.<span class="built_in">reserve</span>(<span class="number">2</span>);</span><br><span class="line">    tls.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(rm-&gt;localt));</span><br><span class="line">    tls.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(rm-&gt;opt));</span><br><span class="line">    parent-&gt;<span class="built_in">queue_transactions</span>(tls, op);</span><br><span class="line">    <span class="comment">// op is cleaned up by oncommit/onapply when both are executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从消息中提取出 <code>PGLOG</code> ，整理为从副本本地待更新的PGLOG数据</li><li>创建一个新的 <code>ObjectStore::Transcation</code> ，将 <code>PGLOG</code> 数据落盘的操作转换为 <code>omap_setkeys</code> 执行单元，封装进新创建的事务</li><li>调用 <code>queue_transactions</code> 接口，将主副本发送的事务与新创建的事务一同提交给存储后端落盘</li></ul><h4 id="主副本后处理"><a href="#主副本后处理" class="headerlink" title="主副本后处理"></a>主副本后处理</h4><p>从副本执行结果的反馈消息类型为 <code>MSG_OSD_REPOPREPLY</code></p><p>反馈消息达到主OSD后，仍先进入OSD全局队列，被分配到所属PG的子队列</p><ul><li>不需要经过查重、对象存在性确认</li></ul><p>由PG将其出队，由 <code>PrimaryLogPG::do_request()</code> 依据消息类型 <code>MSG_OSD_REPOPREPLY</code> 最终将其提交给 <code>XXXPGBackend::do_repop_reply()</code> 处理</p><ul><li>首先根据 <code>reqid</code> ，到 <code>in_progress_ops</code> 列表中查找对应的 <code>InProgressOp</code> 结构</li><li>通过 <code>InProgressOp</code> 的回调函数关联到 <code>RepGather</code> ，汇集各副本的执行结果</li></ul><p>最终调用 <code>PrimaryLogPG::eval_repop(RepGather)</code> ，判断汇集结果并进行相应处理</p><ul><li><p>根据 <code>RepGather.all_committed</code> 的值判断各副本 committed 结果</p><ul><li><p>true，调用 <code>oncommited</code> 处登记的回调函数，反馈给客户端执行结果，消息类型为 <code>CEPH_MSG_OSD_OPREPLY</code></p><p>调用相关清除 <code>(OpContext) ctx</code> 、处理Watch/Notify操作等函数</p></li></ul></li></ul><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>客户端默认将读操作请求发送给PG主副本</p><p>客户端的读请求发送到PG所在的OSD后，OSD读取本地存储中的对象数据。读取成功后，返回给客户端</p><ul><li>缓存机制可以提高读性能，若缓存中有，则OSD直接从缓存中提供数据</li></ul><h2 id="恢复与再平衡"><a href="#恢复与再平衡" class="headerlink" title="恢复与再平衡"></a>恢复与再平衡</h2><p><strong>恢复等待时间</strong></p><p>在故障域中的组件发生故障后，Ceph会进入默认等待时间，等待时间耗尽后，会将该OSD标记为 down out 并初始化恢复</p><ul><li>通过Ceph集群配置文件中的 <code>mon osd down out interval</code> 配置项，可以修改等待时间</li></ul><p><strong>再平衡操作</strong></p><p>在恢复操作期间，Ceph会进行再平衡操作：重新组织发生故障的结点上受影响的数据，保证集群中所有磁盘能均匀使用</p><p>原则：尽量减少数据的移动来构建新的集群布局</p><p>对于利用率高的集群，建议先将新添加的OSD权重设置为0，再依据磁盘容量逐渐提高权重，减少Ceph集群再平衡的负载并避免性能下降</p><h2 id="3-4-后端存储Object-Store（不重要）"><a href="#3-4-后端存储Object-Store（不重要）" class="headerlink" title="3.4 后端存储Object Store（不重要）"></a>3.4 后端存储Object Store（不重要）</h2><p>Object Store完成实际的数据存储，封装了所有对底层IO的操作</p><ul><li>IO请求从客户端发出后，最终会使用ObjectStore提供的API将数据存储磁盘</li></ul><p>目前有四种实现方式，可以在配置文件中通过 <code>osd_objectstore</code> 指定：</p><ul><li>MemStore：将所有的数据放入内存；仅由于测试</li><li>KSStore（元数据）：将元数据和Data全部放入KVDB；仅用于测试</li></ul><h3 id="3-4-1-FileStore"><a href="#3-4-1-FileStore" class="headerlink" title="3.4.1 FileStore"></a>3.4.1 FileStore</h3><blockquote><p>L版之前，OSD后端存储只有FileStore；L版~R版，默认为BlusStore；R版之后，FileStore废弃</p></blockquote><p>FileStore基于Linux现有的文件系统，将Object存放在文件系统上。</p><p>每个Object会被FileStore看做一个文件，Object的属性(xattr)会利用文件属性存取</p><ul><li>对于ext4，对xattr有限制，超出长度的属性会用 omap 存储</li></ul><h3 id="3-4-2-BlueStore"><a href="#3-4-2-BlueStore" class="headerlink" title="3.4.2 BlueStore"></a>3.4.2 BlueStore</h3><p>FileStore最初只针对机械盘设置，并未对SSD进行优化，且写数据前先写日志带来了一倍的写放大。</p><p>BlueStore专为管理Ceph OSD工作负载的磁盘数据而设计。去除了日志，直接管理裸设备来减少文件系统部分的开销，并且对SSD进行了单独优化</p><p>与传统文件系统类似，分为三部分：</p><ul><li>数据管理</li><li>元数据管理</li><li>空间管理</li></ul><p>与文件系统区别之处在于数据与元数据可以存储在不同的介质中</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>直接管理存储设备</p><ul><li>BlueStore使用原始块设备或分区，避免文件系统(XFS)的限制与抽象干预层</li></ul><p>使用RocksDB进行元数据管理</p><ul><li>对象名到磁盘块位置的映射</li></ul><p>完整数据和元数据校验和</p><ul><li>写入BlueStore的所有数据和元数据都收到一个或多个校验和的保护</li><li>未经验证，不会从磁盘读取任何数据、元数据且不会返回给用户</li></ul><p>内联压缩</p><ul><li>数据在写入磁盘之前可以选择进行压缩</li></ul><p>多设备元数据分层</p><ul><li>BlueStore允许将其内部日志(预写日志)写入单独的高速设备(SSD、NVMe或NVDIMM)，以提高性能。</li></ul><h3 id="3-4-3-SeaStore"><a href="#3-4-3-SeaStore" class="headerlink" title="3.4.3 SeaStore"></a>3.4.3 SeaStore</h3><p>目前仅是设计雏形</p><p>设计目标：</p><ul><li>专门为NVMe设备设计，不是PMEM和硬盘驱动器</li><li>使用SPDK访问NVMe，不再使用Linux AIO</li><li>使用SeaStar Future编程模型优化，使用share-nothing机制避免锁竞争</li><li>网络驱动使用DPDK实现零拷贝</li></ul><p>由于Flash设备特性，重写时必须进行擦除操作，并不清楚哪些数据有效，哪些数据无效，但文件系统知道。</p><p>Ceph希望垃圾回收有SeaStore来做，SeaStore的设计思路：</p><ul><li><p>SeaStore逻辑段应该与硬件（Flash擦除单位）对齐</p></li><li><p>SeaStar是每个线程一个CPU核，所以将底层按照CPU核进行分段</p></li><li><p>当空间使用率达到设定上限就进行回收，当segment完成回收后，就调用discard线程通知硬件进行擦除。</p><p>尽可能保证逻辑段与物理段对齐，避免出现逻辑段无有效数据但是底层物理段存在，会造成额外的读/写操作</p><p>同时由discard带来消耗，需要尽量平滑地处理回收工作，减少对正常读/写的印象概念股</p></li><li><p>用一个公用的表管理segment的分配工作</p></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/1234137269/" title="4.OSD">https://amostian.github.io/posts/1234137269/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 存储</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 分布式存储</a> <a href="/tags/Ceph/" rel="tag"><i class="fa fa-tags"></i> Ceph</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2928535482/" rel="prev" title="3.Monitor"><i class="fa fa-chevron-left"></i> 3.Monitor</a></div><div class="post-nav-item"><a href="/posts/181607087/" rel="next" title="5.BlueStore">5.BlueStore <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-OSD%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">4.1 OSD中的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-Ceph%E8%A7%86%E8%A7%92%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">4.1.1 Ceph视角的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-OSD%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">4.1.2 OSD中的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">对象的标识符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">对象的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">元数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#head%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1"><span class="nav-text">head对象与克隆对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-text">4.1.3 对象的组织与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="nav-text">存储池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PG"><span class="nav-text">PG</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-OSD%E7%BB%84%E4%BB%B6"><span class="nav-text">4.2 OSD组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-PG"><span class="nav-text">4.2.1 PG</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Collection"><span class="nav-text">对象的组织结构——Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PG%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">PG的元数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PG%E4%B8%8EPGP"><span class="nav-text">PG与PGP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PG-peer-%E5%92%8Cup%E3%80%81acting%E9%9B%86%E5%90%88"><span class="nav-text">PG peer 和up、acting集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-op-shardedwq"><span class="nav-text">4.2.2 op_shardedwq</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#class-PGQueueable"><span class="nav-text">class PGQueueable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#class-ShardedOpWQ"><span class="nav-text">class ShardedOpWQ</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ShardedOpWQ%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">ShardedOpWQ的处理函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PG-lock%E7%B2%92%E5%BA%A6"><span class="nav-text">PG lock粒度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#osd-snap-trim-sleep%E5%92%8Cosd-scrub-sleep%E9%85%8D%E7%BD%AE"><span class="nav-text">osd_snap_trim_sleep和osd_scrub_sleep配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E5%9C%A8OSD%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-text">4.3 操作请求在OSD中的处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E7%BD%AE%E5%85%A5%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">4.3.1 操作请求置入工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%86%99%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E4%B8%BAMessage"><span class="nav-text">1. 写请求转换为Message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B0%86Message%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2%E4%B8%BAOpRequest"><span class="nav-text">2. 将Message结构转换为OpRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8OSD%E5%85%A8%E5%B1%80%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9FQoS"><span class="nav-text">3. 使用OSD全局工作队列控制系统QoS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Weightedpriority%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="nav-text">Weightedpriority（默认）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E8%AF%B7%E6%B1%82%E5%9C%A8%E5%85%A8%E5%B1%80%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E5%85%A5%E9%98%9F%E8%BF%87%E7%A8%8B"><span class="nav-text">写请求在全局工作队列的入队过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%87%BA%E9%98%9F%E8%BF%87%E7%A8%8B"><span class="nav-text">请求出队过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-PG%E4%BA%8B%E5%8A%A1%E7%94%9F%E6%88%90%E5%89%8D%E7%9A%84OSD%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="nav-text">4.3.2 PG事务生成前的OSD处理阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8F%AF%E8%B0%83%E5%BA%A6%E6%80%A7-%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E6%9F%A5%E9%87%8D%E3%80%81%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E9%99%8D%E7%BA%A7%E7%8A%B6%E6%80%81"><span class="nav-text">1. 判断操作的可调度性(操作请求查重、对象是否处于降级状态)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-text">重复操作请求处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%8D%E7%BA%A7%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86"><span class="nav-text">降级对象处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%A1%AE%E5%AE%9A%E5%BE%85%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF"><span class="nav-text">2. 确定待操作对象是否存在，并获取目标对象的上下文信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B1%87%E9%9B%86%E8%AF%B7%E6%B1%82%E6%B6%89%E5%8F%8A%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E5%BD%A2%E6%88%90OpContext"><span class="nav-text">3. 汇集请求涉及的结构，形成OpContext</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E5%9C%A8PG%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%94%9F%E6%88%90PG%E4%BA%8B%E5%8A%A1"><span class="nav-text">4.3.3 在PG处理线程中生成PG事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PG%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="nav-text">PG事务介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-text">事务转换过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#do-osd-ops%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%BA%E7%A1%80%E5%A4%84%E7%90%86"><span class="nav-text">do_osd_ops——操作请求的基础处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#make-writeable%E2%80%94%E2%80%94%E5%BF%AB%E7%85%A7%E5%8A%9F%E8%83%BD%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">make_writeable——快照功能的处理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#finish-ctx%E2%80%94%E2%80%94%E7%94%9F%E6%88%90OI%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83%E4%B8%8EPGLOG%E6%97%A5%E5%BF%97"><span class="nav-text">finish_ctx——生成OI属性更新的事务执行单元与PGLOG日志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-%E5%85%B3%E8%81%94%E4%BB%8E%E5%89%AF%E6%9C%AC%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B9%B6%E5%90%91%E4%BB%8E%E5%89%AF%E6%9C%AC%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="nav-text">4.3.4 关联从副本事务的回调函数，并向从副本提交事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86PG%E4%BA%8B%E5%8A%A1%E8%BD%AC%E6%8D%A2%E4%B8%BAObjectStore%E4%BA%8B%E5%8A%A1"><span class="nav-text">将PG事务转换为ObjectStore事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A2%E6%88%90%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E8%81%94%E7%BB%93%E6%9E%84"><span class="nav-text">形成操作请求与回调函数的关联结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RepGather"><span class="nav-text">RepGather</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%8E%9F%E5%A7%8B%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">关联原始操作请求与回调函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E4%BB%8E%E5%89%AF%E6%9C%AC%E6%8F%90%E4%BA%A4ObjectStore%E4%BA%8B%E5%8A%A1%E5%92%8CPGLOG%E6%97%A5%E5%BF%97"><span class="nav-text">向从副本提交ObjectStore事务和PGLOG日志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-5-%E4%B8%BB%E5%89%AF%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B7%E6%B1%82%E8%90%BD%E7%9B%98"><span class="nav-text">4.3.5 主副本操作请求落盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-6-%E4%BB%8E%E5%89%AF%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%8E%E4%B8%BB%E5%89%AF%E6%9C%AC%E5%90%8E%E5%A4%84%E7%90%86"><span class="nav-text">4.3.6 从副本处理与主副本后处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%89%AF%E6%9C%AC%E5%A4%84%E7%90%86"><span class="nav-text">从副本处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%89%AF%E6%9C%AC%E5%90%8E%E5%A4%84%E7%90%86"><span class="nav-text">主副本后处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="nav-text">读操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="nav-text">恢复与再平衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8Object-Store%EF%BC%88%E4%B8%8D%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-text">3.4 后端存储Object Store（不重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-FileStore"><span class="nav-text">3.4.1 FileStore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-BlueStore"><span class="nav-text">3.4.2 BlueStore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-text">功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-SeaStore"><span class="nav-text">3.4.3 SeaStore</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">236</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1252.1k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">50:25</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>