<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="图：点+边+边与点的映射函数   连通性与判别   欧拉图与哈密尔顿图   二分图和平面图与欧拉公式   树及生成树   单源点最短路径：Dijkstra算法   对偶图"><meta property="og:type" content="article"><meta property="og:title" content="4.图论"><meta property="og:url" content="https://amostian.github.io/posts/284249815/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="图：点+边+边与点的映射函数   连通性与判别   欧拉图与哈密尔顿图   二分图和平面图与欧拉公式   树及生成树   单源点最短路径：Dijkstra算法   对偶图"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303082804835.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303085546084.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303090624510.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303091518947.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303092739035.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303093720009.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303152613653.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303152838883.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303153334119.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303154240319.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303155143874.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303160304708.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303105246437.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303110852805.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303111929602.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303102112319.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303115954884.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303130049379.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303161038032.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303170315265.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303170542382.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303192527280.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303205417387.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303212424594.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303212835377.png"><meta property="og:image" content="https://amostian.github.io/posts/284249815/image-20220303213222324.png"><meta property="article:published_time" content="2022-03-02T12:55:45.000Z"><meta property="article:modified_time" content="2023-03-24T03:09:16.480Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="数学"><meta property="article:tag" content="离散数学"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/284249815/image-20220303082804835.png"><link rel="canonical" href="https://amostian.github.io/posts/284249815/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>4.图论 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">58</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">74</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">353</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/284249815/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">4.图论</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2022-03-02 20:55:45" itemprop="dateCreated datePublished" datetime="2022-03-02T20:55:45+08:00">2022-03-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2023-03-24 11:09:16" itemprop="dateModified" datetime="2023-03-24T11:09:16+08:00">2023-03-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">离散数学</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">1.2k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>图：点+边+边与点的映射函数</p><p>连通性与判别</p><p>欧拉图与哈密尔顿图</p><p>二分图和平面图与欧拉公式</p><p>树及生成树</p><p>单源点最短路径：Dijkstra算法</p><p>对偶图</p></blockquote><span id="more"></span><h1 id="4-图论"><a href="#4-图论" class="headerlink" title="4. 图论"></a>4. 图论</h1><h2 id="4-1-图的基本概念"><a href="#4-1-图的基本概念" class="headerlink" title="4.1 图的基本概念"></a>4.1 图的基本概念</h2><h3 id="4-1-1-图"><a href="#4-1-1-图" class="headerlink" title="4.1.1 图"></a>4.1.1 图</h3><blockquote><p>一个图G是一个三重组<script type="math/tex"><V(G),E(G),\Phi_G></script></p><ul><li>V(G)是一个非空的结点集合</li><li>E(G)是边的集合</li><li>关联函数$\Phi_G$ ：是从边集E与结点偶对间的映射函数</li></ul></blockquote><p><img src="/posts/284249815/image-20220303082804835.png" alt></p><h3 id="4-1-2-图的分类"><a href="#4-1-2-图的分类" class="headerlink" title="4.1.2 图的分类"></a>4.1.2 图的分类</h3><h4 id="按边类型分类"><a href="#按边类型分类" class="headerlink" title="按边类型分类"></a>按边类型分类</h4><p>有向图：每一条边都是有向边</p><ul><li>有向边（弧）：边对应的偶对是有序的，用序偶对 $<a ,b>$ 表示<ul><li>有向边的端点：弧的始点与终点</li></ul></a></li></ul><p>无向图：图中的每一条边都是无向的</p><ul><li>无向边（棱）：偶对无序，用偶对 $(a,b)$ 表示</li></ul><p>混合图：图中一些边是有向边，一些边是无向边</p><ul><li>混合边：两结点间既有有向边，又有无向边，用 $[a,b]$ 表示</li></ul><h4 id="结点间的边数"><a href="#结点间的边数" class="headerlink" title="结点间的边数"></a>结点间的边数</h4><p>平行边</p><ul><li>有向图：两结点间(包括结点自身间)，若同始点和终点的边多于一条，则这几条边称为平行边</li><li>无向图：两结点间（包括结点自身间），若多于一条边，则称这几条边为平行边</li></ul><p>重数：两结点间互相平行的边的条数称为 [a,b] 的重数。注意有向图需要同始点同终点</p><p>多重图：含有平行边的图</p><p>线图：不含平行边的图</p><ul><li>简单图：无自回路的线图<ul><li>平凡图仅有一个结点的简单图</li></ul></li></ul><h4 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h4><ul><li><p>零图：全由孤立结点构成的图</p><p>孤立结点：不与任何结点邻接的结点</p></li><li><p>含有自回路的图</p><p>自回路：关联于同一结点的一条边</p></li><li><p>赋权图：边或结点上带有信息，用 三重组或者四重组 表示 $<v ,e,g>或<v ,e,f,g>$</v></v></p><ul><li>V：结点集合</li><li>E：边的集合</li><li>f：定义在边上的函数</li><li>g：定义在结点上的函数</li></ul><p>如：<img src="/posts/284249815/image-20220303085546084.png" alt></p></li></ul><h3 id="4-1-3-邻接关系"><a href="#4-1-3-邻接关系" class="headerlink" title="4.1.3 邻接关系"></a>4.1.3 邻接关系</h3><p>点的邻接：两结点间由边</p><p>边邻接：几条边关联于同一结点，则边邻接</p><h3 id="4-1-4-有向图的底图"><a href="#4-1-4-有向图的底图" class="headerlink" title="4.1.4 有向图的底图"></a>4.1.4 有向图的底图</h3><p>把有向图总的每条边都看做无向边，得到无向图，称为底图</p><h3 id="4-1-5-结点的次数-度"><a href="#4-1-5-结点的次数-度" class="headerlink" title="4.1.5 结点的次数(度)"></a>4.1.5 结点的次数(度)</h3><ul><li><p>出度（引出次数）：有向图中，以结点v为始点的边的条数，记为 $deg^+(v)$</p></li><li><p>入度（引入次数）：有向图中，以结点v为终点的边的条数，记为 $deg^-(v)$</p></li><li><p>次数（度数）：结点v的引出次数和引入次数之和称为结点v的条数，记为 $deg(v)$</p><ul><li>孤立结点v的次数为零</li></ul></li></ul><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><blockquote><p>(n,m)图 ：n个结点m条边</p></blockquote><p><strong>握手定理</strong>：设G是一个(n,m)图，结点集合为 $\{v_1,v_2,…,v_n\}$ ，则</p><ul><li><strong>度数之和是边数的二倍</strong>：$\sum_{i=1}^n deg^+(v_i)+\sum_{i=1}^n deg^-(v_i)=2m$</li><li>在图中，次数为奇数的结点必为偶数个</li></ul><blockquote><p>正则图：各结点次数均相同的无向图，记为 <strong>k-正则图</strong></p></blockquote><p><img src="/posts/284249815/image-20220303090624510.png" alt></p><p>如上图为3-正则图</p><h3 id="4-1-6-图间的同构关系"><a href="#4-1-6-图间的同构关系" class="headerlink" title="4.1.6 图间的同构关系"></a>4.1.6 图间的同构关系</h3><blockquote><p>图的同构：设<script type="math/tex">G=<V,E></script>和<script type="math/tex">G'=<V',E'></script>是两个图，若存在 V到V’ 的双射函数 $\Phi$ ，使对 $\forall a,b\in V,[a,b]\in E$ 有 $[\Phi(a),\Phi(b)]\in E’$ ，并且 $[a,b]与[\Phi(a),\Phi(b)]$ 有相同的重数</p></blockquote><p><strong>同构的必要条件：</strong></p><ol><li>结点数相等</li><li>边数相等</li><li>度数相同的结点数相等</li></ol><p>但不能作为充分条件，如：</p><p><img src="/posts/284249815/image-20220303091518947.png" alt></p><h3 id="4-1-7-图的运算"><a href="#4-1-7-图的运算" class="headerlink" title="4.1.7 图的运算"></a>4.1.7 图的运算</h3><p>设图<script type="math/tex">G_1=<V_1,E_1>,G_2=<V_2,E_2>,G_2=<V_3,E_3></script></p><blockquote><p>$G_1\cup G_2$ ： $V_3=V_1\cup V_2,E_3=E_1\cup E_2$</p><p>$G_1\cap G_2$：$V_3=V_1\cap V_2,E_3=E_1\cap E_2$</p><p>$G_1- G_2$：$E_3=E_1- E_2,V_3=(V_1- V_2)\cup \{E_3中边所关联的顶点\}$</p><p>$G_1\oplus G_2$：$G_3=(G_1\cup G_2)-(G_1\cap G_2)$</p><p>删去图中一个结点v：删去结点v与v关联的所有边</p></blockquote><p><img src="/posts/284249815/image-20220303092739035.png" alt="image-20220303092739035"></p><h3 id="4-1-8-子图"><a href="#4-1-8-子图" class="headerlink" title="4.1.8 子图"></a>4.1.8 子图</h3><h4 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h4><p>设<script type="math/tex">G=<V,E>,G'=<V',E'></script>是两个图</p><blockquote><p>子图： 如果 $V’\subseteq V且E’\subseteq E$ ，则称G’是G的子图</p><p>真子图：如果 $G’\neq G$ ，则称G’是G的真子图</p><p>生成子图：$V’=V且E’\subseteq E$</p><p>由边集E’导出的子图 $G[E’]$：子图G’中没有孤立结点，G’由E’唯一确定</p><p>由结点集V’导出的子图 $G[V’]$ ：子图G’中，对V’中的任意两结点u,v，当 $[u,v]\in E且[u,v]\in E’$ ，则G’由V’唯一确定</p></blockquote><p><img src="/posts/284249815/image-20220303093720009.png" alt="image-20220303093720009"></p><h3 id="4-1-9-完全图与补图"><a href="#4-1-9-完全图与补图" class="headerlink" title="4.1.9 完全图与补图"></a>4.1.9 完全图与补图</h3><p>完全图</p><ul><li>在n个结点的有向图<script type="math/tex">G=<V,E></script>中，如果 $E=V\times V$ ，则G是有向完全图</li><li>在n各结点的无向图<script type="math/tex">G=<V,E></script>中，如果任何两个不同结点间都有一条边，则称G是无向完全图</li></ul><p>补图</p><blockquote><p>设线图<script type="math/tex">G=<V,E></script>有n个顶点，线图<script type="math/tex">H=<V,E'></script>也有同样的顶点，而E’是由n个顶点的完全图的边删去E所得，则图H称为G的补图</p></blockquote><h2 id="4-2-图的矩阵表示"><a href="#4-2-图的矩阵表示" class="headerlink" title="4.2 图的矩阵表示"></a>4.2 图的矩阵表示</h2><p>设<script type="math/tex">G=<V,E></script>是一个有向线图。定义一个n阶方阵 $A(a_{ij})$ 为G的邻接矩阵，其中</p><script type="math/tex;mode=display">a_{ij}=\begin{cases}
1\quad <v_i,v_j>\in E\\
0\quad <v_i,v_j>\notin E\\
\end{cases}</script><p>特殊图的邻接矩阵</p><p>零图：零矩阵，元素全为0</p><p>每个顶点都有自回路而无其他边：单位矩阵</p><p>G的逆图 $\widetilde{G}$：图G的矩阵A的转置矩阵 $A^T$</p><h3 id="4-2-1-性质"><a href="#4-2-1-性质" class="headerlink" title="4.2.1 性质"></a>4.2.1 性质</h3><p>若为有向简单图，则</p><ul><li><p>A(G)不一定是对称的</p></li><li><p>对角线为0</p></li><li><p>第i行中值为1的元素数目等于 $v_i$ 的出度，第j列中值为1的元素数目等于 $v_j$ 的入度</p><p>$\sum_{j=1}^na_{ij}=deg^+(v)\quad \sum_{i=1}^na_{ij}=deg^-(v)$</p></li></ul><p>若G为无向简单图</p><ul><li><p>A(G)是对称的</p></li><li><p>对角线为0</p></li><li><p>第i行中值为1的元素数目等于 $v_i$ 的度，第j列中值为1的元素数目等于 $v_j$ 的度</p><p>$\sum_{j=1}^na_{ij}=deg^(v)\quad \sum_{i=1}^na_{ij}=deg^(v)$</p></li></ul><h3 id="4-2-2-矩阵运算的意义"><a href="#4-2-2-矩阵运算的意义" class="headerlink" title="4.2.2 矩阵运算的意义"></a>4.2.2 矩阵运算的意义</h3><h4 id="AA-T"><a href="#AA-T" class="headerlink" title="$AA^T$"></a>$AA^T$</h4><p>令 $B=[b_{ij}]=AA^T$</p><p>从结点 $v_i$ 和 $v_j$ 两者引出的边，如果能共同终止于一些结点，则这些终止结点的数目就是 $v_{ij}$ 的值</p><p>对角线上元素的值是各结点的出度</p><p><img src="/posts/284249815/image-20220303152613653.png" alt></p><ol><li>i=2,j=3，$b_{23}=1$ 说明从 $v_2$ 和 $v_3$ 引出的边能共同终止与同一结点的只有一个</li><li>i=2,j=2，$b_{22}=2$，说明 $v_2$ 的出度为2</li></ol><h4 id="A-TA"><a href="#A-TA" class="headerlink" title="$A^TA$"></a>$A^TA$</h4><p>令 $B=[b_{ij}]=A^TA$</p><p>从一些结点引出的边，如果同时终于 $v_i$ 和 $v_j$ ，则这些结点的数目为 $b_{ij}$ 的值</p><p>对角线上元素的值就是结点的入度</p><p><img src="/posts/284249815/image-20220303152838883.png" alt></p><ol><li>i=2,j=1，$b_{21}$ 说明以 $v_2$ 和 $v_1$ 为终点的边的共同始点只有一个</li><li>i=2,j=2，$b_{22}$ 说明 $v_2$ 的入度为2</li></ol><h4 id="A-n"><a href="#A-n" class="headerlink" title="$A^{(n)}$"></a>$A^{(n)}$</h4><p>$A^{(n)}=a_{ij}^{(n)}$ 表示从 $v_i$ 到 $v_j$ 的长度为n的不同路径的数目</p><p><img src="/posts/284249815/image-20220303153334119.png" alt="image-20220303153334119"></p><p>设矩阵 $Br=A+A^{(2)}+…+A^{(r)}$ ，$b_{ij}$ 表示从 $v_i$ 到 $v_j$ 的长度小于和等于r的不同路径总数</p><p>又由于简单有向图中，基本路径长度不超过 n-1，基本回路长度不超过n，则</p><script type="math/tex;mode=display">\begin{aligned}
&路径：B_{n-1}=A+A^{(2)}+...+A^{(n-1)}\\
&回路：B_{n}=A+A^{(2)}+...+A^{n}
\end{aligned}</script><p>$b_{ij}$ 表明了结点间的可达性</p><p><img src="/posts/284249815/image-20220303154240319.png" alt></p><h3 id="4-3-3-可达矩阵"><a href="#4-3-3-可达矩阵" class="headerlink" title="4.3.3 可达矩阵"></a>4.3.3 可达矩阵</h3><p>设<script type="math/tex">G=<V,E></script>是一个有向图， $\mid V \mid = n$ ，n阶方阵 $P_{ij}=(p_{ij})$ ，其中</p><script type="math/tex;mode=display">\begin{aligned}
p_{ij}&=\begin{cases}
1\quad从v_i到v_j至少存在一条非零长度的路径\\
0\quad从v_i到v_j不存在一条非零长度的路径
\end{cases}\\\\
P&=A\vee A^{(2)}\vee ...\vee A^{(n)}
\end{aligned}</script><p>则P为可达矩阵</p><p><img src="/posts/284249815/image-20220303155143874.png" alt></p><h4 id="由可达矩阵求强分图"><a href="#由可达矩阵求强分图" class="headerlink" title="由可达矩阵求强分图"></a>由可达矩阵求强分图</h4><p>$p_{ij}=1$ 表示从 $v_i$ 到 $v_j$ 可达，$p_{ji}=p_{ij}^T=1$ 表示从 $v_j$ 到 $v_i$ 可达。仅当 $v_i$ 与 $v_j$ 互相可达时，才是连通。</p><p>当且仅当 $v_i$ 和 $v_j$ 相互可达时，$P^T\wedge P$ 的(i,j) 元素的值为1</p><p><img src="/posts/284249815/image-20220303160304708.png" alt></p><h2 id="4-3-路径与回路"><a href="#4-3-路径与回路" class="headerlink" title="4.3 路径与回路"></a>4.3 路径与回路</h2><p><strong>边不重，点不同；简单与基本</strong></p><blockquote><p>从 $v_0到v_n$ 的路径：图的一个点边交替序列 $(v_0,e_1,v_1,…,e_n,v_n)$ ，</p><p><strong>简单</strong>路径：同一条边不出现两次的路径</p><p><strong>基本</strong>路径(链)：同一顶点不出现两次</p><p>回路：路径始点 $v_0$ 与 终点 $v_n$ 重合</p><p><strong>简单</strong>回路：边不重复的回路</p><p><strong>基本</strong>回路：通过各顶点的不超过一次的回路</p></blockquote><p>如果是线图，路径P可以用顶点序列表示，称P穿程于顶点序列</p><p>路径的长度：路径P所含边的条数。</p><ul><li><p>在有n个结点的简单图<script type="math/tex">G=<V,E></script>中，如果 $v_1$ 到 $v_2$ 有一条路径，则路径长度必不大于 n-1</p></li><li><p>在有n个结点的简单图<script type="math/tex">G=<V,E></script>中，如果经 $v_1$ 有一条简单回路，则经 $v_1$ 有一条长度不超n的基本回路</p></li></ul><h3 id="4-3-1-连通度与连通图"><a href="#4-3-1-连通度与连通图" class="headerlink" title="4.3.1 连通度与连通图"></a>4.3.1 连通度与连通图</h3><h4 id="无向图的连通"><a href="#无向图的连通" class="headerlink" title="无向图的连通"></a>无向图的连通</h4><p>在无向图中，连通关系是等价关系，所以可以用连通关系划分无向图</p><h5 id="无向图可达"><a href="#无向图可达" class="headerlink" title="无向图可达"></a>无向图可达</h5><p>可达：设<script type="math/tex">G=<V,E></script>是无向图， $v_i,v_j\in V$ ，如果两点之间存在一条路径，则称 $v_j从v_i可达$</p><h5 id="无向图连通"><a href="#无向图连通" class="headerlink" title="无向图连通"></a>无向图连通</h5><p>连通：在无向图G中，如果任两个结点可达，则称G是连通的</p><ul><li>连通分图：G的子图G’是连通的，且没有比G’更大的连通图，则G’是G的连通分图<ul><li>V上的 等价关系可达 导出的等价类构成的子图</li></ul></li></ul><h5 id="点割"><a href="#点割" class="headerlink" title="点割"></a>点割</h5><blockquote><p>一个无向简单图<script type="math/tex">G=<V,E>,V'\subset V</script>，如果</p><p>(1) $\omega(G-V’) &gt; \omega(G)$ ；删去某些结点后，分图个数大于原图中的分图个数</p><p>(2) 不存在 V’的真子集 V’’，使得 $\omega(G-V’’)&gt;\omega(G)$ ；生成分图的是最小删除结点数</p><p>，则称V’是图G的<strong>点割</strong>。</p></blockquote><p>当只删去一个点就形成分图，删除的点称为割点：当 V’={v}时，称 v 为割点</p><p>若有生成当前分图有更小的删去点集，则称为<strong>泛点割</strong></p><ul><li>泛点割中包含点割</li></ul><p><img src="/posts/284249815/image-20220303105246437.png" alt></p><h6 id="点连通度"><a href="#点连通度" class="headerlink" title="点连通度"></a>点连通度</h6><blockquote><p><script type="math/tex">G=<V,E></script>是无向简单连通图。G中含顶点数最小的点割的大小称为G的点连通度。</p></blockquote><p>点连通度 $\kappa_0(G)$ ：使连通图变为不连通图或者平凡图必须删去的顶点数</p><p>k-点连通：$\kappa_0(G) \ge k$ ，G至少删去k个点才能变为不连通图</p><ul><li>完全图$\kappa_0(G)=n-1$，平凡图 $\kappa_0(G)=0$</li></ul><p><img src="/posts/284249815/image-20220303110852805.png" alt></p><h5 id="边割集"><a href="#边割集" class="headerlink" title="边割集"></a>边割集</h5><blockquote><p>一个无向简单图<script type="math/tex">G=<V,E>,E'\subseteq E</script>，如果</p><p>(1) $\omega(G-E’) &gt; \omega(E)$ ；删去某些边后，分图个数大于原图中的分图个数</p><p>(2) 不存在 E’的真子集 E’’，使得 $\omega(G-E’’)&gt;\omega(E)$ ；生成分图的是最少删除边数</p><p>，则称E’是图G的<strong>割集</strong>。</p></blockquote><p>当只删去一条边就形成分图，删除的点称为割点：当 E’={e}时，称 e 为桥</p><p>若有生成当前分图有更小的删去边集，则称为<strong>泛割集</strong></p><ul><li>泛割集中包含割集</li></ul><h6 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h6><blockquote><p><script type="math/tex">G=<V,E></script>是无向简单连通图。G中含边数最小的割集的大小称为G的连通度。</p></blockquote><p>连通度 $\kappa_1(G)$ ：使连通图变为不连通图或者平凡图必须删去的边数</p><p>k-连通：$\kappa_0(G) \ge k$ ，G至少删去k条边才能变为不连通图</p><ul><li>平凡图 $\kappa_1(G)=0$</li></ul><p><img src="/posts/284249815/image-20220303111929602.png" alt></p><h4 id="有向图的连通"><a href="#有向图的连通" class="headerlink" title="有向图的连通"></a>有向图的连通</h4><h5 id="有向图的可达"><a href="#有向图的可达" class="headerlink" title="有向图的可达"></a>有向图的可达</h5><p>可达：设<script type="math/tex">G=<V,E></script>是有向图， $v_i,v_j\in V$ ，如果两点之间存在一条路径，则称 $v_j从v_i可达$</p><h5 id="连通分类"><a href="#连通分类" class="headerlink" title="连通分类"></a>连通分类</h5><p>强连通：任两个结点偶对中，两结点互相可达，则称G是强连通的</p><ul><li>所有顶点都在一条回路上</li></ul><p>单向连通：任两个结点偶对中，至少从一个结点到另一个结点是可达的</p><ul><li>存在一条有向路径，穿程于图的全部结点</li></ul><p>弱连通：一个有向图的底图是连通的，则G是弱连通的</p><h5 id="分图"><a href="#分图" class="headerlink" title="分图"></a>分图</h5><p>强分图：在有向图<script type="math/tex">G=<V,E></script>中，G’是G的子图，G’是强连通的，没有比G’更大的强连通图</p><p><img src="/posts/284249815/image-20220303102112319.png" alt></p><p>“在同一强分图中”,”在同一弱分图中”，是图的顶点集V上的等价关系，这个等价关系把V划分成若干个等价类，即分图</p><p><strong>强连通关系是等价关系</strong>，所以可以通过强连通关系划分为强</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>死锁的检测</p><ul><li>分配图：结点表示资源，边的始点表示占有，终点表示请求</li><li>用矩阵方法能够识别包含多于一个结点的强分图，从而检测出死锁状态</li></ul><h3 id="4-3-2-最短路径"><a href="#4-3-2-最短路径" class="headerlink" title="4.3.2 最短路径"></a>4.3.2 最短路径</h3><p>结点间的距离 $d(v_i,v_j)$ ：在图<script type="math/tex">G=<V,E></script>中，从结点 $v_1$ 到 $v_j$ 最短路径的长度</p><ul><li><p>有向图中， $d(v_i,v_j)$ 不一定等于 $d(v_j,v_i)$ ，但满足三角等式</p><p>$d(v_i,v_j)\ge 0$</p><p>$d(v_i,v_i)=0$</p><p>$d(v_i,v_j)+d(v_j,v_k) \ge d(v_i,v_k)$</p></li></ul><h4 id="带权图单源点最短路径"><a href="#带权图单源点最短路径" class="headerlink" title="带权图单源点最短路径"></a>带权图单源点最短路径</h4><p>设<script type="math/tex">G=<V,E,W></script>是个带权图，W是从E到正实数集合的函数</p><p>路径P的长度定义为路径中边的长度之和，记为W(P)</p><script type="math/tex;mode=display">d(u,v)=
\begin{cases}
min\{W(P)|P为G中从u到v的路径\}\\
\infty 当从u到v不可达
\end{cases}</script><h5 id="Dijkstra算法-贪心"><a href="#Dijkstra算法-贪心" class="headerlink" title="Dijkstra算法(贪心)"></a>Dijkstra算法(贪心)</h5><p>单源点多汇点</p><p>(1)将V分成两个子集S，有源点a的集合S与没有源点a的集合T。各结点到源点a的距离向量D(x)是他们之间的直接距离W(a,x)</p><p>(2)根据D(x)从集合T中找出与源点距离最短的结点t，以t为中转更新T中剩余结点到a点的距离向量D(x)；</p><ul><li><code>D(x)=min[D(x),D(t)+W(t,x)]</code>；原先点a到点x的距离 与 到点t的距离+t与x之间的距离 的最小值</li></ul><p>(3)将t并于S，T=T-{t}。若T=∅，则结束，反之执行(2)</p><p><img src="/posts/284249815/image-20220303115954884.png" alt></p><h5 id="Floyd-动态规划"><a href="#Floyd-动态规划" class="headerlink" title="Floyd(动态规划)"></a>Floyd(动态规划)</h5><p><strong>适用场景</strong>：无负权回路求 多源点多汇点间的最短路径</p><p><strong>原理</strong></p><ol><li><p>在一个图中，最短路径长度不会超过 n-1</p></li><li><p>任意节点i与j的最短路径只有两种可能：</p><p>(1) <code>[i,j]</code> 本身最短</p><p>(2) 从i经过若干节点到j</p><p>故其状态转移方程为 <code>path[i,j]=min&#123;path[i,k]+path[k,j],path[i,j]&#125;</code></p></li></ol><p><strong>步骤</strong></p><ol><li><p>初始状态：</p><p>矩阵A：记录各结点间的直接距离</p><p>矩阵P：A中不为无穷的点置1</p><p>路径计数器k=-1,</p><p>$A^{(k)}[i][j]$ 记录的是经过前k个顶点的最短路径</p><p>$P^{(k)}[i][j]$ 记录经过前k个顶点的最短路径长度</p></li><li><p>k++</p><p>判断在已加入前k-1个结点基础上再加上 $v_{k-1}$ 中转是否使路径变短（除去第k行和第k列和主对角线上的元素，A矩阵中其余元素计算 $min\{A^{(k-1)}[i][j],A^{(k)}[i][j]\}$）。</p><p>如果取 $A^{(k)}[i][j]$ ，则相应的令 $A^{(k)}[i][j]=A^{(k)}[i][j],P^{(k)}=P^{(k-1)}[i][j]+1$ ，</p><p>否则令 $A^{(k)}[i][j]=A^{(k-1)}[i][j],P^{(k)}=P^{(k-1)}[i][j]$</p></li><li><p>若k=n-1，停止；否则继续第二步</p></li></ol><h3 id="4-3-3-关键路径-动态规划"><a href="#4-3-3-关键路径-动态规划" class="headerlink" title="4.3.3 关键路径(动态规划)"></a>4.3.3 关键路径(动态规划)</h3><p>单源点到单汇点的最长路径</p><blockquote><p>从源点到汇点，算最长路径有多长</p><p>从汇点到源点，哪条路径是最长路径</p></blockquote><ol><li><p>输入e 条弧 ，建立AOE-网存储结构</p></li><li><p>拓扑排序，求得事件的最早开始时间，最后得到活动的最晚结束时间。从源点出发，源点的最早开始时间 <code>ve[0]=0</code> ，按拓扑有序求其余各顶点的最早开始时间 <code>ve[i]</code> 。如果得到的拓扑序列顶点数小于AOE网中的顶点数，则说明网中有环，无关键路径。</p><ul><li>拓扑排序：入度为0的点，若取出该点，删除以该点为始点的边</li><li>最早开始时间 <code>ve[i]</code> 为源点到顶点i的最长距离</li></ul></li><li><p>逆拓扑排序，求得顶点的最晚开始时间。从汇点出发，令汇点的最晚开始时间等于最早开始时间 <code>vl[n-1]=ve[n-1]</code> ，依次求得各事件的最晚开始时间 <code>vl[i]</code></p><ul><li>逆拓扑排序：出度为0的点，若取出该点，删除以该点为终点的边</li><li>最晚开始时间 <code>vl[i]</code> 为顶点i的所有出边终点的最晚开始时间减去边的权值的最小值</li></ul></li><li><p>根据个顶点的 最早开始时间<code>ve[i]</code>和最晚开始时间<code>vl[i]</code>，求每个边的最早开始时间<code>e[i]</code>和最晚开始时间<code>l[i]</code> ，满足最早开始时间=最晚开始时间的边为关键路径</p><p>活动的最早开始时间=活动始点事件的最早开始时间</p><p>活动的最晚开始时间=活动终点事件的最晚开始时间-活动时间</p></li></ol><h3 id="4-3-4-欧拉路径与欧拉回路"><a href="#4-3-4-欧拉路径与欧拉回路" class="headerlink" title="4.3.4 欧拉路径与欧拉回路"></a>4.3.4 欧拉路径与欧拉回路</h3><p>欧<strong>拉</strong>：拉——边；<strong>哈</strong>密尔顿：口多——结点○</p><p><strong>无向连通图G</strong></p><blockquote><p>欧拉路径：穿程于图G的每条 <strong>边</strong> 一次且仅一次的 <strong>路径</strong></p><p>欧拉回路：穿程于图G的每条 <strong>边</strong> 一次且仅一次的 <strong>回路</strong></p><p>欧拉图：具有欧拉回路的图</p></blockquote><h4 id="充要条件"><a href="#充要条件" class="headerlink" title="充要条件"></a>充要条件</h4><p><strong>无向连通图</strong></p><p>具有欧拉路径：当且仅当G中具有零个或两个奇数度的顶点</p><p>欧拉图：当且仅当该图的顶点次数都是偶数</p><p><strong>有向连通图</strong></p><p>具有欧拉路径：</p><ul><li>每个顶点出度等于入度</li><li>路径起点：出度-入度=1，路径终点：入度-出度=1</li></ul><p>具有欧拉回路：当且仅当每个顶点的出度等于入度</p><h3 id="4-3-5-哈密尔顿图"><a href="#4-3-5-哈密尔顿图" class="headerlink" title="4.3.5 哈密尔顿图"></a>4.3.5 哈密尔顿图</h3><blockquote><p>哈密尔顿路径：在无向图<script type="math/tex">G=<V,E></script>中穿程与G的每个<strong>结点</strong>一次且仅一次的路径</p><p>哈密尔顿回路：穿程于G的每个结点一次且仅一次的回路</p><p>哈密尔顿图：含有哈密尔顿回路的图</p></blockquote><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><p>删去的结点数大于等于删去结点后生成的分图数</p><p>设<script type="math/tex">G=<V,E></script>是哈密尔顿图，对V的每个非空真子集S，有 $\omega(G-S)\le \mid S \mid$ ，$\omega(G-S)$ 表示删去S后形成的连通分图个数</p><p><img src="/posts/284249815/image-20220303130049379.png" alt></p><h4 id="充分条件"><a href="#充分条件" class="headerlink" title="充分条件"></a>充分条件</h4><p>设<script type="math/tex">G=<V,E></script>是具有 $n\ge 3$ 个顶点的简单无向图，</p><ul><li><p>若在G中<strong>每一对</strong>顶点的度数之和大于等于n-1</p></li><li><p><strong>每一个</strong> 顶点的度数大于等于 $\frac{n}{2}$</p></li></ul><p>则在G中存在一条哈密尔顿回路</p><h2 id="4-4-二部图和平面图"><a href="#4-4-二部图和平面图" class="headerlink" title="4.4 二部图和平面图"></a>4.4 二部图和平面图</h2><h3 id="4-4-1-二部图"><a href="#4-4-1-二部图" class="headerlink" title="4.4.1 二部图"></a>4.4.1 二部图</h3><p>若无向图<script type="math/tex">G=<V,E></script>的结点集合V可以划分为两个子集 X和Y ，使G中每一条边e，其一个端点在X中，另一个端点在Y中，则称 G是二部图或偶图</p><p>记为<script type="math/tex">G=<X,E,Y></script>,X和Y称为 互补结点子集。</p><ul><li>二部图没有自回路</li></ul><p>完全二部图：若<strong>X的每一顶点都与Y的每一顶点邻接</strong>，则称G为完全二部图</p><p><img src="/posts/284249815/image-20220303161038032.png" alt></p><h4 id="充要条件-1"><a href="#充要条件-1" class="headerlink" title="充要条件"></a>充要条件</h4><p>无向图G中的所有回路长度均为偶数</p><h3 id="4-4-2-平面图"><a href="#4-4-2-平面图" class="headerlink" title="4.4.2 平面图"></a>4.4.2 平面图</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>设 $G=<v ,e>$ 是一个无向图，如果能把G的所有结点和边画在一个平面上，且使得<strong>任何两条边除了端点外没有其他交点</strong>，则G是一个平面图</v></p><p><img src="/posts/284249815/image-20220303170315265.png" alt></p><p>面：设G施一个连通平面图，由图中的边所包围的区域，在<strong>区域内既不包含图的结点，也不包含图的边</strong>，这样的区域为图的一个面</p><p>边界：包围面的边构成的回路</p><p>面的次数：面的边界回路的长度，记为deg(r)</p><p><img src="/posts/284249815/image-20220303170542382.png" alt></p><p>一个有限平面图，面的次数之和边数的两倍</p><h4 id="充要条件-2"><a href="#充要条件-2" class="headerlink" title="充要条件"></a>充要条件</h4><p>欧拉公式：一个连通的平面图G，共有n个结点，m条边和k个面，则欧拉公式 n-m+k=2成立</p><p>顶点数-边数+面数=2</p><p>推论：</p><ul><li><p>一个连通简单平面图，共n个结点，m条边，若 $n\ge 3$，则 $m\le 3n-6$</p></li><li><p>一个连通简单平面图，共n个结点，m条边，若每个平面至少四条边组成，则 $m\le 2n-4$</p></li><li>一个连通简单平面图，共n个结点，m条边，若每个平面至少s($s\ge 3$)条边组成，则 $m\le \frac{s(n-2)}{s-2}$</li></ul><h4 id="库拉托夫斯基定理"><a href="#库拉托夫斯基定理" class="headerlink" title="库拉托夫斯基定理"></a>库拉托夫斯基定理</h4><p>在给定图G的边上，</p><p>插入一个新的度为2的结点，使一条边分成两条边</p><p>关联于一个度为2的结点的两条边，去掉这个结点，使两条边化为一条边</p><p>不会影响图的平面性</p><h4 id="对偶图"><a href="#对偶图" class="headerlink" title="对偶图"></a>对偶图</h4><p>给定平面图<script type="math/tex">G=<V,E></script>，将其嵌入平面后：</p><ul><li>在图G的每一个面 $D_i$ 内部作一个且仅做一个结点 $v_i^*$</li><li>经过每两个面 $D_i$ 与 $D_j$ 的每一边界 $e_k$ 做一条边 $e_k^<em>$ ，使 $e_k^</em>=(v_i^<em>,v_j^</em>)$ 与 $e_k$ 相交</li><li>当且仅当 $e_k$ 只是一个面 $D_i$ 的边界时，$v_i^<em>$ 恰好存在一个自回路 $e_k</em>$ 与 $e_k$ 相交</li></ul><p>则称G*是G的一个对偶图</p><p><img src="/posts/284249815/image-20220303192527280.png" alt></p><h2 id="4-5-无向树"><a href="#4-5-无向树" class="headerlink" title="4.5 无向树"></a>4.5 无向树</h2><blockquote><p>连通且无简单回路的无向图称为无向树</p><p>树中次数为1的结点称为树叶，次数大于1的结点称为分支点或内部结点</p><ul><li><p>任何一棵树至少有两片树叶($n\ge 2$)</p><p>一个无向图的各连通分图大都是树时，该无向图称为森林</p></li></ul></blockquote><h3 id="4-5-1-树的等价定义"><a href="#4-5-1-树的等价定义" class="headerlink" title="4.5.1 树的等价定义"></a>4.5.1 树的等价定义</h3><ul><li>无简单回路的连通图</li><li>无简单回路，且边数=结点数-1</li><li>连通且边数=结点数-1</li><li>无简单回路，但增加一条新边得到且仅得到一条基本回路</li><li>连通，但删去一条边后不连通</li><li>每一对结点之间有且仅有一条基本路径</li></ul><h3 id="4-5-2-生成树"><a href="#4-5-2-生成树" class="headerlink" title="4.5.2 生成树"></a>4.5.2 生成树</h3><h4 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h4><blockquote><p>在无向图G的一个生成子图T是一棵树，则T为G的生成树或支撑树</p></blockquote><p>生成树T中的边称为树枝，图G中不在生成树中的边称为弦，所有的弦的集合称为生成树T的补</p><ul><li><p>任何连通无向图至少有一棵生成树</p></li><li><p>无向连通图G有n个结点，m条边，G的生成树有 n-1条边。则要删除m-n+1条边。</p><p>连通图G的秩：m-n+1</p></li><li><p>一个连通图可以生成许多树。确定一个回路后，可删除回路中不同的边，进而生成不同的树</p></li><li><p>一条简单回路和任何一棵生成树的补至少有一条公共边</p><p>简单回路至少去掉一条边后才不构成回路</p></li><li><p>一个割集和任何生成树至少有一条公共边</p></li></ul><h4 id="基本割集"><a href="#基本割集" class="headerlink" title="基本割集"></a>基本割集</h4><p>生成树T中删去一条枝，将顶点集划分为两个子集（生成两个分图）。从G变为当前分图的边割集称为该枝对应的基本割集</p><p><img src="/posts/284249815/image-20220303205417387.png" alt></p><h3 id="4-5-3-最小生成树"><a href="#4-5-3-最小生成树" class="headerlink" title="4.5.3 最小生成树"></a>4.5.3 最小生成树</h3><p>设<script type="math/tex">G=<V,E,W></script>是连通简单无向带权图。</p><p>W(T)：T的生成树的树权</p><blockquote><p>最小生成树：在G的所有生成树中，树权最小的生成树称为最小生成树</p></blockquote><h4 id="Kruskal-选边"><a href="#Kruskal-选边" class="headerlink" title="Kruskal(选边)"></a>Kruskal(选边)</h4><p>图中有n个结点</p><p>(1) 将边集划分为两个集合，T和E-T，边计数器 i=0</p><p>(2) 选择E-T中边权最小的边 $e_k$ ，若加入 $e_k$ 后不会使T形成回路，则选择 $e_k$ 放入T，$E-T-\{e_k\}$ ，i++;</p><p>(3) 若 i &lt; n-1，则执行(2)；T即为最小生成树</p><h4 id="Prime-选点"><a href="#Prime-选点" class="headerlink" title="Prime(选点)"></a>Prime(选点)</h4><p>图中有n个结点</p><p>(1) 将结点集分为两个集合，T 和 V-T，并选定一个点加入S，点计数器i=1</p><p>(2) 在边集E中，找一条最小代价边，他的一个端点在T，另一个端在V-T中。</p><p>将该边不在T集的端点加入T集，V-T-{p}，i++</p><p>(3) 若i &lt; n，执行第二步。</p><h2 id="4-6-有向树"><a href="#4-6-有向树" class="headerlink" title="4.6 有向树"></a>4.6 有向树</h2><blockquote><p>有向树定义：</p><p>有且仅有一个结点叫树根</p><p>除树根外，每一结点的入度都是1</p><p>树的每一个结点a,都有从树根到a的一条有向路径</p></blockquote><h3 id="4-6-1-相关概念"><a href="#4-6-1-相关概念" class="headerlink" title="4.6.1 相关概念"></a>4.6.1 相关概念</h3><p><img src="/posts/284249815/image-20220303212424594.png" alt></p><p><img src="/posts/284249815/image-20220303212835377.png" alt></p><p>有序树：树中每一结点引出的边都规定次序的树，称为有序树</p><p>位置树：如果树中的每一结点的儿子不仅给出次序，还明确他们的位置，称为位置树。二叉树是位置树</p><p>有向森林：每个连通分图是有向树</p><p>有序森林：所有树都是有序树，且给树指定了次序</p><h3 id="4-6-2-性质"><a href="#4-6-2-性质" class="headerlink" title="4.6.2 性质"></a>4.6.2 性质</h3><ul><li><p>设T是一棵有向树，根是r，并设a是T的任一结点，则从r到a有唯一的有向路径</p></li><li><p>有向树中的每一有向路径是基本路径</p></li><li><p>有向树没有非零长度的任何回路</p></li><li><p>有向树中，结点树=边数+1</p></li><li><p>有向树的子树是有向树</p></li><li><p>完全n元树，树叶与分支结点数的关系</p><p><img src="/posts/284249815/image-20220303213222324.png" alt></p></li></ul><h3 id="4-6-3-带权二元树"><a href="#4-6-3-带权二元树" class="headerlink" title="4.6.3 带权二元树"></a>4.6.3 带权二元树</h3><blockquote><p>给定一组权 $w_1,w_2,…,w_t$ ，设有一颗完全二元树有t片叶子，每个叶子上带有一个权值，则称该二元树为带权二元树、</p></blockquote><p>带权路径长度：带权二元树中，带权为 $w_i$ 的树叶，其通路长度为 $L(w_i)$ ，将 $W(T)=\sum_{i=1}^{t} w_i·L(w_i)$ ，称为带权二元树的权。</p><p>在所有带权的二元树中，带权路径长度最小的那棵树称为<strong>最优树</strong></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>设T为带权 $w_1≤ w_2≤ … ≤ w_t$ 的最优树， 则</p><ul><li>带权 $w_1,w_2$ 的树叶 $v_{w_1},v_{w_2}$ 是兄弟；</li><li>以树叶 $v_{w_1},v_{w_2}$ 为儿子的分枝点，是通路长度最长（ 层次最大） 的分枝点</li></ul><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>给定一个序列集合，若没有一个序列是另一个序列的前缀，则将该序列集合称为前缀码</p><p>任何一棵二元树的树叶可对应一个前缀码</p><p>任何一个前缀码都对应一棵二元树</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/284249815/" title="4.图论">https://amostian.github.io/posts/284249815/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"><i class="fa fa-tags"></i> 数学</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" rel="tag"><i class="fa fa-tags"></i> 离散数学</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/3927125353/" rel="prev" title="2.集合论"><i class="fa fa-chevron-left"></i> 2.集合论</a></div><div class="post-nav-item"><a href="/posts/2011867706/" rel="next" title="1.网络概述">1.网络概述 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%9B%BE%E8%AE%BA"><span class="nav-text">4. 图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">4.1 图的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-%E5%9B%BE"><span class="nav-text">4.1.1 图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">4.1.2 图的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E8%BE%B9%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-text">按边类型分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E9%97%B4%E7%9A%84%E8%BE%B9%E6%95%B0"><span class="nav-text">结点间的边数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%9B%BE"><span class="nav-text">特殊的图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="nav-text">4.1.3 邻接关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BA%95%E5%9B%BE"><span class="nav-text">4.1.4 有向图的底图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-5-%E7%BB%93%E7%82%B9%E7%9A%84%E6%AC%A1%E6%95%B0-%E5%BA%A6"><span class="nav-text">4.1.5 结点的次数(度)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E7%90%86"><span class="nav-text">定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-6-%E5%9B%BE%E9%97%B4%E7%9A%84%E5%90%8C%E6%9E%84%E5%85%B3%E7%B3%BB"><span class="nav-text">4.1.6 图间的同构关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-7-%E5%9B%BE%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-text">4.1.7 图的运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-8-%E5%AD%90%E5%9B%BE"><span class="nav-text">4.1.8 子图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E5%9B%BE"><span class="nav-text">子图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-9-%E5%AE%8C%E5%85%A8%E5%9B%BE%E4%B8%8E%E8%A1%A5%E5%9B%BE"><span class="nav-text">4.1.9 完全图与补图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%9B%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA"><span class="nav-text">4.2 图的矩阵表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E6%80%A7%E8%B4%A8"><span class="nav-text">4.2.1 性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">4.2.2 矩阵运算的意义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AA-T"><span class="nav-text">$AA^T$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-TA"><span class="nav-text">$A^TA$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-n"><span class="nav-text">$A^{(n)}$</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E5%8F%AF%E8%BE%BE%E7%9F%A9%E9%98%B5"><span class="nav-text">4.3.3 可达矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B1%E5%8F%AF%E8%BE%BE%E7%9F%A9%E9%98%B5%E6%B1%82%E5%BC%BA%E5%88%86%E5%9B%BE"><span class="nav-text">由可达矩阵求强分图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%9B%9E%E8%B7%AF"><span class="nav-text">4.3 路径与回路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E8%BF%9E%E9%80%9A%E5%BA%A6%E4%B8%8E%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="nav-text">4.3.1 连通度与连通图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A"><span class="nav-text">无向图的连通</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%AF%E8%BE%BE"><span class="nav-text">无向图可达</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A"><span class="nav-text">无向图连通</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%82%B9%E5%89%B2"><span class="nav-text">点割</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%82%B9%E8%BF%9E%E9%80%9A%E5%BA%A6"><span class="nav-text">点连通度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%B9%E5%89%B2%E9%9B%86"><span class="nav-text">边割集</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%BA%A6"><span class="nav-text">连通度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A"><span class="nav-text">有向图的连通</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%AF%E8%BE%BE"><span class="nav-text">有向图的可达</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E7%B1%BB"><span class="nav-text">连通分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%9B%BE"><span class="nav-text">分图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-text">应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">4.3.2 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E5%9B%BE%E5%8D%95%E6%BA%90%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">带权图单源点最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83"><span class="nav-text">Dijkstra算法(贪心)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Floyd-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">Floyd(动态规划)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">4.3.3 关键路径(动态规划)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="nav-text">4.3.4 欧拉路径与欧拉回路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">充要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-5-%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E5%9B%BE"><span class="nav-text">4.3.5 哈密尔顿图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6"><span class="nav-text">充分条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E4%BA%8C%E9%83%A8%E5%9B%BE%E5%92%8C%E5%B9%B3%E9%9D%A2%E5%9B%BE"><span class="nav-text">4.4 二部图和平面图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E4%BA%8C%E9%83%A8%E5%9B%BE"><span class="nav-text">4.4.1 二部图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6-1"><span class="nav-text">充要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-%E5%B9%B3%E9%9D%A2%E5%9B%BE"><span class="nav-text">4.4.2 平面图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">相关概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6-2"><span class="nav-text">充要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%93%E6%8B%89%E6%89%98%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%AE%9A%E7%90%86"><span class="nav-text">库拉托夫斯基定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E5%81%B6%E5%9B%BE"><span class="nav-text">对偶图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E6%97%A0%E5%90%91%E6%A0%91"><span class="nav-text">4.5 无向树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-%E6%A0%91%E7%9A%84%E7%AD%89%E4%BB%B7%E5%AE%9A%E4%B9%89"><span class="nav-text">4.5.1 树的等价定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">4.5.2 生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-1"><span class="nav-text">相关概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%89%B2%E9%9B%86"><span class="nav-text">基本割集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">4.5.3 最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal-%E9%80%89%E8%BE%B9"><span class="nav-text">Kruskal(选边)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prime-%E9%80%89%E7%82%B9"><span class="nav-text">Prime(选点)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E6%9C%89%E5%90%91%E6%A0%91"><span class="nav-text">4.6 有向树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">4.6.1 相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-%E6%80%A7%E8%B4%A8"><span class="nav-text">4.6.2 性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-3-%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%85%83%E6%A0%91"><span class="nav-text">4.6.3 带权二元树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-text">性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">哈夫曼编码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">353</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">74</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">760.6k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">31:50</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>