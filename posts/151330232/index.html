<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="I&#x2F;O设备   对I&#x2F;O设备的控制方式   I&#x2F;O管理"><meta property="og:type" content="article"><meta property="og:title" content="5.IO管理"><meta property="og:url" content="https://amostian.github.io/posts/151330232/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="I&#x2F;O设备   对I&#x2F;O设备的控制方式   I&#x2F;O管理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313105337893.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313110258751.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313110633406.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313205904220.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312152816363.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312155337135.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312180101597.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312192022285.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312182218626.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312185248715.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312185515567.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220312193851250-16613053979362.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313080637736.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313083029098.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313083126414.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313090459716.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313090138811.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313085742474.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313090539547.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313090629499.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313100326723.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313100518006.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313102629870.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313102955712.png"><meta property="og:image" content="https://amostian.github.io/posts/151330232/image-20220313103123818.png"><meta property="article:published_time" content="2024-01-26T10:50:58.147Z"><meta property="article:modified_time" content="2022-03-13T15:18:04.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="计算机基础"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/151330232/image-20220313105337893.png"><link rel="canonical" href="https://amostian.github.io/posts/151330232/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>5.IO管理 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">65</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">82</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">216</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/151330232/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">5.IO管理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-01-26 18:50:58" itemprop="dateCreated datePublished" datetime="2024-01-26T18:50:58+08:00">2024-01-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2022-03-13 23:18:04" itemprop="dateModified" datetime="2022-03-13T23:18:04+08:00">2022-03-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">4.6k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>I/O设备</p><p>对I/O设备的控制方式</p><p>I/O管理</p></blockquote><span id="more"></span><h1 id="5-I-O设备与管理"><a href="#5-I-O设备与管理" class="headerlink" title="5. I/O设备与管理"></a>5. I/O设备与管理</h1><h2 id="5-1-I-O设备"><a href="#5-1-I-O设备" class="headerlink" title="5.1 I/O设备"></a>5.1 I/O设备</h2><blockquote><p>将数据输入/输出的计算机外部设备</p></blockquote><h3 id="5-1-1-分类"><a href="#5-1-1-分类" class="headerlink" title="5.1.1 分类"></a>5.1.1 分类</h3><p><img src="/posts/151330232/image-20220313105337893.png" alt="image-20220313105337893"></p><h3 id="5-1-2-I-O设备的组成"><a href="#5-1-2-I-O设备的组成" class="headerlink" title="5.1.2 I/O设备的组成"></a>5.1.2 I/O设备的组成</h3><blockquote><p>机械部件+电子部件<code>I/O控制器(设备控制器)</code></p></blockquote><h4 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h4><p>CPU无法直接控制设备的机械不见，需要电子部件作为中介</p><h5 id="a-功能"><a href="#a-功能" class="headerlink" title="a. 功能"></a>a. 功能</h5><ul><li><p>接受和识别CPU发出的命令</p><p>I/O控制器中的控制寄存器，存放命令与参数</p></li><li><p>向CPU报告设备状态</p><p>I/O控制器中的状态寄存器：记录I/O设备的当前状态</p></li><li><p>数据交互</p><p>I/O控制器中会设置相应的数据寄存器：</p><p>输出时，数据寄存器用于暂存CPU发来的数据；之后控制器传送给设备</p><p>输入时，暂存设备发来的数据。之后CPU从数据寄存器中取走数据</p></li><li><p>地址识别</p><p>类似于内存地址，为了区分设备控制器中的寄存器，需要给每个寄存器设置地址</p></li></ul><h5 id="b-组成"><a href="#b-组成" class="headerlink" title="b. 组成"></a>b. 组成</h5><p><img src="/posts/151330232/image-20220313110258751.png" alt></p><ul><li>一个I/O控制器可能对应多个设备</li></ul><h5 id="c-I-O控制器端口的编址方式"><a href="#c-I-O控制器端口的编址方式" class="headerlink" title="c. I/O控制器端口的编址方式"></a>c. I/O控制器端口的编址方式</h5><ul><li>内存影映像I/O：寄存器地址占用内存地址的一部分</li><li>寄存器独立编址：I/O专用地址</li></ul><p><img src="/posts/151330232/image-20220313110633406.png" alt></p><h2 id="5-2-I-O控制方式"><a href="#5-2-I-O控制方式" class="headerlink" title="5.2 I/O控制方式"></a>5.2 I/O控制方式</h2><h3 id="5-2-1-程序查询方式"><a href="#5-2-1-程序查询方式" class="headerlink" title="5.2.1 程序查询方式"></a>5.2.1 程序查询方式</h3><blockquote><p>CPU不断查询IO控制器中的 <em>状态寄存器</em> ，在等待IO完成的过程中CPU需要不断轮询检查</p></blockquote><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>以读操作为例</p><ol><li>CPU向设备控制器发出读指令，设备启动，修改状态寄存器的值为1，表示从设备读入数据</li><li>轮询检查控制寄存器的状态，若状态位为1，说明设备还没有准备好要输入的数据，于是CPU会不断轮询</li><li>输入设备准备好数据后，将数据传给设备控制器，并报告自身状态</li><li>控制器将输入的数据放到数据寄存器中，并将状态位改为0</li><li>CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU寄存器中，再把寄存器中的内容放入内存</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>数据传送单位：一个字</p><p>数据流向：</p><ul><li>读操作：I/O设备—&gt;I/O设备控制器中的寄存器—&gt;数据总线—&gt;CPU寄存器—&gt;内存</li><li>写操作：内存—&gt;CPU寄存器—&gt;数据总线—&gt;I/O设备控制器中的寄存器—&gt;I/O设备</li></ul><p>优点：实现简单</p><p>缺点：CPU和IO设备只能串行工作，长期处于忙等状态，CPU利用率低</p><h3 id="5-2-2-中断方式"><a href="#5-2-2-中断方式" class="headerlink" title="5.2.2 中断方式"></a>5.2.2 中断方式</h3><blockquote><p>在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。当I/O完成后，设备控制器向CPU发出一个中断信号，CPU检测到中断信号，保存当前进程的运行环境，转去执行中断处理程序处理该中断。</p><ul><li><p>处理中断的过程：CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。</p><p>中断处理完成后，CPU恢复等待I/O的进程的运行环境，继续执行</p></li></ul></blockquote><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>每次读/写一个字</p><p>中断的响应是在每个指令周期的末尾</p><p>数据流向：</p><ul><li>读操作：I/O设备—&gt;CPU—&gt;内存</li><li>写操作：内存—&gt;CPU—&gt;I/O设备</li></ul><p>优点</p><ul><li>CPU与I/O设备可并行工作</li></ul><p>缺点</p><ul><li>每个字在I/O设备与内存之间的传输，都需要经过CPU。频繁的中断处理会消耗较多的CPU时间</li></ul><h3 id="5-2-3-DMA方式"><a href="#5-2-3-DMA方式" class="headerlink" title="5.2.3 DMA方式"></a>5.2.3 DMA方式</h3><blockquote><p>直接存储器存取，用于块设备的I/O控制</p></blockquote><h4 id="DMA特点"><a href="#DMA特点" class="headerlink" title="DMA特点"></a>DMA特点</h4><ul><li><p>基本传送单位是块</p></li><li><p>数据流向</p><p>读操作：I/O设备-&gt;内存</p><p>写操作：内存-&gt;I/O设备</p></li><li><p>所传送的数据是从设备直接送入内存，数据通路中不经过CPU</p></li><li><p>仅在传送一个或多个数据块的开始或结束时，才需要CPU干预，整块数据的传送实在DMA控制器的控制下完成的</p></li></ul><h4 id="DMA控制器组成"><a href="#DMA控制器组成" class="headerlink" title="DMA控制器组成"></a>DMA控制器组成</h4><p><img src="/posts/151330232/image-20220313205904220.png" alt></p><ul><li>DR（数据寄存器）：暂存从设备到内存，或者从内存到设备的数据</li><li>MAR（内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放到内存中的什么位置</li><li>DC（数据计数器）：表示剩余要读/写的字节数</li><li>CR（命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息</li></ul><h4 id="DMA过程"><a href="#DMA过程" class="headerlink" title="DMA过程"></a>DMA过程</h4><p>CPU接收到I/O设备的DMA请求时，会给I/O控制器发出一条命令，启动DMA控制器，然后继续做其它工作</p><p>DMA控制器直接与存储器交互，传送整个数据块到DR。当数据传送完成后，DMA控制器发送一个中断信号给CPU，将DR中的数据转存到MAR指出的内存空间或者</p><h4 id="与中断方式对比"><a href="#与中断方式对比" class="headerlink" title="与中断方式对比"></a>与中断方式对比</h4><p>中断驱动方式在每个数据需要传输时，中断CPU。DMA方式则是在要求传送的一批数据全部传送结束才中断CPU；</p><p>中断驱动方式的数据传送是在中断处理时由CPU控制完成；DMA控制方式则是在DMA控制器的控制下完成</p><h4 id="不适用于离散的数据块"><a href="#不适用于离散的数据块" class="headerlink" title="不适用于离散的数据块"></a>不适用于离散的数据块</h4><blockquote><p>若要读/写多个离散存储的数据块，或将数据分别写到不同的内存区域，CPU需要发出多条I/O指令，需要多次中断处理才能完成</p></blockquote><h3 id="5-2-4-通道控制方式"><a href="#5-2-4-通道控制方式" class="headerlink" title="5.2.4 通道控制方式"></a>5.2.4 通道控制方式</h3><p>通道指专门负责输入输出的处理机</p><h4 id="通道控制方式过程"><a href="#通道控制方式过程" class="headerlink" title="通道控制方式过程"></a>通道控制方式过程</h4><ol><li>CPU向通道发出I/O指令，指明通道程序在内存中的位置，并指明要操作那个I/O设备，之后切换到其他进程</li><li>通道执行内存中的通道程序（指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息）</li><li>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断处理</li></ol><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预</p><p>每次读/写以一组数据块</p><p>优点：CPU、通道、I/O设备可并行工作，资源利用率很高</p><h2 id="5-3-I-O管理"><a href="#5-3-I-O管理" class="headerlink" title="5.3 I/O管理"></a>5.3 I/O管理</h2><h3 id="5-3-1-功能"><a href="#5-3-1-功能" class="headerlink" title="5.3.1 功能"></a>5.3.1 功能</h3><ul><li>状态跟踪：实时掌握外设状态信息</li><li>设备存取：实现对设备的存取操作</li><li>设备分配：设备的分配与回收</li><li>设备控制：设备的驱动，完成故障的中断处理</li></ul><h3 id="5-3-2-IO系统层次结构"><a href="#5-3-2-IO系统层次结构" class="headerlink" title="5.3.2 IO系统层次结构"></a>5.3.2 IO系统层次结构</h3><p><img src="/posts/151330232/image-20220312152816363.png" alt></p><h3 id="5-3-1-用户层软件"><a href="#5-3-1-用户层软件" class="headerlink" title="5.3.1 用户层软件"></a>5.3.1 用户层软件</h3><p>实现与用户的接口：将用户请求翻译成格式化IO请求，通过 <code>系统调用</code> 请求内核服务</p><p>向上层提供库函数</p><h4 id="A-SPOOLing技术-假脱机"><a href="#A-SPOOLing技术-假脱机" class="headerlink" title="A. SPOOLing技术(假脱机)"></a>A. SPOOLing技术(假脱机)</h4><blockquote><p>将一台物理设备逻辑上虚拟成多台设备，可将独占式设备改造成共享设备</p></blockquote><h5 id="a-脱机技术"><a href="#a-脱机技术" class="headerlink" title="a. 脱机技术"></a>a. 脱机技术</h5><p>批处理阶段引入了 <strong>脱机输入/输出技术</strong></p><ul><li>缓解了CPU与I/O设备的速度矛盾</li><li>即使CPU在忙碌，也可以提前将数据输入到磁带(辅存)中，之后主机可以从相对快速的辅存上读入数据，缓解了速度矛盾</li></ul><h5 id="b-假脱机技术"><a href="#b-假脱机技术" class="headerlink" title="b. 假脱机技术"></a>b. 假脱机技术</h5><blockquote><p>用软件的方式模拟脱机技术，从磁盘I/O的速度远比向I/O外设的速度快</p></blockquote><p><img src="/posts/151330232/image-20220312155337135.png" alt></p><p>井：在磁盘上开辟两个存储区域，用于I/O设备数据的输入与输出</p><ul><li><p>输入井：模拟脱机输入时的 <em>辅存</em> ，用于收容I/O设备输入的数据</p></li><li><p>输出井：模拟脱机输出时的 <em>辅存</em> ，用于收容用户进程输出的数据</p></li></ul><p>实现SPOOLing技术，必须有 <strong>多道程序设计的支持</strong></p><ul><li><p>输入进程：模拟脱机输入中的 <em>外围控制机</em></p></li><li><p>输出进程：模拟脱机输出时的 <em>外围控制机</em></p></li></ul><p>输入缓冲区：在输入进程的控制下，暂存从设备中输入的数据，之后转存到 <em>输入井</em> 中</p><p>输出缓冲区：在输出进程的控制下，暂存从 <em>输出井</em> 中送来的数据，之后传送到 <em>输出设备</em> 上</p><h5 id="c-共享打印机"><a href="#c-共享打印机" class="headerlink" title="c. 共享打印机"></a>c. 共享打印机</h5><p>当多个用户进程提出输出打印的请求时，系统会答应请求，但并不是真正把分配打印机，由脱机管理进程为每个进程做两件事</p><ol><li>在磁盘 <em>输出井</em> 中为进程申请一个空闲缓冲区（相当于分配一个逻辑设备），并将要打印的数据放入其中</li><li>为用户进程申请一张空白的 <em>打印请求表</em> ，并将用户的打印请求填入表中（就是说明用户的打印数据存放位置），将该表挂在 <em>假脱机文件队列上</em></li><li>当打印机空闲时，输出进程会从文件队列的队头取出一张 <em>打印请求表</em> ，并根据表中的要求，将数据从 <em>输出井</em> 传送到 <em>输出缓冲区</em> ，再输出到打印机进行打印</li></ol><h3 id="5-3-2-设备独立性软件"><a href="#5-3-2-设备独立性软件" class="headerlink" title="5.3.2 设备独立性软件"></a>5.3.2 设备独立性软件</h3><blockquote><p>用户程序与设备驱动器的统一接口</p></blockquote><h4 id="A-功能"><a href="#A-功能" class="headerlink" title="A. 功能"></a>A. 功能</h4><ul><li>向上层提供系统调用</li><li>建立逻辑设备名到物理设备名的映射</li><li>根据设备类型选择相应的设备驱动程序</li><li>设备保护</li><li>设备的分配与回收</li><li>缓冲区管理</li></ul><h4 id="B-逻辑设备表"><a href="#B-逻辑设备表" class="headerlink" title="B. 逻辑设备表"></a>B. 逻辑设备表</h4><blockquote><p>为每个用户创建一张逻辑设备表，多用户可重名</p></blockquote><ul><li>确定逻辑设备对应的物理设备</li><li>找到物理设备对应的设备驱动程序</li></ul><p>如：</p><div class="table-container"><table><thead><tr><th>逻辑设备名</th><th>物理设备名</th><th>驱动程序入口地址</th></tr></thead><tbody><tr><td>/dev/打印机1</td><td>3</td><td>1024</td></tr><tr><td>/dev/打印机2</td><td>5</td><td>2046</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><ul><li>I/O设备被当做一种特殊文件</li><li>不同类型I/O设备要有不同的驱动程序处理</li></ul><h4 id="C-设备保护"><a href="#C-设备保护" class="headerlink" title="C. 设备保护"></a>C. 设备保护</h4><blockquote><p>设备被看做特殊文件，不同用户对设备访问权限不同</p></blockquote><ul><li>每个设备都有FCB</li><li>用户请求访问某个设备时，系统根据FCB中的信息判断访问权限</li></ul><h4 id="D-设备的分配与回收"><a href="#D-设备的分配与回收" class="headerlink" title="D. 设备的分配与回收"></a>D. 设备的分配与回收</h4><h5 id="a-总原则"><a href="#a-总原则" class="headerlink" title="a. 总原则"></a>a. 总原则</h5><ul><li>充分发挥设备的使用效率</li><li>避免不合理分配方式造成的进程死锁</li></ul><h5 id="b-考虑因素"><a href="#b-考虑因素" class="headerlink" title="b. 考虑因素"></a>b. 考虑因素</h5><h6 id="设备固有属性"><a href="#设备固有属性" class="headerlink" title="设备固有属性"></a>设备固有属性</h6><p>独占设备</p><p>共享设备</p><ul><li>可分配给多个进程(磁盘)</li><li>宏观上共享，微观上交替使用</li></ul><p>虚拟设备</p><ul><li>采用SPOOLing技术将独占式设备改为共享设备</li><li>同时分配给多个进程使用</li></ul><h6 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h6><h6 id="设备分配的安全性"><a href="#设备分配的安全性" class="headerlink" title="设备分配的安全性"></a>设备分配的安全性</h6><p><strong>安全分配方式</strong></p><blockquote><p>为一个进程分配一个设备后将进入阻塞状态，本次I/O完成后将进程唤醒</p></blockquote><p>优点：破坏了 “请求并保持” ，不会造成死锁</p><p>缺点：对一个进程来说，CPU和IO只能串行工作</p><p><strong>不安全分配</strong></p><blockquote><p>为一个进程分配设备后，进程继续执行，可以发出IO请求；IO不满足时，才阻塞</p></blockquote><p>优点：效率高；计算任务和IO任务并行处理</p><p>缺点：有可能发生死锁</p><h5 id="c-分配策略"><a href="#c-分配策略" class="headerlink" title="c. 分配策略"></a>c. 分配策略</h5><p>静态分配：进程运行前全部分配，结束后全部归还</p><p>动态分配</p><h5 id="d-设备分配管理中的数据结构"><a href="#d-设备分配管理中的数据结构" class="headerlink" title="d. 设备分配管理中的数据结构"></a>d. 设备分配管理中的数据结构</h5><blockquote><p>一个通道可控制多个设备控制器，一个设备控制器可控制多个设备</p></blockquote><p><img src="/posts/151330232/image-20220312180101597.png" alt></p><h6 id="系统设备表-SDT"><a href="#系统设备表-SDT" class="headerlink" title="系统设备表(SDT)"></a>系统设备表(SDT)</h6><p>记录系统中全部设备的情况</p><p><img src="/posts/151330232/image-20220312192022285.png" alt></p><h6 id="设备控制表-DCT"><a href="#设备控制表-DCT" class="headerlink" title="设备控制表(DCT)"></a>设备控制表(DCT)</h6><p>每个设备一张设备控制表</p><p><img src="/posts/151330232/image-20220312182218626.png" alt></p><h6 id="控制器控制表-COCT"><a href="#控制器控制表-COCT" class="headerlink" title="控制器控制表(COCT)"></a>控制器控制表(COCT)</h6><p>每个设备控制器一张控制器控制表</p><p><img src="/posts/151330232/image-20220312185248715.png" alt></p><h6 id="通道控制表（CHCT）"><a href="#通道控制表（CHCT）" class="headerlink" title="通道控制表（CHCT）"></a>通道控制表（CHCT）</h6><p>每个通道一张通道控制表</p><p>OS根据通道控制表对通道进行操作</p><p><img src="/posts/151330232/image-20220312185515567.png" alt></p><h5 id="e-设备分配步骤"><a href="#e-设备分配步骤" class="headerlink" title="e. 设备分配步骤"></a>e. 设备分配步骤</h5><blockquote><p>设备及其控制器及通道都分配成功才算成功</p></blockquote><ol><li>根据进程请求的 <em>物理设备名</em> 查找SDT（物理设备名是进程请求分配时提供的参数）</li><li>根据SDT查找DCT，若 <em>设备</em> 忙碌则将进程PCB挂到 <em>设备等待队列</em> 中，不忙，则将设备分配给进程</li><li>根据DCT找到COCT，若 <em>设备控制器</em> 忙则将进程PCB挂到 <em>控制器等待队列</em> 中，不忙，则将 <em>控制器</em> 分配给进程</li><li>根据COCT查找CHCT，若 <em>通道</em> 忙碌则将进程PCB挂到 <em>通道等待队列</em> 中，不忙，则将通道分配给进程</li></ol><p>缺点：</p><ul><li>用户编程必须使用 <code>物理设备名</code> ，底层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，则程序无法运行</li><li>若进程请求的物理设备正在忙碌，即使系统中还有同类型的设备，进程也必须阻塞等待</li></ul><h5 id="f-设备分配改进方法"><a href="#f-设备分配改进方法" class="headerlink" title="f. 设备分配改进方法"></a>f. 设备分配改进方法</h5><blockquote><p>建立 <em>逻辑设备名与物理设备名</em> 的映射机制，用户编程使用的逻辑设备名（设备类型）</p></blockquote><h6 id="逻辑设备表-LUT"><a href="#逻辑设备表-LUT" class="headerlink" title="逻辑设备表(LUT)"></a>逻辑设备表(LUT)</h6><p><img src="/posts/151330232/image-20220312193851250-16613053979362.png" alt></p><h6 id="分配步骤"><a href="#分配步骤" class="headerlink" title="分配步骤"></a>分配步骤</h6><ol><li>根据进程请求的 <em>逻辑设备名</em> 查找SDT</li><li>查找SDT，找到用户进程 <em>指定的类型、且空闲</em> 的设备，将其分配给该进程。</li><li>操作系统在逻辑设备表中新增一个表项</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配各进程</li></ol><h4 id="E-缓冲区管理"><a href="#E-缓冲区管理" class="headerlink" title="E. 缓冲区管理"></a>E. 缓冲区管理</h4><blockquote><p>将内存作为缓冲区，屏蔽设备间数据交互的 单位大小和传输速度 的差异</p><p><em>设备独立性</em> 的缓冲区管理就是组织管理好这些缓冲区</p></blockquote><p>磁盘高速缓存：逻辑上属于磁盘，物理上是主流在内存中的盘块</p><ul><li>缓冲区数据非空，不能向缓冲区冲入数据，只能从缓冲区取出数据</li><li>缓冲区为空，只能往缓冲区冲入数据，但只能充满才能从缓冲区取出数据</li></ul><h5 id="a-缓冲区作用"><a href="#a-缓冲区作用" class="headerlink" title="a. 缓冲区作用"></a>a. 缓冲区作用</h5><ul><li>缓和CPU和IO设备之间速度不匹配的问题</li><li>减少CPU的中断频率，放宽对CPU中断处理时间的限制</li><li>解决数据粒度不匹配问题</li><li>提高CPU和IO设备间的并行性</li></ul><h5 id="b-引入缓冲区的工作策略"><a href="#b-引入缓冲区的工作策略" class="headerlink" title="b. 引入缓冲区的工作策略"></a>b. 引入缓冲区的工作策略</h5><p><img src="/posts/151330232/image-20220313080637736.png" alt></p><p>输出时</p><ol><li>CPU把要输出的数据快速地放到缓冲区中，之后可以做别的事情</li><li>慢速的I/O设备可以慢慢从缓冲区取走数据</li></ol><div style="page-break-after:always"></div><h5 id="c-缓冲管理策略"><a href="#c-缓冲管理策略" class="headerlink" title="c. 缓冲管理策略"></a>c. 缓冲管理策略</h5><h6 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h6><blockquote><p>一个缓冲区大小等于一个块大小</p></blockquote><p><strong>T&gt;C</strong></p><p>初始状态：工作区满，缓冲区空</p><p>故CPU处理数据，耗时C，同时块设备将数据读入到缓冲区耗时T。</p><p>由于T&gt;C，故 <em>CPU</em> 处理完数据后暂时不能将下一块数据传送到工作区，必须 <em>等待缓冲区中冲满数据</em></p><p><img src="/posts/151330232/image-20220313083029098.png" alt><br>此时处理一块数据的 $平均用时=T+M$</p><p><strong>T&lt;C</strong></p><p>初始状态：工作区满，缓冲区空</p><p>当 <em>缓冲区</em> 冲满数据后，必须 <em>等待</em> 工作区取走数据才能继续继续冲入数据</p><p><img src="/posts/151330232/image-20220313083126414.png" alt></p><p>此时处理一块数据的 $平均用时=C+M$</p><p><strong>单缓冲区间的通信</strong></p><p><img src="/posts/151330232/image-20220313090459716.png" alt></p><h6 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h6><blockquote><p>在主存中为其分配两个缓冲区</p></blockquote><p>初始状态：工作区空，缓冲区1满，缓冲区2空</p><p>处理一个数据块平均耗时=MAX{T,C+M}</p><p><strong>T&gt;C+M</strong></p><p><img src="/posts/151330232/image-20220313090138811.png" alt></p><p>每处理一个数据块 $平均耗时=T$</p><p><strong>T&lt;C+M</strong></p><p><img src="/posts/151330232/image-20220313085742474.png" alt="image-20220313085742474"></p><p>设备输入数据块的速度要比处理机处理数据块的速度快，每处理一个数据块 $平均耗时=C+M$</p><p><strong>双缓冲区机器间的通信</strong></p><p><img src="/posts/151330232/image-20220313090539547.png" alt></p><h6 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h6><blockquote><p>将多个大小相等的缓冲区链接成一个循环队列</p></blockquote><p><img src="/posts/151330232/image-20220313090629499.png" alt></p><h5 id="d-缓冲池"><a href="#d-缓冲池" class="headerlink" title="d. 缓冲池"></a>d. 缓冲池</h5><h6 id="三个队列四个区"><a href="#三个队列四个区" class="headerlink" title="三个队列四个区"></a>三个队列四个区</h6><p><img src="/posts/151330232/image-20220313100326723.png" alt></p><p>缓冲队列</p><ul><li>空缓冲队列：没有存放数据的空闲缓冲区链接成队列</li><li>输入队列：用于存放设备输入数据的缓冲区队列</li><li>输出队列：用于存放输出数据的缓冲区队列</li></ul><p>四个区</p><ul><li>收容输入数据的工作缓冲区(hin)</li><li>提取输入数据的工作缓冲区(sin)</li><li>收容输出数据的工作缓冲区(hout)</li><li>提取输出数据的工作缓冲区(sout)</li></ul><h6 id="输入进程请求输入数据"><a href="#输入进程请求输入数据" class="headerlink" title="输入进程请求输入数据"></a>输入进程请求输入数据</h6><p>从 <em>空缓冲队列</em> 中取出一块作为 <em>收容输入数据的工作区(hin)</em> ，冲满数据后将缓冲区放入 <em>输入队列</em> 队尾</p><p><img src="/posts/151330232/image-20220313100518006.png" alt></p><h6 id="计算进程取得一块输入数据"><a href="#计算进程取得一块输入数据" class="headerlink" title="计算进程取得一块输入数据"></a>计算进程取得一块输入数据</h6><p>从输入队列中取得一块充满数据的缓冲区作为 <em>提取数据的工作缓冲区(sin)</em></p><p>缓冲区读完后，挂到空缓冲队列</p><p><img src="/posts/151330232/image-20220313102629870.png" alt></p><h6 id="计算进程将数据输出到输出缓冲区"><a href="#计算进程将数据输出到输出缓冲区" class="headerlink" title="计算进程将数据输出到输出缓冲区"></a>计算进程将数据输出到输出缓冲区</h6><p>从空缓冲队列中取出一块作为 <em>收容输出数据的工作缓冲区(hout)</em> ，缓冲区冲满后挂到输出队列队尾</p><p><img src="/posts/151330232/image-20220313102955712.png" alt></p><h6 id="输出进程请求输出数据"><a href="#输出进程请求输出数据" class="headerlink" title="输出进程请求输出数据"></a>输出进程请求输出数据</h6><p>从输出队列中取得一块冲满的 <em>输出数据的工作区(sout)</em></p><p><img src="/posts/151330232/image-20220313103123818.png" alt></p><h4 id="F-IO调度"><a href="#F-IO调度" class="headerlink" title="F. IO调度"></a>F. IO调度</h4><blockquote><p>用某种算法确定处理IO请求的顺序</p></blockquote><p>如：磁盘调度</p><ul><li>FCFS</li><li>最短道优先</li><li>SCAN算法</li></ul><h3 id="5-3-3-设备驱动程序"><a href="#5-3-3-设备驱动程序" class="headerlink" title="5.3.3 设备驱动程序"></a>5.3.3 设备驱动程序</h3><blockquote><p>不同设备内部硬件特性不同</p><ul><li>厂家需要提供与设备对应的驱动程序</li><li>每类设备一个设备驱动程序</li></ul></blockquote><p>功能</p><ul><li>将上层抽象的IO命令转化为具体的操作指令，发送给设备控制器</li></ul><p>设备驱动程序以一个独立进程存在</p><p>CPU只需执行设备对应的驱动程序，完成设置 <em>设备寄存器</em> ，检查设备的工作状态</p><h3 id="5-3-4-中断处理程序"><a href="#5-3-4-中断处理程序" class="headerlink" title="5.3.4 中断处理程序"></a>5.3.4 中断处理程序</h3><p>IO任务完成时，IO控制器会发出一个中断信号，系统根据中断信号类型找到对应的中断处理程序</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/151330232/" title="5.IO管理">https://amostian.github.io/posts/151330232/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tags"></i> 计算机基础</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tags"></i> 操作系统</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/3045355587/" rel="prev" title="5.查找"><i class="fa fa-chevron-left"></i> 5.查找</a></div><div class="post-nav-item"><a href="/posts/334722172/" rel="next" title="0.后端开发学习路线">0.后端开发学习路线 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#5-I-O%E8%AE%BE%E5%A4%87%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-text">5. I&#x2F;O设备与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-I-O%E8%AE%BE%E5%A4%87"><span class="nav-text">5.1 I&#x2F;O设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E5%88%86%E7%B1%BB"><span class="nav-text">5.1.1 分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">5.1.2 I&#x2F;O设备的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">IO控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E5%8A%9F%E8%83%BD"><span class="nav-text">a. 功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E7%BB%84%E6%88%90"><span class="nav-text">b. 组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-I-O%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">c. I&#x2F;O控制器端口的编址方式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2 I&#x2F;O控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.1 程序查询方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-text">过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.2 中断方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-DMA%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.3 DMA方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DMA%E7%89%B9%E7%82%B9"><span class="nav-text">DMA特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DMA%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90"><span class="nav-text">DMA控制器组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DMA%E8%BF%87%E7%A8%8B"><span class="nav-text">DMA过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-text">与中断方式对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E7%A6%BB%E6%95%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="nav-text">不适用于离散的数据块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.4 通道控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E8%BF%87%E7%A8%8B"><span class="nav-text">通道控制方式过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-text">特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-I-O%E7%AE%A1%E7%90%86"><span class="nav-text">5.3 I&#x2F;O管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E5%8A%9F%E8%83%BD"><span class="nav-text">5.3.1 功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-IO%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">5.3.2 IO系统层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"><span class="nav-text">5.3.1 用户层软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-SPOOLing%E6%8A%80%E6%9C%AF-%E5%81%87%E8%84%B1%E6%9C%BA"><span class="nav-text">A. SPOOLing技术(假脱机)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="nav-text">a. 脱机技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="nav-text">b. 假脱机技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA"><span class="nav-text">c. 共享打印机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="nav-text">5.3.2 设备独立性软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%8A%9F%E8%83%BD"><span class="nav-text">A. 功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E8%A1%A8"><span class="nav-text">B. 逻辑设备表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E8%AE%BE%E5%A4%87%E4%BF%9D%E6%8A%A4"><span class="nav-text">C. 设备保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-text">D. 设备的分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E6%80%BB%E5%8E%9F%E5%88%99"><span class="nav-text">a. 总原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="nav-text">b. 考虑因素</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%9B%BA%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-text">设备固有属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">设备分配算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-text">设备分配的安全性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text">c. 分配策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">d. 设备分配管理中的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8-SDT"><span class="nav-text">系统设备表(SDT)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8-DCT"><span class="nav-text">设备控制表(DCT)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8-COCT"><span class="nav-text">控制器控制表(COCT)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8%EF%BC%88CHCT%EF%BC%89"><span class="nav-text">通道控制表（CHCT）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#e-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4"><span class="nav-text">e. 设备分配步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#f-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95"><span class="nav-text">f. 设备分配改进方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E8%A1%A8-LUT"><span class="nav-text">逻辑设备表(LUT)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4"><span class="nav-text">分配步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-text">E. 缓冲区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BD%9C%E7%94%A8"><span class="nav-text">a. 缓冲区作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%BC%95%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%AD%96%E7%95%A5"><span class="nav-text">b. 引入缓冲区的工作策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-text">c. 缓冲管理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="nav-text">单缓冲</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">双缓冲区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">循环缓冲区</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="nav-text">d. 缓冲池</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E9%98%9F%E5%88%97%E5%9B%9B%E4%B8%AA%E5%8C%BA"><span class="nav-text">三个队列四个区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">输入进程请求输入数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%BF%9B%E7%A8%8B%E5%8F%96%E5%BE%97%E4%B8%80%E5%9D%97%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">计算进程取得一块输入数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%BF%9B%E7%A8%8B%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%88%B0%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">计算进程将数据输出到输出缓冲区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="nav-text">输出进程请求输出数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#F-IO%E8%B0%83%E5%BA%A6"><span class="nav-text">F. IO调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">5.3.3 设备驱动程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-4-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">5.3.4 中断处理程序</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">216</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">82</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1150.8k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">46:51</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>