<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="[TOC]"><meta property="og:type" content="article"><meta property="og:title" content="6.性能调优"><meta property="og:url" content="https://amostian.github.io/posts/1081161349/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="[TOC]"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112102847738.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112195200101.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112120047630.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112203132690.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231110172807558.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112214646763.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112214945129.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231108210850547.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231110173646322.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112220741165.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112102917372.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231102233320607.png"><meta property="og:image" content="https://amostian.github.io/posts/1081161349/image-20231112105713394.png"><meta property="article:published_time" content="2023-11-08T03:59:41.000Z"><meta property="article:modified_time" content="2024-10-04T11:29:42.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="存储"><meta property="article:tag" content="分布式存储"><meta property="article:tag" content="Ceph"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/1081161349/image-20231112102847738.png"><link rel="canonical" href="https://amostian.github.io/posts/1081161349/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>6.性能调优 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">68</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">83</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">236</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/1081161349/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">6.性能调优</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2023-11-08 11:59:41" itemprop="dateCreated datePublished" datetime="2023-11-08T11:59:41+08:00">2023-11-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2024-10-04 19:29:42" itemprop="dateModified" datetime="2024-10-04T19:29:42+08:00">2024-10-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/" itemprop="url" rel="index"><span itemprop="name">Ceph</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">12.2k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>[TOC]</p><span id="more"></span><h2 id="6-1-存储系统的典型场景"><a href="#6-1-存储系统的典型场景" class="headerlink" title="6.1 存储系统的典型场景"></a>6.1 存储系统的典型场景</h2><h3 id="6-1-1-性能与成本"><a href="#6-1-1-性能与成本" class="headerlink" title="6.1.1 性能与成本"></a>6.1.1 性能与成本</h3><p>对于存储系统而言，性能与成本就像天平的两个极端：追求极致的性能必然伴随着高昂的存储成本，而系统成本的节约必然伴随着性能指标的相形见绌。不同企业有着不同的存储工作负载，需要在性能、容量和总拥有成本（total cost of ownership，TCO）之间做出权衡。</p><p><img src="/posts/1081161349/image-20231112102847738.png" alt="image-20231112102847738"></p><p>极低的成本、极致性能以及成本与性能较为均衡的缓存方案，这三种场景基本可以覆盖绝大多数用户业务应用的需求。</p><ul><li>低成本冷存储，业界通常使用高比例纠删码、压缩、SMR叠瓦式磁盘以及大容量磁盘、大盘位服务器等技术方案，通常在对象存储领域使用较多。今年来，存储池休眠技术（磁盘休眠/唤醒功能）及基于蓝光存储等实现光/磁融合存储系统有了商用案例</li><li>高性能存储，通常使用NVMe SSD、Optane SSD等高性能存储介质，配合磁盘多分区域构建Ceph的OSD服务，提升磁盘的性能输出，以上技术方案通常在块存储领域使用较多</li><li>缓存方案是在高速的SSD存储介质与低速的HDD存储介质之间构建起连接，基于存储方案的存储系统，求成本与性能介于低成本冷存储方案与高性能存储方案之间</li></ul><h3 id="6-1-2-低成本冷存储"><a href="#6-1-2-低成本冷存储" class="headerlink" title="6.1.2 低成本冷存储"></a>6.1.2 低成本冷存储</h3><p>可按照I/O要求，分为不同的存储类别产品</p><ul><li>3年内数据可实时调用<ul><li>热存Online对象存储：I/O在任何时间可直接使用，包括RAM、SSD或磁盘</li></ul></li><li>3~5年内数据可查，数据被激活到可读的时间为数小时内<ul><li>冷存Nearline对象存储：并不直接可用，但可在无人工干预的情况下迅速从近线到在线，速度非常快，包括自动磁带库及MAID（massive array of idle disks）的降低转速技术</li></ul></li><li>5年以上数据可查：JBOD整体下架保存<ul><li>离线盘Offline：不直接可用，从离线到在线需要人工干预，如USD、DVD或其他可卸载设备</li></ul></li></ul><p>不同存储类型产品的速度差异</p><p><img src="/posts/1081161349/image-20231112195200101.png" alt="image-20231112195200101"></p><h4 id="冷存储需求和意义"><a href="#冷存储需求和意义" class="headerlink" title="冷存储需求和意义"></a>冷存储需求和意义</h4><p>智能互联网时代，数据正以几何级的数量爆炸增长，如何存储并管理这些海量数据，是很多企业面临的难题。若采用传统通用型服务器存储策略，就意味着要建设庞大的数据中心系统，导致存储成本极速攀升。为了进一步降低企业存储数据的成本，把不常访问的、较旧的冷数据迁移到专为存储冷数据而设计的低成本存储层中——即冷存储。冷存储，通常意味着数据不会经常被访问，也或许永远不会被访问，但用户还是希望保留。</p><p>对于冷存储，AWS有Glacier产品线，Google有Nearline Storage产品线。</p><p>在2019年之前，AWS有单独的冷存储（归档存储）产品线Glacier，现在Glacier已经合并到对象存储产品线中，全称是AWS S3 Glacier，与S3的多个存储类别实现整合。S3支持完整的数据生命周期管理功能，这个功能同样覆盖了Glacier：支持直接写入温存储或者冷存储。</p><p>Facebook的冷存储数据中心功耗只有正常数据中心的六分之一，通过分离频繁访问的内容可以节省更多的电力开销。Facebook冷存储支持将对象存储中的文件通过设定固定时间期限的方式，自动迁移到冷存储。整个冷存储系统是作为其他系统出现数据丢失时最后一个可以恢复的数据源而存在的。</p><h4 id="冷存储设计"><a href="#冷存储设计" class="headerlink" title="冷存储设计"></a>冷存储设计</h4><h5 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h5><p>冷存储系统的目标就是提高经济效益，降低成本。</p><ul><li><p>在设备首次采购成本方面，冷存储更加关注机柜与硬盘。</p><p>在单位机柜中放更多的硬盘，正常的4U48盘位密度太低，需要引入JBOD（Just a Bunch Of Disks）设备，通常一个4U服务器满配下加带6个JBOD设备，每个JBOD最多可放置102块硬盘（如果机架可以支持8个高密度JBOD，则可以接近安装1000块磁盘）。</p><p>在单位硬盘下提供更大的容量，采用PMR技术，单盘最大容量可达到12TB，引入SMR技术，单盘最大容量可以支持18TB甚至更高。</p></li><li><p>在运营成本方面，电力开销的主要来源是磁盘转动的功耗。</p><p>为了尽可能地降低电费，在运营维护过程中应该关闭不必要的磁盘，只让最少数的磁盘维持转动，支持存储池级别的休眠，移除所有的冗余电源。</p><p>冷数据的主要特征是访问频次很低，如果磁盘上的数据局部合理，大多数磁盘可以脱机。每个托盘(tray)同时只有一个设备上电，只有部分磁盘提供读/写服务。</p></li></ul><p>AWS Glacier基于磁带库构建，利用旧设备，缓解设备采购成本</p><p>Google的Nearline Storage，基于磁盘的，通常是SATA，功耗低，主要是为了获取数据时速度更快，数据能更快地在不同的存储层级之间移动</p><h5 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h5><p>软件设计的首要目标是保持系统持久性，避免单点故障。当系统出现异常后，仅需要调用少量资源就会可恢复数据</p><ul><li><p>SMR技术</p><p>采用新型磁存储技术的高容量磁盘。SMR盘将盘片上的数据磁道部分重叠，大大提高磁盘存储密度。</p><p>SMR不再支持随机写和原地更新写（新入的磁道会覆盖与之重叠的所有磁道），只能进行顺序追加写</p><p>存储引擎需要开发单机存储引擎来专门支持SMR磁盘</p></li><li><p>存储池休眠/唤醒技术</p><p>大规模空闲空闲磁盘阵列技术（MAID），降低功耗的最佳选择</p></li><li><p>纠删码技术</p></li></ul><h5 id="纠删码"><a href="#纠删码" class="headerlink" title="纠删码"></a>纠删码</h5><p>保障数据可靠性最流行的方法之一就是复制。复制方法通过将多份相同的数据存储在不同的物理位置保证数据的可靠性</p><p>就性能和可靠性而言，复制方法也被证明是一种很好的方法，但增加了系统的整体成本</p><ul><li>采用复制的方法，需要两倍的存储空间来提供冗余</li></ul><blockquote><p>纠删码 ：将存储对象分割为数据块的片段，再对这些数据块进行扩展并编码生成校验块，最后将生成的校验块存储在Ceph集群的不同故障域中，实现数据保护</p></blockquote><ul><li>纠删码从Ceph的F版开始引入</li></ul><h6 id="纠删码原理"><a href="#纠删码原理" class="headerlink" title="纠删码原理"></a>纠删码原理</h6><p>Reed-Solomon(RS)码是存储系统中常见的一种纠删码</p><script type="math/tex;mode=display">RS(k,m)=n=k+m</script><ul><li>k：将原始数据分割后的数据片段数目</li><li>m：为了提供数据保护而在原始数据块中额外引入的编码，也就是校验块</li><li>n：纠删码运行后生成的数据块总数</li></ul><p>启用了纠删码的Ceph池中的每个对象都将存为 $k+m$ 个块，每个块都存储在acting集合的不同OSD中</p><p><strong>恢复</strong> ：在Ceph恢复期间，需要n个块中的任意k个块来恢复数据</p><p><strong>可靠性级别</strong> ：使用纠删码，可以容忍 m 个块的数据丢失</p><p><strong>编码率</strong> ：$r=\frac{k}{n}$</p><p><strong>存储需求</strong> ：通过 $\frac{1}{r}$ 计算</p><hr><p>如：使用纠删码 (3,2) 规则创建5个OSD的Ceph池</p><p>则每个对象除了自己本身分割为三个数据块外，还需要额外添加两个校验块，这5个数据块分别存储在Ceph集群的纠删码池的5个OSD中。一旦发生故障，构建原始文件时，只需要3个块就可以恢复</p><p>此时 $编码率r=\frac{k}{n}=\frac{3}{5}&lt;1$ ，$存储需求=\frac{1}{r}=\frac{5}{3}\approx 1.6倍原文件$</p><p>即允许两个以内的OSD出错，</p><p>若以副本形式保证部集群的可靠性。允许两个以内的OSD出错，则需要一个复制级别为3的池，最终需要3GB的存储空间来存储1GB的数据</p><h6 id="纠删码分析"><a href="#纠删码分析" class="headerlink" title="纠删码分析"></a>纠删码分析</h6><p><strong>慢</strong> ：基于纠删码机制存储数据的速度比复制方法慢</p><p>纠删码对于存储成本的节省是以性能损耗为代价的，因为纠删码工作过程中会把每个对象分为多个较小的数据块，并且一些新的校验块会与数据块混合在一起。这些块还需要分布在不同的故障域中。</p><p>整个过程需要消耗OSD大量的算力，且在恢复时，解码数据块也需要大量的计算</p><div class="table-container"><table><thead><tr><th>两种技术</th><th>磁盘利用率</th><th>计算开销</th><th>网络消耗</th><th>恢复效率</th></tr></thead><tbody><tr><td>多副本(3副本)</td><td>$\frac{1}{3}$</td><td>几乎没有</td><td>较低</td><td>较高</td></tr><tr><td>纠删码(k+m)</td><td>$\frac{m}{k+m}$</td><td>高</td><td>较高</td><td>较低</td></tr></tbody></table></div><h6 id="纠删码插件"><a href="#纠删码插件" class="headerlink" title="纠删码插件"></a>纠删码插件</h6><p>使用不同的插件可以创建不同的纠删码profile</p><p><strong>Jerasure</strong></p><p>通用和灵活，Ceph存储池默认的插件，封装了Jerasure库。</p><p><img src="/posts/1081161349/image-20231112120047630.png" alt="image-20231112120047630"></p><p>使用Jerasure插件，当一个OSD丢失的话，恢复数据需要从所有其他OSD上读取数据。举例来说，如果Jerasure配置为k=3，m=2，丢失一个OSD需要读取所有5个OSD才能修复，这对数据恢复过程而言并不高效。</p><p><strong>LRC</strong></p><p>本地可修复的纠删码插件，Locally repairable erasure code plugin</p><p>由于Jerasure不能有效地做数据恢复，LRC采用本地校验的方法改进，LRC为单个OSD故障做了优化</p><p>创建本地校验块，可以从更少的OSD上恢复数据</p><p><img src="/posts/1081161349/image-20231112203132690.png" alt="image-20231112203132690"></p><p>K=8，m=4，l=4</p><p>将原始数据分为8个块，生成4个校验块，每个本地校验块L通常用于4个数据块的校验</p><p>当数据丢失时，只需要l个数据恢复</p><ul><li>假设K3丢失，用 K1 、K2、K4和L1中恢复数据</li></ul><p><strong>SHEC</strong></p><p>瓦式纠删码，Shingled erasure code plugin</p><p>对于多个OSD故障，LRC存在开销</p><ul><li>对于K3,K4同时丢失，需要从K1、K2、L1、M1中恢复</li></ul><p>SHEC目的是有效处理多个磁盘故障，本地校验块校验彼此重叠部分</p><p><img src="/posts/1081161349/image-20231110172807558.png" alt="image-20231110172807558"></p><p>若K6和K9丢失，则使用M3，M4，K5，K7，K8，K10作为校验块</p><h6 id="Ceph中创建纠删码池"><a href="#Ceph中创建纠删码池" class="headerlink" title="Ceph中创建纠删码池"></a>Ceph中创建纠删码池</h6><p>通常情况下，适合低成本冷存储的数据会与复制池绑定在一起，数据先存储在速度更快的复制池中，等一定周期内无法访问，则被写回到低成本的纠删码池中</p><p>创建 erasure 类型的Ceph池实现纠删码池</p><p>基于纠删码配置文件创建，这个配置文件定义了纠删码的特征值</p><p><strong>创建纠删码配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">指令格式：ceph osd erasure-code-profile set [纠删码配置文件名] ruleset-failure-domain=osd k=3 m=2</span><br><span class="line"></span><br><span class="line">ceph osd erasure-code-profile set EC-profile ruleset-failure-domain=osd k=3 m=2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出纠删码配置文件</span></span><br><span class="line">ceph osd erasure-code-profile ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看纠删码配置文件内容</span></span><br><span class="line">ceph osd erasure-code-profile get EC-profile</span><br></pre></td></tr></table></figure><p><strong>基于纠删码配置文件新建纠删码池</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool create [池名] 16 16 erasure [配置文件名]</span><br><span class="line"></span><br><span class="line">ceph osd pool create EC-pool 16 16 erasure EC-profile</span><br><span class="line"></span><br><span class="line">ceph osd dump | grep -i EC-pool</span><br></pre></td></tr></table></figure><p>池的大小为 $5(k+m)$ ，即纠删码池 erasure 会被写入到5个不同的OSD中</p><p><strong>生成数据并放入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello Ceph&quot; &gt; file1.txt</span><br><span class="line">rados put -p EC-pool object1 file1.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查EC池中object1的OSD map</span></span><br><span class="line">ceph osd map EC-pool object1</span><br></pre></td></tr></table></figure><p>停止某个OSD，则该查看object1的map时，该OSD的位置被随机数代替，表示该OSD在这个池中不可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh ceph-node2  service ceph stop osd.5</span><br><span class="line">ceph osd map EC-pool object1</span><br></pre></td></tr></table></figure><p>继续停止某个OSD，发现只剩的三个块，仍可以访问数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rados -p EC-pool ls #查看池中的对象</span><br><span class="line"></span><br><span class="line">rados get -p EC-pool object1 /tmp/file1</span><br></pre></td></tr></table></figure><p>在恢复过程中，通过解码失效的块，纠删池在新的OSD上进行重建，恢复成功后，所有的块都处于可用状态</p><h4 id="冷存储发展方向"><a href="#冷存储发展方向" class="headerlink" title="冷存储发展方向"></a>冷存储发展方向</h4><p>5G及物联网技术将继续以指数方式增加企业需要管理的数据量，来自世界各地的数百万设备和数据源将提供大量的数据。金融机构、企业公司和政府需要大规模、低成本的大数据冷存储库，冷存储的需求将会在未来持续增长。</p><ul><li>蓝光存储，光盘比磁盘价格便宜一般，但能源效率是磁盘5倍。蓝光并不适合所有人，如大型视频文件和高性能计算(HPC)数据，这些文件很可能太大，无法存储在容量相对较低的蓝光磁盘上。</li><li>闪存通常用于热存储场景，但闪存的成本与它的可靠性和写入能力有关，理论上可以制造出非常便宜、质量很低、只能写入一两次的存储器。其优势在于它可以在毫秒内被点亮，因此从“冷数据”状态开始的访问时会很快。</li></ul><p>在构建自己的冷存储体系结构时，需要了解要存储数据的类型、保留策略、存储成本，当然还要了解在恢复期间需要这些信息的速度有多快。</p><h3 id="6-1-3-高性能存储"><a href="#6-1-3-高性能存储" class="headerlink" title="6.1.3 高性能存储"></a>6.1.3 高性能存储</h3><p>仅关注通过SSD(含SATA/SAS ssD、 NVMe sSD)存储介质构建的 Ceph 块存储集群，由于SSD存储介质价格受Nand闪存芯片颗粒市场的校多，后续讨论将围绕如何提高单TB存储容量可发挥的性能展开。</p><h4 id="硬件-1"><a href="#硬件-1" class="headerlink" title="硬件"></a>硬件</h4><p>Ceph中国社区推荐配置：</p><ul><li>每个OSD进程占用2个CPU核</li><li>考虑到OSD进程的集群恢复场景，通常要求每TB存储空间配备约1GB的内存容量</li><li>在集群网络方面，生产环境下建议 public 网络和cluster网络物理隔离，通常10Gbit/s或25Gbit/s最佳</li></ul><h4 id="软件-1"><a href="#软件-1" class="headerlink" title="软件"></a>软件</h4><p>常见做法是对SSD存储介质做多分区策略，划分后每个分区分别承载一个OSD进程</p><p><img src="/posts/1081161349/image-20231112214646763.png" alt="image-20231112214646763"></p><p>从单SSD做3分区划分到4分区划分，集群整体性能收益不再增加，而单SSD做4分区占用更多的CPU、内存资源，因此单SSD划分3分区对Ceph集群整体性能提升性价比更高。</p><p>多分区部署Ceph OSD守护进程</p><p><img src="/posts/1081161349/image-20231112214945129.png" alt="image-20231112214945129"></p><h3 id="6-1-4-缓存方案"><a href="#6-1-4-缓存方案" class="headerlink" title="6.1.4 缓存方案"></a>6.1.4 缓存方案</h3><p>当前阶段，同样容量的SSD成本高于HDD，如何有效组织SSD与HDD实现存储系统中性能与成本的均衡，仍有重要意义。实现这一目标，需要依赖于智能的数据分层存储方案，即缓存方案。缓存方案对I/O写请求有削峰填谷的作用，也可以协调数据在吞吐能力相差较大的存储设备间进行平稳传输，也对I/O读请求有提升命中率的效果，可以组织频繁被访问的数据存储在高性能的存储介质中以得到快速响应。</p><h4 id="硬件-2"><a href="#硬件-2" class="headerlink" title="硬件"></a>硬件</h4><p>LSI的Mega RAID阵列卡的CacheCade功能。Intel公司的Smart Response Technology（SRT）都允许用户在使用HDD前利用SSD作为高速缓存</p><h4 id="软件-2"><a href="#软件-2" class="headerlink" title="软件"></a>软件</h4><ul><li>ZFS</li><li>LVM</li><li>FlashCache</li><li>Bcache</li><li>DM-Cache</li><li>Enhance IO</li><li>Intel CAS</li></ul><p>都是实现SSD对HDD的IO加速，Ceph自身的Cache Tier缓存池方案也能实现类似功能</p><h5 id="Ceph-Cache-Tier"><a href="#Ceph-Cache-Tier" class="headerlink" title="Ceph Cache Tier"></a>Ceph Cache Tier</h5><p>缓存分层特性也是在Ceph的F版发布的。</p><p>缓存分层是在更快的磁盘（SSD）上创建一个Ceph池，这个缓存池应放置在一个常规复制池或erasure池（HDD）的前端，这样所有的客户端IO经过缓存池处理之后，再将数据刷新（flush）到现有的数据池中</p><p><img src="/posts/1081161349/image-20231108210850547.png" alt="image-20231108210850547"></p><p>客户端能够享受缓存池的高性能，一段时间后，缓存层将所有数据写回备用的存储层，以便可以缓存来自客户端的新请求</p><p>在缓存层和存储层之间的数据迁移都是自动触发且对客户端透明的</p><h6 id="缓存分层模式"><a href="#缓存分层模式" class="headerlink" title="缓存分层模式"></a>缓存分层模式</h6><p><strong>writeback</strong></p><ul><li><p>写</p><p>当Ceph缓存分层配置为writeback模式时，Ceph客户端将数据写到缓存层类型池中，客户端能立即收到写入确认</p><p>基于为缓存层指定的 flushing/evicting策略，数据从缓存层迁移到存储层，并最终由缓存分层代理将其从缓存层中删除</p></li><li><p>读</p><p>由缓存分层代理将数据从存储层迁移到缓存层，然后将其提供给客户。直到数据不活跃或变为冷数据，否则会一直保留在缓存层中</p><p>适用于可变数据：图片、视频编辑、交易性数据等理想模式</p></li></ul><p><strong>read-only模式</strong></p><p>只处理来自客户端的读操作。客户端的写操作不涉及缓存分层。</p><p>缓存分层代理将请求的数据从存储层复制到缓存层。</p><p>基于为缓存层配置的策略，不活跃的对象将会从缓存层中删除</p><p><strong>Forward模式</strong></p><p><strong>Proxy模式</strong></p><p><strong>Read-forward模式</strong></p><p><strong>Read-Proxy模式</strong></p><h6 id="部署Ceph-Cache-Tier"><a href="#部署Ceph-Cache-Tier" class="headerlink" title="部署Ceph Cache Tier"></a>部署Ceph Cache Tier</h6><p><img src="/posts/1081161349/image-20231110173646322.png" alt="image-20231110173646322"></p><p><strong>1. 新建池</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 获取CRUSH map并反编译</span></span><br><span class="line">ceph osd getcrushmap -o crushmapdump</span><br><span class="line"></span><br><span class="line">crushtool -d crushmapdump -o crushmapdump-decompiled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 编辑反编译得到的CRUSH map</span></span><br><span class="line">vim crushmapdump-decompiled</span><br><span class="line"></span><br><span class="line">[buckets]</span><br><span class="line">root cache&#123;</span><br><span class="line">	id -5</span><br><span class="line">	alg straw</span><br><span class="line">	hash 0</span><br><span class="line">    item osd.0 weight 0.010</span><br><span class="line">    item osd.3 weight 0.010</span><br><span class="line">    item osd.6 weight 0.010</span><br><span class="line">&#125;</span><br><span class="line">[ruleset]</span><br><span class="line">rule cache-pool&#123;</span><br><span class="line">	ruleset 4</span><br><span class="line">	type replicated</span><br><span class="line">	min_size 1</span><br><span class="line">	max_size 10</span><br><span class="line">	step take cache</span><br><span class="line">	step chooseleaf firstn 0 type osd</span><br><span class="line">	step emit</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 编译CRUSH map并将其导入Ceph集群中</span></span><br><span class="line">crushtool -c crushmapdump-decompiled -o crushmapdump-compiled</span><br><span class="line">ceph osd set crushmap -i crushmapdump-compiled</span><br><span class="line">一旦Ceph集群应用新的CRUSH map，`ceph osd tree` 可以发现名为 cache 的新的 root bucket</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4. 在SSD磁盘上新建缓存池</span></span><br><span class="line">ceph osd pool create cache-pool 32 32</span><br><span class="line">ceph osd pool set cache-pool crush_ruleset 4</span><br><span class="line"></span><br><span class="line">ceph osd dump | grep -i cache-pool</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 检查cache池是否创建成功</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出缓存池的所有对象</span></span><br><span class="line">rados -p cache-pool ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向缓存池中添加一个临时对象，验证对象存储在正确的OSD上</span></span><br><span class="line">rados -p cache-pool put object1 /etc/hosts</span><br><span class="line">rados -p cache-pool ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查缓存池和object1的OSD map</span></span><br><span class="line">ceph osd map cache-pool object1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除这个对象</span></span><br><span class="line">rados -p cache-pool rm object1</span><br></pre></td></tr></table></figure><p><strong>2. 新建缓存层</strong></p><p><img src="/posts/1081161349/image-20231112220741165.png" alt="image-20231112220741165"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 为存储池设置缓存池</span></span><br><span class="line">指令格式：ceph osd tier add [存储池] [缓存池]</span><br><span class="line">ceph osd tier add EC-pool cache-pool</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2. 设置缓存模式为writeback或read-only</span></span><br><span class="line">指令格式：ceph osd tier cache-mode [cache_pool] [writeback | read-only]</span><br><span class="line">ceph osd tier cache-mode cache-pool writeback</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3. 转发客户端请求</span></span><br><span class="line">指令格式：ceph osd tier set-overlay [存储池] [缓存池]</span><br><span class="line">ceph osd tier set-overlay EC-pool cache-pool</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 检查池的细节</span></span><br><span class="line">ceph osd dump | egrep -i &quot;EC-pool|cache-pool&quot;</span><br><span class="line"></span><br><span class="line">EC-pool的tier、read-tier、write-tier都被设置为16（缓存池的ID）</span><br><span class="line">cache-pool的tier_of设置为15（EC-pool的ID）,cache_mode 为writeback</span><br></pre></td></tr></table></figure><p><strong>3. 配置缓存层</strong></p><p>缓存层有几个配置选项，需要为缓存层配置一些参数以实现策略的设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为缓存池启用 hit <span class="built_in">set</span> 命中记录，生产级别的缓存层通常使用bloom过滤器</span></span><br><span class="line">ceph osd pool set cache-pool hit_set_type bloom</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改缓存池中存储的hits <span class="built_in">set</span>（命中集合）次数</span></span><br><span class="line">ceph osd pool set cache-pool hits_set_count 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改hit <span class="built_in">set</span> 在缓存池中的有效期，以s为单位</span></span><br><span class="line">ceph osd pool set cache-pool hit_set_period 300</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存分层代理开始从缓存池中将对象写回后端存储或删除前，允许存放的最大字节数</span></span><br><span class="line">ceph osd pool set cache-pool target_max_types 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存分层代理开始从缓存池中将对象写回后端存储或删除前，允许存放的最大对象数</span></span><br><span class="line">ceph osd pool set cache-pool target_max_objects 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存分层代理将数据从缓存层刷新到存储层中并删除这些数据的最小时间间隔,s为单位</span></span><br><span class="line">ceph osd pool set cache-pool cache_min_flush_age 300 #刷新到存储层</span><br><span class="line">ceph osd pool set cache-pool cache_max_evict_age 300 #删除缓存层数据</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存分层代理开始将数据写回存储层前，允许缓存池中被修改数据总量占池总量的百分比</span></span><br><span class="line">ceph osd pool set cache-pool cache_target_dirty_ratio .01</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存分层代理开始将新的数据写回存储层前，允许缓存池存放未经修改的数据总量占池总量的百分比</span></span><br><span class="line">ceph osd pool set cache-pool cache_target_full_ratio .02</span><br></pre></td></tr></table></figure><p><strong>4. 测试缓存层</strong></p><p>在客户端进行写操作，数据会先写在缓存池上，客户端可以获得更快的IO</p><p>基于缓存层策略，数据会透明地从缓存池迁移到一个存储池</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向EC-pool中写入</span></span><br><span class="line">rados -p EC-pool put object1 /tmp/tmpfile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">EC-pool已经与一个缓存池绑定，所以不会里面刷入EC-pool</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">date</span>跟踪时间</span></span><br><span class="line">rados -p EC-pool ls</span><br><span class="line">rados -p cache-pool ls</span><br><span class="line">	发现cache-pool已经写入object1，EC-pool还没有</span><br><span class="line">date</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由于配置了cache_min_evict_age为300s，缓存分层代理将从缓存池中迁移object1到EC-pool中</span></span><br><span class="line">date</span><br><span class="line">rados -p EC-pool ls</span><br><span class="line">rados -p cache-pool ls</span><br></pre></td></tr></table></figure><h2 id="6-2-Ceph性能"><a href="#6-2-Ceph性能" class="headerlink" title="6.2 Ceph性能"></a>6.2 Ceph性能</h2><p>[ceph cookbook]</p><p>同一时间段内大量客户端向应用程序发起请求时，需要一个性能更好的后端存储系统</p><p>当数据请求到达Ceph时，Ceph会将请求其分散到多个节点和OSD，实际提供的性能是多个节点的叠加</p><p>当为Ceph添加新的OSD节点时，整个存储集群的性能会线性增加，因为有了更多能够分担负载的OSD</p><h3 id="6-2-1-性能指标"><a href="#6-2-1-性能指标" class="headerlink" title="6.2.1 性能指标"></a>6.2.1 性能指标</h3><p>性能数据分为：</p><ul><li>集群级</li><li>存储池级</li><li>存储节点级</li></ul><h4 id="集群性能指标"><a href="#集群性能指标" class="headerlink" title="集群性能指标"></a>集群性能指标</h4><p>集群读IOPS、集群写IOPS</p><p>集群读带宽(byte/s)、写带宽(byte/s)</p><p>集群读I/O时延(ms)、集群写I/O时延(ms)</p><h4 id="存储池性能指标"><a href="#存储池性能指标" class="headerlink" title="存储池性能指标"></a>存储池性能指标</h4><p>存储池读IOPS、存储池写IOPS</p><p>集群读带宽(byte/s)、写带宽(byte/s)</p><p>存储池读I/O时延(ms)、存储池写I/O时延(ms)</p><h4 id="存储节点性能指标"><a href="#存储节点性能指标" class="headerlink" title="存储节点性能指标"></a>存储节点性能指标</h4><p><strong>磁盘性能</strong></p><p>读IOPS，写IOPS，读带宽(byte/s)，写带宽(byte/s)</p><p><strong>网卡性能</strong></p><p>每秒收包数，每秒发包数，收带宽(byte/s)，发带宽(byte/s)</p><p><strong>CPU性能</strong></p><p>IDLE，SYS，USER，IOWAIT，IRQ，SOFTIRQ，NICE所占百分比</p><p><strong>内存性能</strong></p><p>TOTAL、FREE、BUFFERS、CACHE、SWAPCACHED、SWAPREE大小(bytes)</p><h3 id="6-2-3-性能调优方向"><a href="#6-2-3-性能调优方向" class="headerlink" title="6.2.3 性能调优方向"></a>6.2.3 性能调优方向</h3><p>Ceph能在同一集群中，针对不同工作负载，提供不同类型的存储池</p><p><img src="/posts/1081161349/image-20231112102917372.png" alt="image-20231112102917372"></p><h4 id="IOPS优化"><a href="#IOPS优化" class="headerlink" title="IOPS优化"></a>IOPS优化</h4><p>随着闪存使用的增加，企业越来越多地将IOPS敏感型工作负载依托在Ceph集群，以便提高私有云存储解决方案的性能。在此场景下，可以把MySQL、MariaDB或PostgreSQL托管在Ceph集群，以支持结构化数据</p><p>这种配型在每次IO低总体拥有成本（Total Cost of Ownership，TCO）下拥有高的IOPS。</p><p>通常使用更快的SSD硬盘，PCIe SSD、NVMe等数据存储的高性能结点</p><p>通常用于块存储，也可用于其他场景</p><h4 id="吞吐量优化"><a href="#吞吐量优化" class="headerlink" title="吞吐量优化"></a>吞吐量优化</h4><p>Ceph集群通常可以存储半结构化数据，一般是顺序读写比较大的文件，需要提供很大的带宽。存储服务器上的磁盘可以使用SSD做日志加快HDD</p><p>这种配型在每吞吐量的低总体拥有成本（Total Cost of Ownership，TCO）下拥有高的吞吐量。</p><p>使用SSD和PCIe SSD做OSD日志盘，以及一个高带宽、物理隔离的双重网络</p><p>通常用于块存储，高性能的对象存储和文件存储</p><h4 id="容量优化"><a href="#容量优化" class="headerlink" title="容量优化"></a>容量优化</h4><p>低成本和高容量的解决方案用于处理存储容量较大、存储时间较长的数据，且按块顺序读写。数据可以是结构化或半结构化。存储内容包括媒体文件、大数据分析文件和磁盘镜像备份等。为了获得更高的效益，OSD与日志通常都托管在HDD。</p><p>每TB存储的低成本，单元机架物理空间的低成本</p><p>使用机械硬盘的密集服务器（36-72），每个服务器有4-6T物理硬件空间</p><p>用于低功耗、大容量的对象存储和文件存储——纠删码技术</p><h2 id="6-3-性能调优"><a href="#6-3-性能调优" class="headerlink" title="6.3 性能调优"></a>6.3 性能调优</h2><p>Ceph具备优良的可扩展性以及分布式的体系结构，Ceph系统中的所有工作负载都会均匀地分布、分配到整个集群的各个存储节点上，每个存储节点包含数个OSD。因此，Ceph 的性能是集群节点内所有OSD性能的叠加，即当向Ceph集群添加满配OSD的新节点时，存储集群拥有了更多能够分担负载的OSD，以及在每个新节点上配置的CPU、内存和网络能力，整个存储集群的性能会线性增加。</p><p>由冯·诺依曼架构可以看出，Ceph产品性能调优方向主要有：CPU/内存，磁盘I/O，网络，应用软件四个方面</p><h3 id="6-3-1-硬件"><a href="#6-3-1-硬件" class="headerlink" title="6.3.1 硬件"></a>6.3.1 硬件</h3><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><p><strong>性能角度</strong></p><p>当系统处于recovery状态，需要 10Gbit/s 或更多双端口网络</p><h5 id="多网卡聚合负载均衡"><a href="#多网卡聚合负载均衡" class="headerlink" title="多网卡聚合负载均衡"></a>多网卡聚合负载均衡</h5><p>提升Ceph性能的主要手段是将多网卡聚合进行负载均衡，达到带宽叠加的效果</p><p>配置多网卡聚合可以使用Bonding和Teaming技术</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>磁盘的选择需要综合考虑工作负载和性能需求，决定了集群的整体性能和总成本。副本数也需要在可靠性、性能和TCO间做出平衡</p><h5 id="转速"><a href="#转速" class="headerlink" title="转速"></a>转速</h5><p>选择7200RPM以上的SATA或SAS</p><h5 id="non-RAID"><a href="#non-RAID" class="headerlink" title="non-RAID"></a>non-RAID</h5><h5 id="OSD日志"><a href="#OSD日志" class="headerlink" title="OSD日志"></a>OSD日志</h5><p>Ceph OSD包括两部分：日志部分与数据部分，即OSD的性能受日志和数据分区共同影响</p><p>Ceph在数据提交到备用存储之前，首先将数据写入日志（journal）的独立存储区域，日志可以使用相同的机械磁盘或不同的SSD磁盘或分区上的一小块缓冲区大小的分区，甚至可以用一个文件。</p><p><img src="/posts/1081161349/image-20231102233320607.png" alt="image-20231102233320607"></p><p>Ceph使用日志来保障速度和一致性。默认情况下，每隔5s日志会向备用存储中刷新数据</p><h5 id="日志分区"><a href="#日志分区" class="headerlink" title="日志分区"></a>日志分区</h5><p>日志允许OSD处理小文件写，随机写，为文件系统提供了充足时间将写操作合并到磁盘，能够很好地处理工作负载的峰值，减少访问时间和读取延迟实现吞吐量的提升</p><p>日志读写速度的提升显然会让系统整体的读写速度提升，将日志创建在SSD上，所有客户端的写操作都是写入SSD型日志中，然后再写入机械硬盘</p><p><strong>最佳实践</strong>：</p><p>常见的日志大小为10GB，分区越大越好</p><p>应该为每一个OSD配置独立的日志盘</p><p>采用SSD 盘的分区存储日志，机械盘存储数据兼顾成本与性能，每个SSD盘上可作为2～4个OSD日志盘</p><ul><li><p>在物理SSD磁盘上创建的每个逻辑分区都可以作为日志分区映射到OSD数据分区</p><p>每个SSD磁盘最多给4-5个OSD做日志，否则会成为集群的性能瓶颈。</p><ul><li>SATA/SAS SSD，则4个OSD数据硬盘共享一个SSD</li><li>PCIe/NVMe，则12-18个数据硬盘共享一个SSD</li></ul></li></ul><p><strong>缺点</strong> ：若将多个采用ext4或者XFS文件系统的日志挂载在同一磁盘上，会存在单点故障的风险，与这个SSD相关的OSD都会出错</p><ul><li><p>Btrfs是一个写时复制文件系统（将对象写入日志时，可以同时将该对象写入数据分区），支持回滚。若一个块的内容发生了变化，而针对这个块的写时独立进行的，因此能够保留旧的块</p></li><li><p>可以为日志增加RAID 1，但增加了存储成本</p></li></ul><h5 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h5><p><strong>硬盘故障率</strong></p><p>数百个旋转式HDD近距离安装时，其叠加的旋转振动会增加桌面级HDD的硬盘故障率</p><p>企业级HDD对震动做了特别处理，其平均无故障时间（MTBF）远少于桌面级HDD</p><p><strong>数据盘接口</strong></p><p>NL-SAS HDD有双重12GB/s端口，比单个端口的6GB/s的SATA性能更高，双重SAS端口提供了冗余，允许并行读写</p><p>SAS比SATA的不可恢复的读错误（URE）更低，URE越低，清理过程中发现的错误以及PG修复操作越少</p><p><strong>OSD节点密度</strong></p><p>OSD节点密度影响集群性能、容量和TCO</p><p>大量小容量节点比少量大容量节点好，</p><p>尽量使单个节点容量小于集群总容量的10%</p><h5 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h5><p>Ceph OSD守护进程运行在文件系统的上层，文件系统的稳定性和性能很大程度上依赖于底层文件系统的稳定性和性能。</p><p>此外，文件系统也提供了OSD使用的 <strong>扩展属性</strong>（XATTR）来扩展其内部状态和元数据的形式，使用 <code>xattr_name</code> 和 <code>xattr_value</code> 来存储对象的额外信息（内部对象的状态、快照、元数据和ACL等信息）</p><p>btrfs有更大的xattr元数据，以文件形式存储</p><p>xfs具有相对大的上限64KB</p><p>ext4上限太小，不能被使用</p><ul><li>若使用ext4文件系统，需要在ceph.conf的[OSD]段添加 <code>filestore xattr use omap = true</code></li></ul><p><strong>XFS</strong></p><p>推荐在生产环境Ceph集群中使用</p><ul><li>XFS是一种日志文件系统：客户端每次写入数据时，首先需要写入日志空间，再写入XFS文件系统，相当于两次写入操作，写入性能上不如Btrfs</li><li>XFS在元数据扩展性上存在性能问题</li></ul><p><strong>Btrfs</strong></p><p>使用Btrfs文件系统的OSD能提供最佳性能</p><ul><li>并行地写日志和OSD数据</li><li>支持写时复制和可写快照：对于虚拟机的部署和克隆十分有用</li><li>支持透明的压缩、普遍的校验和多设备的统一管理</li><li>支持对小文件的合并</li><li>集成卷管理</li><li>支持在线fsck的特性</li></ul><p>不具备用于生产系统的条件</p><p><strong>ext4</strong></p><p>ext4也是一种日志文件系统</p><p>ext4限制了XTTRA的存储容量使其不具备提供足够的XATTR信息的能力，而Btrfs和XFS在 XTTRA存储容量上的限额就比较大</p><h3 id="6-3-2-软件"><a href="#6-3-2-软件" class="headerlink" title="6.3.2 软件"></a>6.3.2 软件</h3><p><strong>任何系统的性能都是依赖负载和性能测试来量化的</strong>。性能调优就是要解决在性能测试过程中发现瓶颈的过程</p><p><strong>合理的调优流程</strong> ：从最小组件逐步向客户端调查</p><p>将性能调优参数写入一个Ceph集群的配置文件便于让Ceph守护进程每次启动时都能读取到</p><p>针对具体环境中的Ceph集群进行调优可能不会在其他环境中起作用</p><h4 id="通用调优参数"><a href="#通用调优参数" class="headerlink" title="通用调优参数"></a>通用调优参数</h4><h5 id="CPU-内存——内核参数"><a href="#CPU-内存——内核参数" class="headerlink" title="CPU/内存——内核参数"></a>CPU/内存——内核参数</h5><p><strong>kernel pid max</strong></p><p>Linux内核参数，控制线程和进程ID的最大数据</p><p>大多数Linux内核对于 <code>kernel pid max</code> 预设的值会很小。在拥有多个OSD的Ceph结点上需要为该参数设置更高的值</p><ul><li>若 $OSD &gt; 20$ ，在恢复和再平衡过程中会生成很多进程和线程用于快速的数据恢复和再平衡</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo xxxx &gt; /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure><h5 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h5><p><strong>为系统保留的内存空间最小值，KB</strong></p><p>如果预留太大会导致空闲使用内存不足，迫使内核频繁进行内存回收，严重影响性能。</p><ul><li>在超48GB RAM 系统上我们可将min_free_kbytes 参数设置为4194303(4GB)或者以上</li></ul><p>配置整个系统保留内存为1%到3%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 4194303 &gt; /proc/sys/vm/min_free_kbytes</span><br></pre></td></tr></table></figure><p><strong>虚拟内存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;vm.swappiness=0&quot; &gt;&gt; /etc/sysctl1.conf</span><br></pre></td></tr></table></figure><p>vm.swappiness 决定了应用内存来自页交换分区还是直接从页缓存中回收内存的程度。vm.swappiness 取值范围为0到100，</p><ul><li><p>1，系统将尽可能少地将内存页交换到交换分区，而是优先从页缓存中回收内存页。</p><p>虚存以IO为中心，内存交换的使用会导致整个服务器性能降低。为高IO工作负载配置低swappiness值</p></li><li><p>一般将wappiness设置为100。与从页缓存中回收内存相比，系统更喜欢交换页面到磁盘，以空出更多内存。</p></li></ul><p>在Ceph节点上，最重要的是Ceph进程不会被交换出去，通常设置为10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.dirty_ratio/vm.dirty_bytes</span><br></pre></td></tr></table></figure><p>这两个参数可以实现对内存回写磁盘的控制。当脏页数量达到一定比例(系统总内存占比)或者具体的阈值时，触发 Linux 内核强制回写磁盘数据。这时，进程的所有 I/O操作将被阻塞，这也是造成磁盘I/O 性能瓶颈的重要因素。我们可以尝试将这个比例或者阈值设置得大一些。比例和阙值只需要设置其中一个即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmdirty_backgroud ratio/vmdirty_backgroud_bytes</span><br></pre></td></tr></table></figure><p>当系统的脏页数量达到一定比例(系统总内存占比)或者具体的值时，将激活pdflush/flush/kdmflush 后台进程清理脏数据，异步执行回写磁盘数据操作。我们可以尝试将此比例设置得较小一些，比如 5%，这样可以保证系统数据平滑地回写到磁盘。</p><h5 id="网络调优"><a href="#网络调优" class="headerlink" title="网络调优"></a>网络调优</h5><p><strong>TCP/IP连接缓冲区</strong></p><p>Linux为每个TCP/IP连接级冲区，但是默认值可能不适用于所有连接x</p><ul><li>net.ipv4.tcp_wmem：设置操作系统的接收级冲区值</li><li>net.ipv4.tcp_rmem：设置操作系统的发送缓冲区值</li><li>net.ipv4.tcp_ mem：定义与内存使用有关的TCP堆栈行为</li><li>net.core_wmem_max：操作系统接收的所有类型的连接的最大接收缓冲区大小</li><li>net.core_ rmem max:操作系统接收的所有类型的连接的最大发送缓冲区大小。</li></ul><p>配置net.ipv4.tcp_wmem和net.ipv4.tcp_rmem参数时，需要按照固定格式进行。</p><ul><li>第一个值表示内核单个TCP套接字的最小缓冲区空间</li><li>第二个值表示内核单个TCP套接字的默认缓冲区空间</li><li>第三个值表示内核单个TCP套接字的最大缓冲区空间。</li></ul><p>对于net.ipv4.tcp_ mem参数</p><ul><li>第一个值表示内核较低的阈值</li><li>第二个值表示内核何时开始增加内存使用量</li><li>第三个值表示内核最大内存页数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@mon1] vim /etc/sysctl.d/99-ceph.conf</span><br><span class="line">net.ipv4.tcp_rmem 4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem 4096 16384 16777216 </span><br><span class="line">net.core.rmem_max 16777216</span><br><span class="line">net.core.wmem_max 16777216</span><br></pre></td></tr></table></figure><p><strong>jumbo frames</strong></p><p>MTU的以太网帧载荷超过1500字节的称为jumbo贴（巨帧）。</p><p>在Ceph集群节点的网络接口上使用jumbo贴可以提供更好的网络吞吐量</p><p>jumbo贴在操作系统级配置，且网络接口即后端网络交换机必须支持jumbo贴才行</p><p>首先应该配置交换机这一端的接口，然后再在操作系统层面上配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从操作系统层面，要在eth0接口上启用jumbo贴</span></span><br><span class="line">ifconf eth0 mtu 9000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为了永久改变，也应该更新网络接口配置文件 /etc/sysconfig/network-script/ifcfg-eth0为MTU=9000</span></span><br></pre></td></tr></table></figure><h5 id="磁盘相关参数"><a href="#磁盘相关参数" class="headerlink" title="磁盘相关参数"></a>磁盘相关参数</h5><p><strong>disk read_ahead</strong></p><p>通过预读取数据并将其加载到RAM中加快磁盘的读操作</p><p>通过在使用RBD的Ceph客户端上给 <code>read_ahead</code> 设置一个相对较高的值有利于客户端执行<strong>顺序读</strong>操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/vda/queue/read_ahead_kb #查看当前read_ahead值</span><br><span class="line">echo &quot;8192&quot; &gt; /sys/block/vda/queue/read_ahead_kb # 修改</span><br></pre></td></tr></table></figure><p><strong>IO调度器</strong></p><p>Linux 内核支持多种I/O调度算法，包括 CFQ、Noop、Deadline等。根据不同的磁盘应用场景选择不同的 I/O调度算法可提升 I/O 性能。</p><p>I/O 调度算法的选择取决于硬件特性，也取决于应用场景。</p><ul><li>对于传统的 SAS 盘，CFQ、Deadline、Noop 算法都是不错的选择。</li><li>对于专属的数据库服务器，Deadline 算法在吞吐量和响应时间方面都表现自好。</li><li>然而在新兴的固态硬盘比如 SSD 上，最简单的 Noop 算法反而可能是最好的，因为其他两种算法的优化是基于缩短寻道时间，而固态硬盘没有所谓的寻道时间且 I/O 响应时间非常短。上面 3 种调度算法适用的场景如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查磁盘默认使用的调度器</span></span><br><span class="line">cat /sys/block/sda/queue/scheduler </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改磁盘sda默认的I/O调度器为 deadline</span></span><br><span class="line">echo deadline &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure><p><strong>deadline</strong> ：</p><p>好处是每个调度器使用单独的 IO 队列，因此与写相比，更利于读。这个调度器适用于大多数使用场景，尤其是读操作多于写操作的情况。</p><p>已经在队列中的I/O请求被分类到读和写批次，然后以 LBA 升序被调度执行</p><p>默认情况下，读批次的优先级高于写批次，因为应用程序更容易阻塞在读I/O上</p><p>适用场景：</p><ul><li>最大化吞吐量，良好的响应时间</li></ul><div class="table-container"><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td>fifo_batch</td><td>一次批处理的大小</td></tr><tr><td>front_merges</td><td>是否进行前向合并</td></tr><tr><td>read_expire</td><td>读请求超时时间</td></tr><tr><td>write_expire</td><td>写请求超时时间</td></tr><tr><td>writes_starved</td><td>写请求被“饿死”的次数</td></tr></tbody></table></div><p><strong>CFQ(completely fair queuing)</strong></p><p>完全公平队列调度器。只适用于SATA磁盘。CFQ调度器将进程划分为三大类</p><ul><li>real time：实时的</li><li>bets effort：尽力而为的。进程默认类型</li><li>idle：闲时调用的</li></ul><p>适用：</p><ul><li>不适合SSD，对于SAS或SATA且I/O请求较多，需要均衡调度时使用</li></ul><p><strong>Noop</strong></p><p>FIFO调度器，通过 last-hit（最后命中）缓存，请求在通用块层中被合并。</p><p>对于使用快速存储的计算密集型系统来说，最好的调度器</p><ul><li>对于SSD ，NOOP I/O调度器可以减少延迟，增加吞吐量，消除CPU花费在重新排序IO请求上的时间</li></ul><p><strong>IO调度队列</strong></p><p>IO Scheduler queue（调度队列）缺省的IO调度队列大小为128</p><p>调度队列对IO进行排序，并通过对顺序IO进行优化减少寻道到时间</p><p>修改调度队列深度，可以增加磁盘执行顺序IO的比例，提高整体吞吐量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查设备的调度器深度</span></span><br><span class="line">cat /sys/block/sda/queue/nr——requests</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改设备调度器深度</span></span><br><span class="line">echo1024 &gt; /sys/block/sda/queue/nr_requests</span><br></pre></td></tr></table></figure><h4 id="集群配置文件"><a href="#集群配置文件" class="headerlink" title="集群配置文件"></a>集群配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph config show-with-defaults mon.mon01 | awk &#x27;&#123;print $1,&quot;=&quot;, $2&#125;&#x27; &gt; Octopus_conf.txt # 获取全部参数</span><br></pre></td></tr></table></figure><p>大部分作用域整个集群范围的配置都是在Ceph集群配置文件/etc/ceph/ceph.conf中定义的。</p><p><img src="/posts/1081161349/image-20231112105713394.png" alt="image-20231112105713394"></p><p><strong>全局段</strong></p><p>定义在 <code>[global]</code> 后的段，在这个段设置会影响Ceph集群的所有守护进程，如客户端网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public network = 192.168.0.0/24</span><br></pre></td></tr></table></figure><p><strong>mon段</strong></p><p>在 <code>[mon]</code> 段设置的参数只会影响Ceph集群内所有的mon守护进程，且会覆盖掉 <code>[global]</code> 段相同的参数</p><p>同时，也可使用 <code>[mon.MON_ID]</code> 来为每个mon指定配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon initial members = ceph-mon1</span><br></pre></td></tr></table></figure><p><strong>OSD段</strong></p><p>在 <code>[OSD]</code> 段设置的参数只会影响Ceph集群内所有的OSD守护进程，且会覆盖掉 <code>[global]</code> 段相同的参数</p><p>同时，也可使用 <code>[osd.OSD_ID]</code> 来为单个OSD指定配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd mkfs type = xfs</span><br></pre></td></tr></table></figure><p><strong>MDS段</strong></p><p>在 <code>[MDS]</code> 段设置的参数只会影响Ceph集群内所有的OSD守护进程，且会覆盖掉 <code>[global]</code> 段相同的参数</p><p>同时，也可使用 <code>[mds.MDS_ID]</code> 来为单个MDS指定配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mds cache size = 250000</span><br></pre></td></tr></table></figure><p><strong>client段</strong></p><p>在 <code>[client]</code> 段设置的参数只会影响Ceph集群内所有的OSD守护进程，且会覆盖掉 <code>[global]</code> 段相同的参数</p><p>同时，也可使用 <code>[client.client_name]</code> 来为单个client指定配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd cache = true</span><br></pre></td></tr></table></figure><h4 id="全局调优参数"><a href="#全局调优参数" class="headerlink" title="全局调优参数"></a>全局调优参数</h4><p><strong>网络</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public network = &#123;public network / netmask&#125; #公共网络/客户端网络</span><br><span class="line"></span><br><span class="line">cluster network = &#123;cluster network / netmask&#125; #集群网络/内部网络</span><br></pre></td></tr></table></figure><p><strong>最大文件打开数</strong></p><p>在操作系统层面设置最大文件打开描述符，避免OSD进程出现文件描述符不足的情况</p><p>默认为0，最多设置64位的整数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max open files = 1111</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认0，推荐：131072</span></span><br></pre></td></tr></table></figure><p><strong>pg、pgp数确定</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">osd pool default pg num = 128</span><br><span class="line">osd pool default pgp num = 128</span><br></pre></td></tr></table></figure><p><strong>处于degraded状态的副本数</strong></p><p>Ceph向客户端发送确认写操作前，存储池中object的最小副本数（必须&lt;pg-num、pgp-num）。即使集群处于degraded状态。</p><p>若副本数小于参数值，则不会确认写操作给客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd pool default min size=1</span><br></pre></td></tr></table></figure><p><strong>默认rule ID</strong></p><p>创建存储池时，缺省则使用CRUSH ruleset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd pool default crush rule = 0</span><br></pre></td></tr></table></figure><p><strong>disbale in-Memory logs</strong></p><p>每个Ceph子系统都有自己的输出日志级，并记录在内存中</p><p>通过debug logging设置一个log文件等级和内存等级（1-20，轻量级-重量级）</p><p>格式：<code>debug&lt;subsystem&gt; = &lt;log-level&gt;/&lt;memory&gt;</code></p><p>若内存级别日志影响了性能和内存消耗。可以尝试关闭该功能，要禁用 <code>in-memory logging</code> 添加参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">debug lockdep=0/0</span><br><span class="line">debug context = 0/0</span><br><span class="line">debug crush=0/0</span><br><span class="line">debug buffer=0/0</span><br><span class="line">debug timer=0/0</span><br><span class="line">debug_filer=0/0</span><br><span class="line">debug objecter=0/0</span><br><span class="line">debug_rados=0/0</span><br><span class="line">debug rbd=0/0</span><br><span class="line">debug_journaler=0/0</span><br><span class="line">debug_objectcatcher =0/0</span><br><span class="line">debug_client=0/0</span><br><span class="line">debug osd=0/0</span><br><span class="line">debug_optracker= 0/0</span><br><span class="line">debug_objclass=0/0</span><br><span class="line">debug_filestore= 0/0</span><br><span class="line">debug_journal=0/0</span><br><span class="line">debug ms=0/0</span><br><span class="line">debug_monc=0/0</span><br><span class="line">debug_tp=0/0</span><br><span class="line">debug auth=0/0</span><br><span class="line">debug_finisher=0/0</span><br><span class="line">debug heartbeatmap = 0/0</span><br><span class="line">debug_perfcounter = 0/0</span><br><span class="line">debug_asok=0/0</span><br><span class="line">debug throttle=0/0</span><br><span class="line">debug mon=0/0</span><br><span class="line">debug_paxos=0/0</span><br><span class="line">debug_rgw=0/0</span><br></pre></td></tr></table></figure><h4 id="mon调优"><a href="#mon调优" class="headerlink" title="mon调优"></a>mon调优</h4><p><strong>指定OSD进程多少秒未响应后标记为down或out状态</strong></p><p>当OSD节点崩溃、自行重启或者短时间的网络故障时，会用到此参数</p><p>即不想让集群在问题出现时就立刻启动数据平衡操作，尝试等待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mon_osd_down_out_interval=</span><br><span class="line">默认300，推荐600</span><br></pre></td></tr></table></figure><p><strong>避免Ceph存储池以外删除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon_allow_pool_delete = false</span><br></pre></td></tr></table></figure><p><strong>mon间的clock drift</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mon clock drift allowed = </span><br><span class="line">默认0.05</span><br><span class="line">推荐1</span><br></pre></td></tr></table></figure><p><strong>OSD down上报次数</strong></p><p>如果Ceph OSD守护进程监控的OSD down了，它就会向 MON 报告</p><p>缺省值为 1，表示仅报告一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon_osd_min_down_reporters = 3 </span><br></pre></td></tr></table></figure><h4 id="OSD调优参数"><a href="#OSD调优参数" class="headerlink" title="OSD调优参数"></a>OSD调优参数</h4><h5 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h5><p><strong>OSDping mon的时间间隔</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_mon_heartbeat_interval=</span><br><span class="line">默认30</span><br><span class="line">建议40</span><br></pre></td></tr></table></figure><p><strong>OSD map的缓存大小，MB</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_map_cache_size = &lt;numeric&gt;</span><br><span class="line">默认500</span><br><span class="line">推荐1024</span><br></pre></td></tr></table></figure><p><strong>内存中允许的OSD map缓存大小，以MB为单位</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_map_cache_bl_size = &lt;numeric&gt;</span><br><span class="line">默认50</span><br><span class="line">推荐128</span><br></pre></td></tr></table></figure><p><strong>创建xfs文件系统</strong></p><p>创建OSD的时候，Ceph 将使用这些 xfs 选项来创建OSD的文件系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_mkfs_options_xfs =&quot;-f -i size=2048&quot;</span><br></pre></td></tr></table></figure><p><strong>挂载xfs文件系统</strong></p><p>设置挂载文件系统到OSD的选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_mount_options_xfs = &quot;rw,noatime,inode64,logbufs=8logbsize=256k,delaylog,allocsize=4M&quot;</span><br></pre></td></tr></table></figure><p><strong>OSD单次写大小，MB</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_max_write_size = 256</span><br></pre></td></tr></table></figure><p><strong>内存允许的最大客户端数据大小，B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_client_message_size_cap=1073741824</span><br></pre></td></tr></table></figure><p><strong>删除OSD map中的重复项</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_map_dedup = true</span><br></pre></td></tr></table></figure><p><strong>设置服务于OSD进程操作的线程数</strong></p><p>默认0</p><p>越大，处理速率越快</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_op_threads=16</span><br><span class="line">默认2</span><br><span class="line">建议16</span><br></pre></td></tr></table></figure><p><strong>执行清理、快照等磁盘密集型操作的磁盘线程数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_disk_threads = 1</span><br><span class="line">默认1</span><br><span class="line">建议4</span><br></pre></td></tr></table></figure><p><strong>修改磁盘线程的IO调度类型，只工作在Linux内核CFQ调度器上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_disk_thread_ioprio_class=idle</span><br></pre></td></tr></table></figure><ul><li>idle：（闲时调用）磁盘线程的优先级比OSD的其他线程低。加快处理客户端请求，放缓OSD上的清理(scrubbing)</li><li>be：（尽力，best effort）磁盘线程与OSD其他线程有相同优先级</li><li>rt：（实时,real time）磁盘线程的优先级比OSD其他线程高。加快 OSD上的清理(scrubbing)，放缓处理客户端请求</li></ul><p><strong>修改磁盘线程的IO调度优先级（0-7，最高-最低）</strong></p><p>与 <code>osd_disk_thread_ioprio_class</code> 配合使用</p><p>若主机的所有OSD都处于idle，都在竞争IO，这个参数可以用来将一个OSD的磁盘线程优先级降为7，让另一个优先级为0的OSD更快清理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_disk_thread_ioprio_priority=0</span><br></pre></td></tr></table></figure><h5 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h5><p><strong>日志大小</strong></p><p>设置日志分区大小，至少是预期磁盘速度和filestore最大同步时间间隔的两倍。</p><p>若用了SSD日志，最好创建大于10GB的日志，并调大filestore的最小、最大同步时间间隔</p><ul><li><code>filestore_min_sync_interval</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_journal_size=20480</span><br></pre></td></tr></table></figure><p><strong>单次写日志的最大比特数/条目数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#单次写日志的最大比特数</span><br><span class="line">journal_max_write_byte = &lt;numeric&gt;</span><br><span class="line"></span><br><span class="line">#单次写日志的最大条目数</span><br><span class="line">journal_max_write_entries = &lt;numeric&gt;</span><br></pre></td></tr></table></figure><p><strong>日志队列允许的最大op数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journal_queue_max_ops = &lt;numeric&gt;</span><br></pre></td></tr></table></figure><p><strong>日志队列允许的最大btyes</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journal_queue_max_bytes = &lt;numeric&gt;</span><br></pre></td></tr></table></figure><p><strong>启用direct i/o到日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journal_dio = true</span><br></pre></td></tr></table></figure><p><strong>启用libaio异步写日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journal_aio=true</span><br></pre></td></tr></table></figure><p><strong>日志块写操作对齐</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需要配置dio和aio</span><br><span class="line">journal_block_align = true</span><br></pre></td></tr></table></figure><h5 id="filestore设置"><a href="#filestore设置" class="headerlink" title="filestore设置"></a>filestore设置</h5><p><strong>libaio异步写日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_merge_threshold = 40</span><br></pre></td></tr></table></figure><p><strong>子目录在分裂成二级目录前的最大文件数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_split_multiple = &lt;numeric&gt;</span><br></pre></td></tr></table></figure><p><strong>并行执行的文件系统操作线程个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_op_threads = 32</span><br></pre></td></tr></table></figure><p><strong>etx4文件系统使用的XATTRS</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_xattr_use_omap= true</span><br></pre></td></tr></table></figure><p><strong>设置日志同步数据的提交点</strong></p><p>从日志中同步数据到数据盘，然后清理日志。filestore需要停止写操作来执行 syncfs() 。</p><p>更加频繁地同步操作，可以减少存储在日志中的数据量</p><p>配置一个越小的同步值，越有利于文件系统合并小量的写，提升性能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filestore_min_sync_interval=10</span><br><span class="line">filestore_max_sync_interval=15</span><br></pre></td></tr></table></figure><p><strong>filestore队列能接收的最大op数</strong></p><p>超过filestore设置的最大op数，会阻塞新的op加入filestore队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_queue_max_ops =2500</span><br></pre></td></tr></table></figure><p><strong>filestore一个op的最大比特数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_queue_max_bytes=10485760</span><br></pre></td></tr></table></figure><p><strong>filestore能提交的op的最大个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_queue_committing_max_ops = 5000</span><br></pre></td></tr></table></figure><p><strong>filestore能提交的op的最大比特数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filestore_queue_committing_max_bytes=10485760000</span><br></pre></td></tr></table></figure><h5 id="BlueStore"><a href="#BlueStore" class="headerlink" title="BlueStore"></a>BlueStore</h5><p>使用 BlueStore 相比使用Filestore 会带来更高的性能提升。针对 BlueStore，我们有很多可以进行优化的参数</p><p><strong>rocksdb和 wal</strong></p><ul><li>具体数值根据实际情况而定，不能一概而论。这需要在系统部署时候规划好，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bluestore_block_db_size</span><br><span class="line">bluestore_block_wal_size</span><br></pre></td></tr></table></figure><p><strong>Allocation Size</strong></p><p>在混合工作负载条件下，调整 alloc_size 会略微提高小型对象的写入性能。</p><p>将 alloc_size 减小到 4KB 有助于减少对小型对象的写入放大</p><p>但此更改需要在 OSD 部署之前完成。如果部署之后更改，必须重新部署 OSD，以使其生效。建议机械盘设置为64KB，SSD/NVMe设置为4KB。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min_alloc_size_ssd = 4096</span><br><span class="line">min_alloc_size_hdd = 6</span><br></pre></td></tr></table></figure><h5 id="recovery设置"><a href="#recovery设置" class="headerlink" title="recovery设置"></a>recovery设置</h5><p>若Ceph集群健康状态不正常，OSD处于数据恢复状态则性能会降低。</p><p>若在recovery期间，仍期望得到更好的性能，可以降低数据恢复的优先级，使数据恢复占用OSD的资源更少</p><p><strong>每个OSD上同时进行恢复操作的最大PG数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_recovery_max_active=3</span><br><span class="line">默认15</span><br><span class="line">推荐10</span><br></pre></td></tr></table></figure><p><strong>OSD在某个时刻启动恢复操作的PG数</strong></p><p>与 <code>osd_recovery_max_active</code> 共同使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_recovery_max_single_start= 1</span><br></pre></td></tr></table></figure><p>OSD 在某个时刻会为一个PG启动一个恢复操作，而且最多可以有三个恢复操作同时处于活动状态</p><p><strong>OSD恢复操作的优先级</strong></p><p>配置恢复操作的优先级。值越小，恢复优先级越高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_recovery_op_priority = 50</span><br><span class="line">默认10</span><br><span class="line">推荐2</span><br></pre></td></tr></table></figure><p><strong>数据恢复块的最大值,B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_recovery_max_chunk = 1048576</span><br></pre></td></tr></table></figure><p><strong>恢复数据所需的线程数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recovery_threads =1</span><br></pre></td></tr></table></figure><h5 id="backfilling设置"><a href="#backfilling设置" class="headerlink" title="backfilling设置"></a>backfilling设置</h5><p>允许设置backfill操作的优先级比请求读写更低</p><p><strong>允许进/出单个OSD的最大backfill数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_max_backfills = 2</span><br><span class="line">默认10</span><br><span class="line">推荐4</span><br></pre></td></tr></table></figure><p><strong>每个backfill扫描的最小object数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_backfill_scan_min=8</span><br></pre></td></tr></table></figure><p><strong>每个backfill扫描的最大object 数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_backfill_scan_max=64</span><br></pre></td></tr></table></figure><h5 id="scrubbing设置"><a href="#scrubbing设置" class="headerlink" title="scrubbing设置"></a>scrubbing设置</h5><p>OSD scrubbing对维护数据完整性非常重要，但会降低OSD性能</p><p><strong>单个OSD进程最大的并行scrub数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_max_scrubs = 1</span><br></pre></td></tr></table></figure><p><strong>两个连续scrub之间的睡眠时间，s</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_scrub_sleep = 1</span><br></pre></td></tr></table></figure><p><strong>单个OSD执行scrub的最小/最大数据块数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">osd_scrub_chunk_min = 1</span><br><span class="line">osd_scrub_chunk_max = 5</span><br></pre></td></tr></table></figure><p><strong>深层scrub时读大小，B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osd_deep_scrub_stride = 1048576</span><br><span class="line">默认524288</span><br><span class="line">建议：1311072</span><br></pre></td></tr></table></figure><p><strong>scrub的最早/最晚开始时间</strong></p><p>用于定义执行scrub的时间窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">osd_scrub_begin_hour = 19</span><br><span class="line">osd_scrub_end_hour = 7</span><br></pre></td></tr></table></figure><h4 id="RGW参数"><a href="#RGW参数" class="headerlink" title="RGW参数"></a>RGW参数</h4><h4 id="FS参数"><a href="#FS参数" class="headerlink" title="FS参数"></a>FS参数</h4><h4 id="RBD参数"><a href="#RBD参数" class="headerlink" title="RBD参数"></a>RBD参数</h4><p>用户空间实现的块设备不能很好利用Linux页面缓存，因此Ceph引入了新的内存缓存机制，称为RBD缓存</p><p>默认情况下，Ceph没有启用RBD缓存</p><p>若要启用RBD缓存，在ceph.conf中的 <code>[client]</code> 段添加内容</p><p><strong>启用RBD缓存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_cache = true</span><br></pre></td></tr></table></figure><p><strong>一开始使用写直达模式(write-through)，第一次flush请求被接收后切换到写回式(write-back)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_cache_writethrough_until_flush = true</span><br></pre></td></tr></table></figure><p><strong>rbd缓存大小，B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_cache_size = 67108864</span><br></pre></td></tr></table></figure><p><strong>缓存开始写数据到后端存储前，脏数据大小的目标值，B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_cache_target_dirty = 33554432 #32M</span><br></pre></td></tr></table></figure><p><strong>缓存触发writeback的字节上限数,B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_cache_max_dirty = &lt;numeric&gt;</span><br></pre></td></tr></table></figure><ul><li>若设置为0，则Ceph使用的缓存模式是写直达</li><li>若不设置该属性，则默认写回模式</li></ul><p><strong>writeback开始前， 脏数据在缓存中存在的秒数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_cache_max_dirty_age = &lt;numeric&gt;</span><br></pre></td></tr></table></figure><p><strong>rbd的默认创建类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_default_format = 2</span><br></pre></td></tr></table></figure><p><strong>在rbd上执行的并发管理操作数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd_concurrent_management_ops=10</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/1081161349/" title="6.性能调优">https://amostian.github.io/posts/1081161349/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 存储</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 分布式存储</a> <a href="/tags/Ceph/" rel="tag"><i class="fa fa-tags"></i> Ceph</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/30934922/" rel="prev" title="5.存储配置"><i class="fa fa-chevron-left"></i> 5.存储配置</a></div><div class="post-nav-item"><a href="/posts/3815159323/" rel="next" title="7.基准测试与性能数据监控">7.基准测试与性能数据监控 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="nav-text">6.1 存储系统的典型场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%88%90%E6%9C%AC"><span class="nav-text">6.1.1 性能与成本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%E4%BD%8E%E6%88%90%E6%9C%AC%E5%86%B7%E5%AD%98%E5%82%A8"><span class="nav-text">6.1.2 低成本冷存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B7%E5%AD%98%E5%82%A8%E9%9C%80%E6%B1%82%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-text">冷存储需求和意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B7%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1"><span class="nav-text">冷存储设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6"><span class="nav-text">硬件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6"><span class="nav-text">软件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A0%E5%88%A0%E7%A0%81"><span class="nav-text">纠删码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%A0%E5%88%A0%E7%A0%81%E5%8E%9F%E7%90%86"><span class="nav-text">纠删码原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%A0%E5%88%A0%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">纠删码分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%A0%E5%88%A0%E7%A0%81%E6%8F%92%E4%BB%B6"><span class="nav-text">纠删码插件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Ceph%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%A0%E5%88%A0%E7%A0%81%E6%B1%A0"><span class="nav-text">Ceph中创建纠删码池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B7%E5%AD%98%E5%82%A8%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"><span class="nav-text">冷存储发展方向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AD%98%E5%82%A8"><span class="nav-text">6.1.3 高性能存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6-1"><span class="nav-text">硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6-1"><span class="nav-text">软件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="nav-text">6.1.4 缓存方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6-2"><span class="nav-text">硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6-2"><span class="nav-text">软件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ceph-Cache-Tier"><span class="nav-text">Ceph Cache Tier</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%88%86%E5%B1%82%E6%A8%A1%E5%BC%8F"><span class="nav-text">缓存分层模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2Ceph-Cache-Tier"><span class="nav-text">部署Ceph Cache Tier</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Ceph%E6%80%A7%E8%83%BD"><span class="nav-text">6.2 Ceph性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">6.2.1 性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">集群性能指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%B1%A0%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">存储池性能指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%8A%82%E7%82%B9%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">存储节点性能指标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%96%B9%E5%90%91"><span class="nav-text">6.2.3 性能调优方向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IOPS%E4%BC%98%E5%8C%96"><span class="nav-text">IOPS优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%8C%96"><span class="nav-text">吞吐量优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F%E4%BC%98%E5%8C%96"><span class="nav-text">容量优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-text">6.3 性能调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E7%A1%AC%E4%BB%B6"><span class="nav-text">6.3.1 硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E5%AE%BD"><span class="nav-text">带宽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BD%91%E5%8D%A1%E8%81%9A%E5%90%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">多网卡聚合负载均衡</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98"><span class="nav-text">磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E9%80%9F"><span class="nav-text">转速</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#non-RAID"><span class="nav-text">non-RAID</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OSD%E6%97%A5%E5%BF%97"><span class="nav-text">OSD日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E5%8C%BA"><span class="nav-text">日志分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="nav-text">数据分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E8%BD%AF%E4%BB%B6"><span class="nav-text">6.3.2 软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-text">通用调优参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU-%E5%86%85%E5%AD%98%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0"><span class="nav-text">CPU&#x2F;内存——内核参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><span class="nav-text">内存调优</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98"><span class="nav-text">网络调优</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="nav-text">磁盘相关参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">集群配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-text">全局调优参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mon%E8%B0%83%E4%BC%98"><span class="nav-text">mon调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSD%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-text">OSD调优参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE"><span class="nav-text">常用设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AE%BE%E7%BD%AE"><span class="nav-text">日志设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#filestore%E8%AE%BE%E7%BD%AE"><span class="nav-text">filestore设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BlueStore"><span class="nav-text">BlueStore</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#recovery%E8%AE%BE%E7%BD%AE"><span class="nav-text">recovery设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#backfilling%E8%AE%BE%E7%BD%AE"><span class="nav-text">backfilling设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scrubbing%E8%AE%BE%E7%BD%AE"><span class="nav-text">scrubbing设置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RGW%E5%8F%82%E6%95%B0"><span class="nav-text">RGW参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FS%E5%8F%82%E6%95%B0"><span class="nav-text">FS参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RBD%E5%8F%82%E6%95%B0"><span class="nav-text">RBD参数</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">236</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1252.1k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">50:25</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>