<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="图这部分以概念为主，具体实现放到算法部分   参考：王道数据结构图部分"><meta property="og:type" content="article"><meta property="og:title" content="4.图"><meta property="og:url" content="https://amostian.github.io/posts/3274436167/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="图这部分以概念为主，具体实现放到算法部分   参考：王道数据结构图部分"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220202160808860.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220202162507405.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220202161754637.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220203092557809.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220203100509705.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220203105107942.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220203114520778.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220203194113442.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220204093950252.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220204102546195.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220204130557372.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220204144101317.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220204144618301.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220204144639377.png"><meta property="og:image" content="https://amostian.github.io/posts/3274436167/image-20220204154335077.png"><meta property="article:published_time" content="2024-01-26T10:50:57.956Z"><meta property="article:modified_time" content="2023-03-22T15:06:53.768Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="计算机基础"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/3274436167/image-20220202160808860.png"><link rel="canonical" href="https://amostian.github.io/posts/3274436167/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>4.图 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">58</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">74</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">363</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/3274436167/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">4.图</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-01-26 18:50:57" itemprop="dateCreated datePublished" datetime="2024-01-26T18:50:57+08:00">2024-01-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2023-03-22 23:06:53" itemprop="dateModified" datetime="2023-03-22T23:06:53+08:00">2023-03-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">4.2k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>图这部分以概念为主，具体实现放到算法部分</p><p>参考：王道数据结构图部分</p></blockquote><span id="more"></span><h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><blockquote><p>不存在空图</p><ul><li><p>顶点集一定非空</p></li><li><p>边集可以为空</p></li></ul></blockquote><p>图和树是逻辑上的区别，都是 <strong>逻辑结构</strong></p><h3 id="4-1-1-顶点的度"><a href="#4-1-1-顶点的度" class="headerlink" title="4.1.1 顶点的度"></a>4.1.1 顶点的度</h3><script type="math/tex;mode=display">\begin{cases}
无向图\\
&\sum_{i=1}^nTD(v_i)=2e \\
有向图\\ &\sum_{i=1}^nTD(v_i)=\sum_{i=1}^nID(v_i)+\sum_{i=1}^nOD(v_i)\\
&\sum_{i=1}^{n}ID(v_i)=\sum_{i=1}^nOD(v_i)=e
\end{cases}</script><h3 id="4-1-2-图的种类"><a href="#4-1-2-图的种类" class="headerlink" title="4.1.2 图的种类"></a>4.1.2 图的种类</h3><h4 id="1-简单图"><a href="#1-简单图" class="headerlink" title="1. 简单图"></a>1. 简单图</h4><ul><li>$v_i \rightarrow v_j$ 间无重复边</li><li>任一顶点无自身到自身的顶点</li></ul><h4 id="2-n个顶点的完全图"><a href="#2-n个顶点的完全图" class="headerlink" title="2. n个顶点的完全图"></a>2. n个顶点的完全图</h4><script type="math/tex;mode=display">\begin{cases}
无向图\\
&\frac{n(n-1)}{2}条边 \\
有向图\\ 
&n(n-1)条边
\end{cases}</script><div style="page-break-after:always"></div><h4 id="3-子图"><a href="#3-子图" class="headerlink" title="3. 子图"></a>3. 子图</h4><blockquote><p>顶点集为图G的子集</p></blockquote><ul><li>并非所有的顶点子集与边子集的组合都是图G的子图</li><li>任一条边及其两个端点都在的边集与顶点集的组合才构成子图</li></ul><h4 id="4-连通图-无向图"><a href="#4-连通图-无向图" class="headerlink" title="4. 连通图[无向图]"></a>4. 连通图[无向图]</h4><p>无向图连通：顶点 $v\rightarrow w$ 直接有路径</p><blockquote><p>图 G 中任两顶点间都连通</p><ul><li>一点可以访问全部</li><li>若边数小于n-1，则一定是非连通图</li></ul></blockquote><ol><li>连通分量：<strong>无向图</strong>中极大连通子图</li><li>生成树：<strong>连通图</strong> 的包含所有结点的极小连通子图<ul><li>包含n-1条边，n个顶点</li><li>加一条边构成回路，减一条边为非连通图</li></ul></li><li>生成森林：<strong>非连通图</strong> 的多个连通分量生成的多个树构成的森林</li></ol><h4 id="5-路径-amp-完全图"><a href="#5-路径-amp-完全图" class="headerlink" title="5. 路径&amp;完全图"></a>5. 路径&amp;完全图</h4><h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><blockquote><p>$v_p \rightarrow v_q$ 之间的顶点序列</p></blockquote><ul><li>路径长度：路径中的顶点个数</li><li>距离：$v_p \rightarrow v_q$ 的最短路径长度</li><li>简单路径：顶点不重复</li></ul><blockquote><p>回路、环：起点和终点 ($v_p == v_q$) 相同的路径</p></blockquote><ul><li>简单回路：除首尾顶点不重复的路径</li><li>有拓扑序列的图一定无环</li></ul><h5 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h5><p>已知有n个顶点，确保连通的的最小边数为：n-1个顶点的完全图的边数+1,$\frac{(n-1)(n-2)}{2}+1$</p><p>已知有n条边，组成非连通图的顶点数为：k个顶点组成完全图+1,$\frac{k(k-1)}{2}+1\Rightarrow \lceil \sqrt{2n} \rceil+1$</p><h4 id="6-强连通图-有向图"><a href="#6-强连通图-有向图" class="headerlink" title="6. 强连通图[有向图]"></a>6. 强连通图[有向图]</h4><p>有向图连通：$v \rightleftarrows w$ ，双向连通</p><blockquote><p>每对顶点间有 <strong>路径</strong></p></blockquote><ul><li>不是每对顶点间都有 <strong>弧</strong></li></ul><ol><li><p>强连通分量</p><p>有向图中的极大强连通图</p></li><li><p><em>有向完全图一定是强连通图</em></p></li></ol><div style="page-break-after:always"></div><h2 id="4-2-图的存储"><a href="#4-2-图的存储" class="headerlink" title="4.2 图的存储"></a>4.2 图的存储</h2><h3 id="4-2-1-邻接矩阵法"><a href="#4-2-1-邻接矩阵法" class="headerlink" title="4.2.1 邻接矩阵法"></a>4.2.1 邻接矩阵法</h3><h4 id="1-规则"><a href="#1-规则" class="headerlink" title="1. 规则"></a>1. 规则</h4><ol><li>表示</li></ol><script type="math/tex;mode=display">\begin{cases}
无权图 &取0或1 \\
带权图 &w_{ij}或0或\infty
\end{cases}</script><ol><li><p>无向图</p><ul><li><p>邻接矩阵对称且唯一</p></li><li><p>可进行压缩存储，只存放上(下)三角矩阵元素</p><p>对称矩阵默认为无向图</p></li><li><p>第i行(列)非零元素个数= $v_i$ 的出度OD( $v_i$ )或者入度ID( $v_i$ )</p></li></ul></li><li><p>有向图</p><ul><li>第i行非零且非 $\infty$ 的元素个数为顶点 $v_i$ 的出度</li><li>第i列非零且非 $\infty$ 的元素个数为顶点 $v_i$ 的入度</li></ul></li></ol><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ol><li><p>适用于 <em>稠密图</em> 存储</p></li><li><p>空间复杂度为 $O(\mid v\mid^2)$</p></li><li><p>确定两点之间是否有边 $O(1)$ ——数组的随机存取特性</p><p>确定图中边数 $O(\mid v\mid^2)$</p></li><li><p>某个顶点出度越大，则存储矩阵的行非零元素越多</p></li><li><p>图G的邻接矩阵为A，则$A^n[i][j]$ 表示从 $v_i \rightarrow v_j$ 的长度为n的路径数量</p></li></ol><div style="page-break-after:always"></div>#### 3. 表示<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VexType Vex[MaxVertexNum];<span class="comment">//顶点集</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵表示边集</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>#### 4. 有向无环图的矩阵表示 > 有向无环图：非零元素集中在上三角或下三角区域，其对称区域全为0 - 图中比不存在环 - 一定存在拓扑序列但不唯一 上三角：出度大编号小 下三角：入度大编号小 ### 4.2.2 邻接表法 邻接表法：只存出度 逆邻接表法：只存入度 > 邻接表：每个顶点 v 建立相应的边表 > > - 顶点头指针(**顺序存储**) ：顶点头指针为边链表的头指针，指向与 $v_i$ 关联的首条边 > > - 边信息(**单链表**) > > 无向图：依附于 $v_i$ 的边 > > 有向图：以 $v_i$ 为尾的弧<div style="page-break-after:always"></div><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><ol><li><p>适用于 <em>稀疏图</em></p></li><li><p>邻接表 <em>不唯一</em></p><p>同一顶点的边结点连接顺序不唯一，取决于建立边表的算法及边的输入序列</p></li><li><p>存储空间</p><p>无向图：$O(\mid v\mid+2\mid e\mid)$</p><p>有向图：$O(\mid v\mid+\mid e\mid)$</p></li><li><p>时间复杂度</p><p>找所有邻边：读顶点的边表——$O(n)$</p><p>确定边是否存在：扫一个端点的边表—— $O(n)$</p></li><li><p>有向图某顶点的度</p><p>出度：邻接表中结点个数</p><p>入度：需遍历全部邻接表</p></li></ol><h4 id="2-表示"><a href="#2-表示" class="headerlink" title="2. 表示"></a>2. 表示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VexType data;</span><br><span class="line">    ArcNode *firstArc;</span><br><span class="line">&#125;VNode,AdList[MaxVertexNum];<span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//邻接点域</span></span><br><span class="line">    <span class="type">double</span> weigh;<span class="comment">//边表权值</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextArc;<span class="comment">//邻接顶点</span></span><br><span class="line">&#125;ArcNode;<span class="comment">//边表结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> vexnum;</span><br><span class="line">    <span class="type">int</span> arcnum;</span><br><span class="line">    AdList vertices;<span class="comment">//顶点头指针</span></span><br><span class="line">&#125;AGraph;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><p><img src="/posts/3274436167/image-20220202160808860.png" alt></p><h3 id="4-2-3-邻接多重表"><a href="#4-2-3-邻接多重表" class="headerlink" title="4.2.3 邻接多重表"></a>4.2.3 邻接多重表</h3><blockquote><p><strong>无向图的存储结构</strong></p></blockquote><p><img src="/posts/3274436167/image-20220202162507405.png" alt></p><div style="page-break-after:always"></div><h3 id="4-2-4-十字链表法"><a href="#4-2-4-十字链表法" class="headerlink" title="4.2.4 十字链表法"></a>4.2.4 十字链表法</h3><blockquote><p><strong>有向图的存储结构</strong></p></blockquote><p><img src="/posts/3274436167/image-20220202161754637.png" alt></p><h2 id="4-3-图的基本操作"><a href="#4-3-图的基本操作" class="headerlink" title="4.3 图的基本操作"></a>4.3 图的基本操作</h2><blockquote><p>独立于存储结构</p><p>参数相同；实现不同，性能不同</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Adjacent(G,x,y);<span class="comment">//x与y之间是否存在边</span></span><br><span class="line">Neighbors(G,x);<span class="comment">//x的邻接边</span></span><br><span class="line">FirstNeighbor(G,x);<span class="comment">//G中x的第一个邻接点</span></span><br><span class="line">NextNerghbor(G,x,y);<span class="comment">//G中除x的下一个邻接点</span></span><br><span class="line"></span><br><span class="line">InsertVertex(G,x);<span class="comment">//插入点</span></span><br><span class="line">DeleteVertex(G,x);<span class="comment">//删除点</span></span><br><span class="line"></span><br><span class="line">AddEdge(G,x,y);<span class="comment">//新增边</span></span><br><span class="line">RemoveEdge(G,x,y);<span class="comment">//移除边</span></span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><p>已知n个顶点的图，其邻接矩阵表示为MGraph，邻接表表示为LGraph</p><ol><li><p>判别图中边数 n(e)</p><p>n(x)：表示x的个数</p></li></ol><div class="table-container"><table><thead><tr><th></th><th>无向图</th><th>有向图</th></tr></thead><tbody><tr><td>MGraph</td><td>$n(e)=\frac{n(1)}{2}$</td><td>$n(e)=n(1)$</td></tr><tr><td>LGraph</td><td>$n(e)=\frac{n(eNode)}{2}$</td><td>$n(eNode)$</td></tr></tbody></table></div><ol><li>判断两点是否连通</li></ol><div class="table-container"><table><thead><tr><th>MGraph</th><th>$MGraph[i][j] \overset{?}{=}1$</th><th>$O(1)$</th></tr></thead><tbody><tr><td>LGraph</td><td>遍历顶点i的邻接表</td><td>$O(e)$</td></tr></tbody></table></div><ol><li>度的计算</li></ol><div class="table-container"><table><thead><tr><th></th><th>无向图</th><th>有向图</th></tr></thead><tbody><tr><td>MGraph</td><td>$2*第 i 行 ‘1’ 的个数$</td><td>出度：第 i 行 ‘1’ 的个数<br>入度：第 i 列 ‘1’ 的个数</td></tr><tr><td>LGraph</td><td>n(eNode)</td><td>$出度：表头为 i 的单链表中 eNode 的个数$<br>$入度：边表中 i 的个数$</td></tr></tbody></table></div><div style="page-break-after:always"></div><h2 id="4-3-图的遍历"><a href="#4-3-图的遍历" class="headerlink" title="4.3 图的遍历"></a>4.3 图的遍历</h2><blockquote><p>从某一顶点出发，沿图中的边对图中所有顶点访问且只访问一次</p></blockquote><ul><li><p>遍历与经过的区别</p><p>从某一点出发经过图中所有结点 $\neq$ 遍历：每个结点不重复的访问一次</p></li><li><p>对每个顶点查找邻接点的过程取决于存储结构</p><p>矩阵： $O(\mid v\mid^2)$</p><p>邻接表：$O(\mid e\mid)$</p></li><li><p>树是一种特殊的图</p></li></ul><h3 id="4-3-1-广度优先搜索"><a href="#4-3-1-广度优先搜索" class="headerlink" title="4.3.1 广度优先搜索"></a>4.3.1 广度优先搜索</h3><blockquote><p>从某一顶点 v 开始，由近到远访问和 v 有路径长度为1,2,3….的顶点</p><ul><li>逐层访问，故需要借助队列</li></ul></blockquote><h4 id="1-实现"><a href="#1-实现" class="headerlink" title="1. 实现"></a>1. 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visted[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vernum;++i)</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            <span class="built_in">BFS</span>(G,i);<span class="comment">//使用for循环确保每个连通分量都被访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">	<span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);<span class="comment">//顶点v入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);</span><br><span class="line">        <span class="keyword">for</span>(w = <span class="built_in">FirstNeighbor</span>(G,v);w &gt;= <span class="number">0</span>;</span><br><span class="line">            				w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">            <span class="comment">//检测v的所有邻接点w</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为v尚未访问的邻接点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = TRUE;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2. 性能分析"></a>2. 性能分析</h4><ol><li><p>空间复杂度</p><p>$O(\mid v\mid)$</p></li><li><p>时间复杂度[与采取的存储方式有关]</p><ul><li><p>邻接矩阵 $O(\mid v\mid^2)$</p></li><li><p>邻接表 $O(\mid v\mid+\mid e\mid)$</p><p>顶点入队 $O(\mid v\mid)$</p><p>搜索所有邻接点，访问边 $O(\mid e\mid)$</p></li></ul></li></ol><h4 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h4><ol><li><p>求 $u \rightarrow v$ 路径长度最小的路径</p></li><li><p>无权图求单源点最短路径</p><div style="page-break-after:always"></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_Min_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="comment">//d[i]表示从u到i的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">        d[i] = INFINITE;</span><br><span class="line">    visited[u] = TRUE;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,u);<span class="comment">//BFS算法主过程</span></span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G,u);w &gt;= <span class="number">0</span>;</span><br><span class="line">           			w = NextNeighbor(G,u,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">				visited[w] = TRUE;<span class="comment">//设已访问标记</span></span><br><span class="line">                d[w] = d[u]+<span class="number">1</span>;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>广度优先生成树</p><p>邻接矩阵：表示法唯一 $\Longrightarrow$ 生成树唯一</p><p>邻接表：表示法不唯一 $\Longrightarrow$ 生成树不唯一</p></li></ol><h3 id="4-3-2-深度优先搜索"><a href="#4-3-2-深度优先搜索" class="headerlink" title="4.3.2 深度优先搜索"></a>4.3.2 深度优先搜索</h3><script type="math/tex;mode=display">\begin{cases}
& 图的邻接矩阵唯一 \Longrightarrow 基于邻接矩阵的DFS、BFS序列唯一 \\
& 图的邻接表不唯一\Longrightarrow 基于邻接表的DFS、BFS序列不唯一
\end{cases}</script><p>DFS——递归算法，用一个递归工作栈，空间复杂度 $O(\mid v\mid)$</p><p>性能分析</p><ul><li><p>时间复杂度</p><p>邻接矩阵 $O(\mid v\mid^2)$</p><p>邻接表 $O(\mid v\mid+\mid e\mid)$</p></li><li><p>空间复杂度</p><p>$O(\mid v\mid)$</p></li></ul><div style="page-break-after:always"></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.vexnum;++v) <span class="comment">//初始化</span></span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.vexnum;++v)<span class="comment">//遍历所有连通分量</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = TRUE;<span class="comment">//访问v并做标记</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G,v);w &gt;= <span class="number">0</span>;</span><br><span class="line">        			w = NextNeighbor(G,v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS(G,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-图的遍历与连通性"><a href="#4-3-3-图的遍历与连通性" class="headerlink" title="4.3.3 图的遍历与连通性"></a>4.3.3 图的遍历与连通性</h3><ol><li><p>连通</p><ul><li>无向图：从某一顶点 v 出发，一次遍历可访问图中所有顶点</li><li>有向图：初始点到图中每个顶点都有路径</li></ul></li><li><p>连通分量个数</p></li></ol><ul><li><code>DFSTraverse</code> / <code>BFSTraverse</code> 中调用 <code>DFS</code> / <code>BFS</code> 次数为连通分量数</li></ul><ol><li><p>对一个有向无环图，<code>DFSTraverse</code> 的退栈序列就是一个拓扑序列</p><p><img src="/posts/3274436167/image-20220203092557809.png" alt></p></li></ol><div style="page-break-after:always"></div><h2 id="4-4-应用"><a href="#4-4-应用" class="headerlink" title="4.4 应用"></a>4.4 应用</h2><h3 id="4-4-1-最小生成树"><a href="#4-4-1-最小生成树" class="headerlink" title="4.4.1 最小生成树"></a>4.4.1 最小生成树</h3><blockquote><ol><li><p>边数 = 顶点数 - 1</p></li><li><p>带权连通图权值和最小</p><p>最小权值和唯一，但树形不唯一</p><p>若各边权值互不相等，则树形唯一</p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Generate_MST(Graph G)&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> T未形成树</span><br><span class="line">        <span class="keyword">do</span> 找最小代价边(u,v)且加入T后不形成回路</span><br><span class="line">    		T = T ∪ (u,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-深度优先、广度优先生成树"><a href="#1-深度优先、广度优先生成树" class="headerlink" title="1. 深度优先、广度优先生成树"></a>1. 深度优先、广度优先生成树</h4><p><img src="/posts/3274436167/image-20220203100509705.png" alt></p><div style="page-break-after:always"></div><h4 id="2-Prim算法"><a href="#2-Prim算法" class="headerlink" title="2. Prim算法"></a>2. Prim算法</h4><blockquote><p>选点：Prime——Point</p></blockquote><p><strong>手动模拟</strong></p><p><img src="/posts/3274436167/image-20220203105107942.png" alt></p><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(G,T)</span></span>&#123;</span><br><span class="line">    T = ∅;<span class="comment">//初始化为空集</span></span><br><span class="line">    U = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;<span class="comment">//MST的顶点集</span></span><br><span class="line">    <span class="keyword">while</span>((V-U) != ∅)&#123;</span><br><span class="line">        设(u,v)是使 u∈U与v∈V，且权值最小的边;</span><br><span class="line">        T = T∪&#123;(u,v)&#125;;</span><br><span class="line">        U = U∪&#123;v&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\mid v\mid^2)$ ，故不依赖于边集，适用于稠密图</p><div style="page-break-after:always"></div><h4 id="3-Kruskal算法"><a href="#3-Kruskal算法" class="headerlink" title="3. Kruskal算法"></a>3. Kruskal算法</h4><p><img src="/posts/3274436167/image-20220203114520778.png" alt="image-20220203114520778" style="zoom:67%"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(G,T)</span></span>&#123;</span><br><span class="line">    T = V;<span class="comment">//初始化树，仅含顶点</span></span><br><span class="line">    numS = n;<span class="comment">//连通分量数</span></span><br><span class="line">    <span class="keyword">while</span>(numS &gt; <span class="number">1</span>)&#123;<span class="comment">//若连通分量数大于1</span></span><br><span class="line">        从E中取出权值最小的边(v,w);</span><br><span class="line">        <span class="keyword">if</span>(v和u属于不同连通分量)&#123;</span><br><span class="line">            T = T∪&#123;(v,u)&#125;;<span class="comment">//将此边加入生成树中</span></span><br><span class="line">            numS--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(\mid e\mid log\mid e\mid)$ ，适用于点多边少</p><div style="page-break-after:always"></div><h3 id="4-4-2-最短路径"><a href="#4-4-2-最短路径" class="headerlink" title="4.4.2 最短路径"></a>4.4.2 最短路径</h3><blockquote><p>带权路径长度：路劲上权值的和</p><ul><li>满足连通的 $u \rightarrow v$</li><li>找所有 $u \rightarrow v$ 中权值最小的路径</li></ul></blockquote><p>区别：</p><p><code>Dijkstra</code> : 单源点最短路径</p><p><code>Floyd</code> : 多源点最短路径</p><h4 id="1-Dijkstra"><a href="#1-Dijkstra" class="headerlink" title="1. Dijkstra"></a>1. Dijkstra</h4><p><img src="/posts/3274436167/image-20220203194113442.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MGraph G,<span class="type">int</span> v0,Patharc P,ShortPathTable D)</span>&#123;</span><br><span class="line">	<span class="type">int</span> flag[MAXVEX];<span class="comment">//访问标记数组 0-未访问 1-已访问 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.numVertices;++i)&#123;</span><br><span class="line">		flag[i] = <span class="number">0</span>;</span><br><span class="line">		D[i] = G.arc[v0][i];<span class="comment">//D[]为距离数组 </span></span><br><span class="line">		P[i] = <span class="number">0</span>;<span class="comment">//P[i]为到达vi的路径长度 </span></span><br><span class="line">	&#125; </span><br><span class="line">	D[v0] = <span class="number">0</span>,flag[v0] = <span class="number">1</span>,P[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.numVertices;++i)&#123;</span><br><span class="line">		<span class="type">int</span> min = INFINITY;<span class="comment">//记录当前距离最小值 </span></span><br><span class="line">		<span class="type">int</span> idx;<span class="comment">//记录距离最小值下标 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.numVertices;++j)<span class="comment">//查找距离v0最近的点 </span></span><br><span class="line">			<span class="keyword">if</span>(!flag[j] &amp;&amp; D[j] &lt; min)&#123;<span class="comment">//vj未被访问且距离最小 </span></span><br><span class="line">				idx = j;</span><br><span class="line">				min = D[j];</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		flag[idx] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>;w &lt; G.numVertices;++w)<span class="comment">//更新各顶点最小距离 </span></span><br><span class="line">			<span class="keyword">if</span>(!flag[w] &amp;&amp; (min + G.arc[idx][w] &lt; D[w]))</span><br><span class="line">				D[w] = min + G.arc[idx][w]; </span><br><span class="line">		P[i+<span class="number">1</span>] = idx;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Floyd"><a href="#2-Floyd" class="headerlink" title="2. Floyd"></a>2. Floyd</h4><p><img src="/posts/3274436167/image-20220204093950252.png" alt></p><script type="math/tex;mode=display">\begin{gathered}
A^{(0)}=
\begin{bmatrix}
0 & 6 & 13 \\
10 & 0 & 4/19 \\
5 & 15/\infty & 0
\end{bmatrix}
=\begin{bmatrix}
0 & 6 & 13 \\
10 & 0 & 4 \\
5 & 15 & 0
\end{bmatrix}
PATH^{(0)}=
\begin{bmatrix}
 & ab & ac \\
ba &  & bac/bc \\
ca & cab/cb & 
\end{bmatrix}
=\begin{bmatrix}
 & ab & ac \\
ba &  & bc \\
ca & cab & 
\end{bmatrix}
\end{gathered}</script><script type="math/tex;mode=display">\begin{gathered}
A^{(1)}=
\begin{bmatrix}
0 & 6 & 10/13 \\
10 & 0 & 4 \\
5/\infty & 15 & 0
\end{bmatrix}
=\begin{bmatrix}
0 & 6 & 13 \\
10 & 0 & 4 \\
5 & 15 & 0
\end{bmatrix}
PATH^{(1)}=
\begin{bmatrix}
 & ab & abc/ac \\
ba &  & bc \\
cba/ca & cab & 
\end{bmatrix}
=\begin{bmatrix}
 & ab & ac \\
ba &  & bc \\
ca & cab & 
\end{bmatrix}
\end{gathered}</script><script type="math/tex;mode=display">\begin{gathered}
A^{(2)}
=\begin{bmatrix}
0 & \infty/6 & 13 \\
9/10 & 0 & 4 \\
5 & 15 & 0
\end{bmatrix}
=\begin{bmatrix}
0 & 6 & 13 \\
9 & 0 & 4 \\
5 & 15 & 0
\end{bmatrix}
PATH^{(2)}=
\begin{bmatrix}
 & acb/ab & ac \\
bca/ba &  & bc \\
ca & cab & 
\end{bmatrix}
= \begin{bmatrix}
 & ab & ac \\
bca &  & bc \\
ca & cab & 
\end{bmatrix}
\end{gathered}</script><div style="page-break-after:always"></div><h3 id="4-4-3-有向无环图"><a href="#4-4-3-有向无环图" class="headerlink" title="4.4.3 有向无环图"></a>4.4.3 有向无环图</h3><blockquote><p>有向无环图：一个有向图中无环，简称DAG</p></blockquote><p>用于描述公共子式</p><ul><li>符号最多为二元运算符</li><li>出现多少种运算数就多少个叶结点</li></ul><p><img src="/posts/3274436167/image-20220204102546195.png" alt></p><h3 id="4-4-4-拓扑排序"><a href="#4-4-4-拓扑排序" class="headerlink" title="4.4.4 拓扑排序"></a>4.4.4 拓扑排序</h3><blockquote><p>在一个有向无环图的顶点组成的序列中</p><ul><li>每个顶点出现且只出现一次</li><li><p>若顶点A在序列中排在顶点B前面，则在图中不存在B-&gt;A的路径</p><p>对有向无环图的一种排序，若存在一条顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。</p></li></ul></blockquote><h4 id="1-AOV"><a href="#1-AOV" class="headerlink" title="1. AOV"></a>1. AOV</h4><blockquote><p>AOV(用顶点表示活动)：若用DAG表示一个工程，顶点表示活动，有向边 $<v_i ,v_j>$ 表示活动 $v_i$ 必须先于活动 $v_j$ 发生的关系。</v_i></p></blockquote><ul><li>$v_i$ 是 $v_j$ 的直接前驱，$v_j$ 是 $v_i$ 的直接后继，具有传递性</li><li>任何活动 $v_i$ 都不能以自身作为前驱或者后继</li></ul><p><img src="/posts/3274436167/image-20220204130557372.png" alt></p><h4 id="2-拓扑排序步骤"><a href="#2-拓扑排序步骤" class="headerlink" title="2. 拓扑排序步骤"></a>2. 拓扑排序步骤</h4><ol><li><p>每次从AOV中选一个没有前驱(入度=0)的顶点输出</p></li><li><p>从AOV网中删除该顶点和以该顶点为起点的所有边</p></li><li><p>重复 1. 2. 直至当前的AOV为空或当前网中不存在无前驱的顶点</p><p>若AOV为空，则该图存在拓扑序列</p><p>若AOV不空，则该图不存在拓扑序列</p></li></ol><p><img src="/posts/3274436167/image-20220204144101317.png" alt></p><h4 id="3-拓扑排序实现"><a href="#3-拓扑排序实现" class="headerlink" title="3. 拓扑排序实现"></a>3. 拓扑排序实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TopologicalSort</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    InitStack(S);<span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Push(S,i);<span class="comment">//将所有入度为0的顶点入栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//表示已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">        Pop(S,i);<span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++] = i;<span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span>(p = G.vertices[i].firstarc;p;p = p-&gt;nextarc)&#123;</span><br><span class="line">            <span class="comment">//将所有i指向的顶点入度减1并将入度为0的顶点压栈</span></span><br><span class="line">            v = p-&gt;adjvex;<span class="comment">//v是p的邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))</span><br><span class="line">                Push(S,v);<span class="comment">//入度为0则入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排序失败，有向图有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//存在拓扑序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：$O(\mid v\mid+\mid e\mid)$</p></li><li><p>入度为零的顶点，即没有前驱活动的或前驱活动全部完成的顶点，工程可以从这个顶点所代表的活动开始或继续</p></li><li>若一个顶点有多个直接后继，则拓扑序列不唯一</li><li>AOV网中各个顶点地位相同，故可重新编号，若是DAG则其邻接矩阵是三角矩阵</li></ul><h3 id="4-4-5-关键路径"><a href="#4-4-5-关键路径" class="headerlink" title="4.4.5 关键路径"></a>4.4.5 关键路径</h3><h4 id="1-AOE"><a href="#1-AOE" class="headerlink" title="1. AOE"></a>1. AOE</h4><blockquote><p>有向无环图中，顶点表示事件，有向边表示活动，边上权值表示完成该活动的开销。用边表示活动的图为AOE。</p></blockquote><ul><li>只有在顶点所代表的事件发生后，从该顶点出发的有向边代表的活动才能开始</li><li>只有在进入某顶点各有向边所代表的活动完成后，该顶点所代表的事件才能发生</li><li>AOE网中，只有一个入度为0的顶点（源点），表示整个工程开始；一个出度为0的顶点（汇点），表示整个工程结束</li></ul><p><img src="/posts/3274436167/image-20220204144618301.png" alt></p><p>拓扑序列：$v_1,v_2,v_3,v_4,v_5,v_5,v_6,v_7,v_8,v_9$</p><h4 id="2-关键路径"><a href="#2-关键路径" class="headerlink" title="2. 关键路径"></a>2. 关键路径</h4><blockquote><p>从源点到汇点的路径中，具有最大路径长度的路径；关键路径上的活动为关键活动</p></blockquote><ul><li>加快关键活动可以缩短整个工程的工期，但缩短到一定程度，关键活动会为非关键活动</li><li>若AOE网中关键路径不唯一，只有加快公共的关键路径上的关键活动，才能缩短工期</li></ul><p><img src="/posts/3274436167/image-20220204144639377.png" alt></p><h4 id="3-活动的最早开始时间最晚开始时间"><a href="#3-活动的最早开始时间最晚开始时间" class="headerlink" title="3. 活动的最早开始时间最晚开始时间"></a>3. 活动的最早开始时间最晚开始时间</h4><p>活动最早开始时间 = 活动的起点事件最早开始时间</p><p>活动的最晚开始时间 = 活动的终点事件最晚开始时间-活动的时长</p><p>活动的最晚开始时间-活动的最早开始时间 = 0 的活动为关键活动</p><p><img src="/posts/3274436167/image-20220204154335077.png" alt></p><p>即关键路径为($v_1,v_4,v_7,v_8,v_{10},v_{11}$)</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/3274436167/" title="4.图">https://amostian.github.io/posts/3274436167/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tags"></i> 计算机基础</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tags"></i> 数据结构</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/3975030669/" rel="prev" title="2.线性表"><i class="fa fa-chevron-left"></i> 2.线性表</a></div><div class="post-nav-item"><a href="/posts/3828244079/" rel="next" title="3.树">3.树 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">4.1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6"><span class="nav-text">4.1.1 顶点的度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-%E5%9B%BE%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-text">4.1.2 图的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%AE%80%E5%8D%95%E5%9B%BE"><span class="nav-text">1. 简单图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-n%E4%B8%AA%E9%A1%B6%E7%82%B9%E7%9A%84%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="nav-text">2. n个顶点的完全图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%90%E5%9B%BE"><span class="nav-text">3. 子图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%BF%9E%E9%80%9A%E5%9B%BE-%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-text">4. 连通图[无向图]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%B7%AF%E5%BE%84-amp-%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="nav-text">5. 路径&amp;完全图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84"><span class="nav-text">路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="nav-text">完全图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-text">6. 强连通图[有向图]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">4.2 图的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="nav-text">4.2.1 邻接矩阵法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%A7%84%E5%88%99"><span class="nav-text">1. 规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%89%B9%E7%82%B9"><span class="nav-text">2. 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%89%B9%E7%82%B9"><span class="nav-text">1. 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A1%A8%E7%A4%BA"><span class="nav-text">2. 表示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-text">4.2.3 邻接多重表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="nav-text">4.2.4 十字链表法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">4.3 图的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">4.3 图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">4.3.1 广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0"><span class="nav-text">1. 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">2. 性能分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%BA%94%E7%94%A8"><span class="nav-text">3. 应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">4.3.2 深度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-text">4.3.3 图的遍历与连通性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%BA%94%E7%94%A8"><span class="nav-text">4.4 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">4.4.1 最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">1. 深度优先、广度优先生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Prim%E7%AE%97%E6%B3%95"><span class="nav-text">2. Prim算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Kruskal%E7%AE%97%E6%B3%95"><span class="nav-text">3. Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">4.4.2 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Dijkstra"><span class="nav-text">1. Dijkstra</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Floyd"><span class="nav-text">2. Floyd</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="nav-text">4.4.3 有向无环图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-4-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">4.4.4 拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-AOV"><span class="nav-text">1. AOV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4"><span class="nav-text">2. 拓扑排序步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="nav-text">3. 拓扑排序实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-5-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">4.4.5 关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-AOE"><span class="nav-text">1. AOE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">2. 关键路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E6%97%A9%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%E6%9C%80%E6%99%9A%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4"><span class="nav-text">3. 活动的最早开始时间最晚开始时间</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">363</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">74</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">879.2k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">36:47</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>