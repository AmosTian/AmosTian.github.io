<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="[TOC]"><meta property="og:type" content="article"><meta property="og:title" content="Ceph参数注解-MON"><meta property="og:url" content="https://amostian.github.io/posts/2744181762/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="[TOC]"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-06-24T06:04:16.000Z"><meta property="article:modified_time" content="2024-10-04T11:29:42.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="存储"><meta property="article:tag" content="分布式存储"><meta property="article:tag" content="Ceph"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://amostian.github.io/posts/2744181762/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Ceph参数注解-MON | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">68</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">84</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">234</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/2744181762/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Ceph参数注解-MON</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-06-24 14:04:16" itemprop="dateCreated datePublished" datetime="2024-06-24T14:04:16+08:00">2024-06-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2024-10-04 19:29:42" itemprop="dateModified" datetime="2024-10-04T19:29:42+08:00">2024-10-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/Ceph/" itemprop="url" rel="index"><span itemprop="name">Ceph</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">18.5k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>38 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>[TOC]</p><span id="more"></span><h2 id="引导参数"><a href="#引导参数" class="headerlink" title="引导参数"></a>引导参数</h2><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p><code>host</code> ：默认使用主机短名称 <code>hostname -s</code> 的输出</p><p><code>public_addr</code> ：要绑定到的面向公众的地址</p><p><code>public_addrv</code> ：同 <code>public_addr</code></p><p><code>public_bind_addr</code></p><p><code>cluster_addr</code> ：要绑定到的面向群集的地址</p><p><code>public_network</code> ：从中选择要绑定到的公共地址的网络</p><p><code>public_network_interface</code> ：从public_network中选择要绑定到的地址的接口名称;还必须指定public_network</p><p><code>cluster_network</code> ：从中选择要绑定到的群集地址的网络</p><p><code>cluster_network_interface</code> ：从cluster_network中选择要绑定到的地址的接口名称;还必须指定cluster_network</p><p><code>openssl_engine_opts</code> ： 将引擎用于特定的 openssl 算法</p><ul><li><p>通过以下方式选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine_id=engine1，dynamic_path=somepathengine1.so，default_algorithms=DIGESTS：engine_id=engine2，dynamic_path=somepathengine2.so，default_algorithms=CIPHERS，other_ctrl=other_value</span><br></pre></td></tr></table></figure></li></ul><h3 id="bootstrap-mon"><a href="#bootstrap-mon" class="headerlink" title="bootstrap-mon"></a>bootstrap-mon</h3><p><code>fsid</code> ：集群的 uuid</p><p><code>monmap</code> ：MonMap文件的路径，不能运行时修改</p><ul><li>此参数通常在 mkfs 期间使用，但也可用于识别要连接到的监视器</li></ul><p><code>mon_host</code> ：用逗号、空格或分号分隔的 IP 地址或主机名的列表。主机名通过 DNS 解析。所有 A 和 AAAA 记录都包含在搜索列表中。</p><p><code>mon_host_override</code> 这是 Ceph 进程首次与 Ceph 集群建立通信时最初联系的监视器列表。使用这些旧Ceph集群实例所在主机中的monmap覆盖新的monmap</p><p><code>mon_dns_srv_name</code> ：要检查监视器地址的 DNS SRV 记录的名称</p><p><code>mon_initial_members</code> ：mon集群的成员，集群启动时初始Monitor的ID。如果指定，Ceph 需要奇数个监视器来形成初始法定人数（例如 3）。</p><h3 id="bootstrap-osd"><a href="#bootstrap-osd" class="headerlink" title="bootstrap-osd"></a>bootstrap-osd</h3><p><code>osd_uuid</code> ：新OSD进程的uuid</p><ul><li><p>Ceph OSD 守护进程的通用唯一标识符 (UUID)。</p></li><li><p>osd_uuid 适用于单个 Ceph OSD 守护进程。 fsid 适用于整个集群。</p></li></ul><p><code>osd_data</code> ：OSD 数据的路径</p><ul><li>OSD 数据的路径。部署 Ceph 时必须创建该目录。您应该在此安装点安装 OSD 数据的驱动器。我们不建议更改默认值。</li></ul><p><code>osd_max_write_size</code> ：RADOS 写入操作的最大大小（以 MB 为单位）</p><ul><li>此设置可防止客户端对 RADOS 执行非常大的写入操作。如果将此值设置为低于客户端预期的值，则在尝试写入群集时，客户端将收到错误。</li></ul><p><code>osd_max_object_size</code> ：RADOS 对象的最大大小（以字节为单位）。</p><p><code>osd_client_message_size_cap</code> ：内存中允许的最大客户端数据请求消息。</p><ul><li>如果超过此值，则在释放内存之前，OSD 不会从网络中读取任何新的客户端数据。</li></ul><p><code>osd_class_dir</code> ：RADOS 类插件的类路径。</p><h3 id="cephadm"><a href="#cephadm" class="headerlink" title="cephadm"></a>cephadm</h3><p><code>container_image</code> ：容器docker 镜像（由 CEPHADM Orchestrator 使用）</p><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p><code>no_config_file</code> ：表示我们不需要存在配置文件</p><ul><li>指定后，我们不会查找配置文件，而是期望我们工作所需的任何选项或值都将作为参数传递。</li></ul><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><p><code>run_dir</code> ：用于存储 PID 和套接字文件的“run”目录的路径</p><p><code>admin_socket</code> ：用于在守护进程上执行管理命令的套接字文件路径，由“ceph daemon”命令使用，无论 Ceph Monitor 是否已建立仲裁。</p><p><code>admin_socket_mode</code> ：为管理套接字文件设置的文件模式，例如“0755”</p><p><code>daemonize</code> ：启动后是否守护（后台）</p><p><code>pid_file</code> ：写入 PID 文件的路径（如果有）</p><ul><li>mon、osd 或 mds 将在其中写入其 PID 的文件。</li><li><code>/var/run/$cluster/$type.$id.pid</code> 将为 ceph 集群中运行的 id a 的 mon 创建 /var/run/ceph/mon.a.pid</li><li>当守护进程正常停止时，pid 文件将被删除。</li><li>如果进程未守护进程（即使用 -f 或 -d 选项运行），则不会创建 pid 文件。</li></ul><p><code>chdir</code> ：守护进程化后的chdir(2)的路径</p><ul><li>一旦 Ceph 守护进程启动并运行，其目录就会更改。推荐使用默认的根目录/。</li></ul><p><code>fatal_signal_handlers</code> ：如果设置，我们将为 SEGV、ABRT、BUS、ILL、FPE、XCPU、XFSZ、SYS 信号 安装信号处理程序以生成有用的日志消息</p><ul><li>是否为dump 堆栈的 SIGABRT 等信号 注册处理程序</li><li>这通常适用于守护程序和库的值</li></ul><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p><code>setuser</code> ：启动时要切换到的 uid 或用户名，这通常由 systemd 单元文件指定</p><p><code>setgroup</code> ：启动时要切换到 GID 或组名称，</p><p><code>setuser_match_path</code> ：如果指定了 setuser 或 setgroup，并且此选项为非空，则仅当此选项指定的文件或目录具有匹配的 uid 和 gid 时，才会更改守护程序的 uidgid。这主要是为了允许切换到 OSD 的ceph用户 ，以升级后 osd 数据内容是否也被 chother 为条件。这通常由 systemd 单元文件指定。</p><h3 id="data-path"><a href="#data-path" class="headerlink" title="data_path"></a>data_path</h3><p><code>crash_dir</code> ：存档崩溃报告的目录</p><p><code>erasure_code_dir</code> ：可以找到纠删码插件的目录</p><h3 id="restapi"><a href="#restapi" class="headerlink" title="restapi"></a>restapi</h3><p><code>restapi_log_level</code> ：默认由python代码设置</p><ul><li>restapi的日志级别</li></ul><p><code>restapi_base_url</code> ：默认由python代码设置</p><ul><li>restapi的base url</li></ul><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p><code>key</code> ：身份验证密钥</p><ul><li>CephX 身份验证密钥，base64 编码</li></ul><p><code>keyfile</code> ：包含密钥的文件的路径</p><ul><li>该文件应包含 CephX 身份验证密钥和可选的尾随换行符，但不能包含其他任何内容。</li></ul><p><code>keyring</code> ：keyring文件的路径</p><ul><li>keyring 是 INI-style 的格式化文件，其中部分名称是客户端或守护程序名称（例如，“osd.0”），每个部分都包含一个以 CephX 身份验证密钥为值的“key”属性。</li></ul><h3 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h3><p><code>heartbeat_interval</code> ：内部心跳检测的频率（秒）</p><p><code>heartbeat_file</code> ：用于 touch 内部心跳检测的文件</p><ul><li>如果设置，则每次内部心跳检测信号成功时都会touch到此文件。</li></ul><h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h2><p>每个mon进程都需要被绑定到特定的IP地址上，这些IP地址通常用部署工具配置，Ceph集群中其他组件通过 <code>[global] mon_host</code> 参数配置项发现mon进程。</p><p>MGR、OSD 和 MDS 守护程序将绑定到任何可用地址，并且不需要任何特殊配置。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote><p>bind相关的参数用于各进程的IP绑定</p></blockquote><p><code>ms_bind_ipv4</code> ：将服务绑定到 IPv4 地址</p><ul><li><code>ms_bind_prefer_ipv4</code> ：首选 IPV4 而不是 IPV6 地址</li></ul><p><code>ms_bind_ipv6</code> ：将服务绑定到IPv6地址</p><p><code>ms_bind_msgr1</code> ：将服务绑定到 msgr1（旧版）协议地址</p><p><code>ms_bind_msgr2</code> ：将服务器绑定到 msgr2 （nautilus+） 协议地址</p><p><code>ms_bind_port_min</code> ：要绑定守护程序的最低端口号</p><p><code>ms_bind_port_max</code> ：要绑定守护程序的最高端口号</p><ul><li><code>ms_bind_port_min</code> &lt; <code>ms_bind_port_max</code></li></ul><p><code>ms_bind_retry_count</code> ：binding 到端口时的尝试次数</p><p><code>ms_bind_retry_delay</code> ：2次 bind 尝试之间的延迟（秒）</p><p><code>ms_bind_before_connect</code> ：在客户端套接字上调用 bind</p><h3 id="messenger"><a href="#messenger" class="headerlink" title="messenger"></a>messenger</h3><blockquote><p><strong>messenger 是一个用于实现集群内节点间通信的协议</strong>，Ceph的各个守护进程之间需要频繁地交换信息，以协调数据存储、副本管理、故障检测和恢复等操作。基于 Messenger，Ceph 能够有效地管理集群中的信息流动，如：进程间通信、心跳消息同步、日志消息、请求处理、进程状态更新等。</p><p>【14.2.8】</p><p>支持三种消息器类型（ “simple”, “async” , “xio”）。后两种处于实验阶段，不应该被用于生产环境</p><p><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/nautilus/dev/messenger/#messenger-notes">https://docs.ceph.com/en/nautilus/dev/messenger/#messenger-notes</a></p></blockquote><h4 id="ms-async"><a href="#ms-async" class="headerlink" title="ms_async"></a>ms_async</h4><p><code>ms_type</code> ：Async Messenger 使用的传输类型。可以是 async+posix、async+dpdk 或 async+rdma。<a target="_blank" rel="noopener" href="https://docs.ceph.com/en/quincy/rados/configuration/network-config-ref/#confval-ms_type">https://docs.ceph.com/en/quincy/rados/configuration/network-config-ref/#confval-ms_type</a></p><ul><li>其取值影响其他参数配置项</li><li>枚举类型</li><li>rdma<ul><li><code>ms_async_rdma_device_name</code></li><li><code>ms_async_rdma_enable_hugepage</code></li><li><code>ms_async_rdma_buffer_size</code></li><li><code>ms_async_rdma_send_buffers</code></li><li><code>ms_async_rdma_receive_buffers</code></li><li><code>ms_async_rdma_receive_queue_len</code></li><li><code>ms_async_rdma_support_srq</code></li><li><code>ms_async_rdma_port_num</code></li><li><code>ms_async_rdma_polling_us</code></li><li><code>ms_async_rdma_gid_idx</code> ：使用gid_idx选择GID 选择RoCEv1或RoCEv2</li><li><code>ms_async_rdma_local_gid</code></li><li><code>ms_async_rdma_roce_ver</code></li><li><code>ms_async_rdma_sl</code></li><li><code>ms_async_rdma_dscp</code></li><li><code>ms_async_rdma_cm</code></li><li><code>ms_async_rdma_type</code></li></ul></li></ul><ul><li><p>dpdk</p><ul><li><p><code>ms_dpdk_port_id</code> ：应该是有特殊含义，不知道不调</p></li><li><p><code>ms_dpdk_coremask</code></p></li><li><p><code>ms_dpdk_memory_channel</code> ：MS DPDK 内存通道</p></li><li><p><code>ms_dpdk_hugepages</code> ：</p></li><li><p><code>ms_dpdk_pmd</code></p></li><li><p><code>ms_dpdk_devs_allowlist</code> ：允许使用 NIC 的 PCIe 地址</p><p>对于单个 NIC，请使用 ms_dpdk_devs_allowlist=-a 0000:7d:010 or —allow=0000:7d:010;</p><p>对于多个NIC，请使用 ms_dpdk_devs_allowlist=—allow=0000:7d:01.0 —allow=0000:7d:02.6 —vdev=net_bonding0,mode=2,slave=0000:7d:01.0,slave=0000:7d:02.6</p></li><li><p><code>ms_dpdk_host_ipv4_addr</code> ：</p></li><li><p><code>ms_dpdk_gateway_ipv4_addr</code></p></li><li><p><code>ms_dpdk_netmask_ipv4_addr</code></p></li><li><p><code>ms_dpdk_lro</code></p></li><li><p><code>ms_dpdk_enable_tso</code></p></li><li><p><code>ms_dpdk_hw_flow_control</code></p></li><li><p><code>ms_dpdk_hw_queue_weight</code> ：可能用于配置 Monitor 服务在 DPDK 硬件队列中使用的权重。DPDK 是一种用于优化网络性能的库，它提供了与硬件队列（如 NIC 队列）交互的能力。</p><p>这个参数对于优化 Monitor 服务的网络性能非常重要。设置合适的权重可以帮助确保 Monitor 服务能够有效地利用硬件队列的性能优势。</p></li><li><p><code>ms_dpdk_debug_allow_loopback</code> ：用于调试 (level: dev)，允许有回路</p></li><li><p><code>ms_dpdk_rx_buffer_count_per_core</code> ：</p></li></ul></li></ul><hr><p><code>ms_public_type</code> ：用于公共网络的 Messenger 类型</p><p><code>ms_cluster_type</code> ：用于内部集群网络的 Messenger 类型</p><hr><p><code>ms_async_op_threads</code> ：AsyncMessenger 的线程池大小 （ms_type=async）</p><p><code>ms_async_reap_threshold</code> ：用于控制异步操作中的资源清理行为</p><ul><li><p>在执行清理（reap）之前，已删除的连接数量的阈值。</p></li><li><p>这个参数的目的是优化资源的清理过程。在某些系统中，当连接被删除后，它们的资源（如内存和文件描述符）不会立即释放，而是等待一个清理操作来释放这些资源。<code>ms_async_reap_threshold</code> 定义了在执行这样的清理操作之前，系统应该积累多少个已删除的连接。</p><p>使用这个阈值的好处包括：</p><ul><li><strong>减少清理频率</strong>: 通过设置一个较高的阈值，可以减少清理操作的频率，从而减少因频繁清理而可能引起的性能开销。</li><li><strong>批量处理</strong>: 允许系统在执行清理时一次性处理多个已删除的连接，这可能比逐个处理更高效。</li></ul><p>然而，设置一个过高的阈值可能会导致资源长时间不被释放，进而影响系统性能和稳定性。因此，这个参数的值需要根据具体的应用场景和系统负载来合理调整。</p></li></ul><h4 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h4><p><code>ms_tcp_listen_backlog</code> ：可接受的连接接入队列的大小</p><p><strong>发送行为</strong></p><p><code>ms_tcp_nodelay</code> ：为 <code>true</code> Ceph将立即发送请求消息</p><ul><li>禁用 Nagle 的算法会增加网络流量。如果您遇到大量小数据包，可以尝试禁用。</li></ul><p><strong>接收行为</strong></p><p>ms_tcp_rcvbuf 与 ms_tcp_prefetch_max_size 二者独立</p><ul><li><p><code>ms_tcp_rcvbuf</code>：这个选项控制的是TCP接收缓冲区的大小，它影响着网络栈接收数据的能力。增大这个值可以减少在高网络负载下丢包，因为它允许操作系统缓冲更多的入栈数据。<br><code>ms_tcp_rcvbuf</code> 是在网络层面，确保数据能够有效地从网络传输到集群</p></li><li><p><code>ms_tcp_prefetch_max_size</code>：这个选项与Ceph的预取功能有关，它指定了在处理客户端请求时，Ceph可以提前预取的最大数据量。</p><p>预取是指在实际请求到达之前，先从网络中获取数据，以减少等待时间。</p></li></ul><h4 id="msgr2"><a href="#msgr2" class="headerlink" title="msgr2"></a>msgr2</h4><blockquote><p>Messenger v2 协议（或 msgr2）是 Ceph 在线协议的第二个主要修订版</p><p>Ceph 守护进程现在可以绑定到多个端口，允许旧版 Ceph 客户端和新的支持 v2 的客户端连接到同一集群。</p><p>默认情况下，监视器现在绑定到 IANA-分配 的采用 msgr2 协议的新端口 3300（ce4h 或 0xce4），同时还绑定到旧 v1 协议的旧默认端口 6789。</p></blockquote><h5 id="connection-mode"><a href="#connection-mode" class="headerlink" title="connection mode"></a>connection mode</h5><p><code>ms_mon_cluster_mode</code> ：按优先顺序排列的 mon 间的连接模式（crc、secure）</p><p><code>ms_mon_service_mode</code> ：允许用于连接到 mons的连接模式（crc、secure）</p><p><code>ms_mon_client_mode</code> ：用于按优先顺序从客户端连接到监视器的连接模式（crc、secure）</p><p><code>ms_cluster_mode</code> ：集群内连接的连接模式（crc、secure），按优先顺序排列</p><p><code>ms_service_mode</code> ：允许连接到守护进程的连接模式（crc、secure）</p><p><code>ms_client_mode</code> ：连接模式（crc、secure），用于从客户端进行连接，按优先顺序排列</p><h5 id="compression-mode"><a href="#compression-mode" class="headerlink" title="compression mode"></a>compression mode</h5><p><code>ms_compress_secure</code>：是否使用安全的压缩模式，而安全的压缩模式会更加注重安全性</p><ul><li>将加密与压缩相结合会降低对等体之间消息的安全级别。如果同时启用了加密和压缩，则压缩设置将被忽略，并且不会压缩消息。可以使用此设置覆盖此行为。</li></ul><hr><p>有一组并行的选项专门适用于 OSD，允许管理员对 OSD 之间的通信设置不同的要求。</p><p><code>ms_osd_compress_mode</code> ：用于与 OSD 通信的 Messenger 的压缩策略，不为 <code>none</code> ，下列参数生效- <code>force</code> （强制压缩）</p><ul><li><p>在公有云中，可用区域(zones)的通信非常昂贵。因此，最小化消息大小可以降低云提供商的网络成本。</p><p>当在 AWS（可能还有其他公共云）上使用实例存储时，具有 NVMe 的实例提供的网络带宽相对于设备带宽较低。在这种情况下，NW 压缩可以提高整体性能，因为这显然是瓶颈。</p></li><li><p><code>ms_osd_compress_min_size</code> ：需要在线压缩的最小消息大小</p></li><li><p><code>ms_osd_compression_algorithm</code> ：如果无法识别压缩模式，则将其设置为无压缩模式，并记录错误信息</p><ul><li><p>ms_osd_compress_min_size：只有当数据块大小超过这个值时，才会进行压缩</p></li><li><p>ms_osd_compression_algorithm，如ce果当前算法无法使用，Ceph 会尝试列表中的下一个算法，直到找到一个可用的算法或者遍历完整个列表。通过尝试多种算法，选择一种最适合当前工作负载和硬件环境的压缩算法</p><ul><li>根据源码分析，<code>ms_osd_compression_algorithm</code> 的取值是以 “分号、逗号、等号、空格或制表符” 分隔的压缩算法字符串列表</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/msg/compressor_registry. cc</span></span><br><span class="line"><span class="type">void</span> CompressorRegistry::_refresh_config()&#123;</span><br><span class="line">    <span class="keyword">auto</span> c_mode = Compressor::<span class="built_in">get_comp_mode_type</span>(cct-&gt;_conf.<span class="built_in">get_val</span>&lt;std::string&gt;(<span class="string">&quot;ms_osd_compress_mode&quot;</span>));</span><br><span class="line">    ms_osd_compression_methods = _parse_method_list(cct-&gt;_conf.<span class="built_in">get_val</span>&lt;std::string&gt;(<span class="string">&quot;ms_osd_compression_algorithm&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">uint32_t</span>&gt; CompressorRegistry::_parse_method_list(<span class="type">const</span> std::string&amp; s)&#123;</span><br><span class="line">	std::vector&lt;<span class="type">uint32_t</span>&gt; methods;</span><br><span class="line">    for_each_substr(s, <span class="string">&quot;;,= \t&quot;</span>, [&amp;] (<span class="keyword">auto</span> method) &#123;</span><br><span class="line">	    <span class="keyword">auto</span> alg_type = Compressor::<span class="built_in">get_comp_alg_type</span>(method);</span><br><span class="line">    	<span class="keyword">if</span> (alg_type)</span><br><span class="line">      		methods.<span class="built_in">push_back</span>(*alg_type);</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">            ...</span><br><span class="line">  	&#125;);</span><br><span class="line">   <span class="keyword">return</span> methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>ms_learn_addr_from_peer</code> ：使用我们正在连接的第一个对等体（通常是监视器）看到的 IP 地址</p><ul><li>如果客户端位于某种 NAT 后面，并且我们希望看到它由其本地（而不是 NATed）地址标识，这将非常有用</li></ul><p><code>ms_initial_backoff</code> ：检测到网络错误后的初始回退（秒）</p><p><code>ms_max_backoff</code> ：重试前出现网络错误后的最大回退（秒）</p><ul><li><p>这两个参数之间存在直接的大小关系，即 <code>ms_max_backoff</code> 应该大于或等于 <code>ms_initial_backoff</code>。</p><p>在首次检测到网络错误后，Monitor 服务会退避 <code>ms_initial_backoff</code> 秒，然后再次尝试连接。如果连接仍然失败，它会退避更长的时间，这个时间会增加，直到达到 <code>ms_max_backoff</code> 秒。超过这个时间后，如果连接仍然失败，Monitor 服务可能会采取其他措施，如报告错误或继续尝试连接。</p></li></ul><p><strong>crc校验</strong></p><p><code>ms_crc_data</code> ：设置通过网络发送的数据有效负载 与/或校验crc32c 校验和</p><p><code>ms_crc_header</code> ：设置通过网络发送的header 与/或校验crc32c 校验和</p><p><strong>。。</strong></p><p><code>ms_dispatch_throttle_bytes</code> ：限制从网络读取但仍在处理中的消息大小</p><ul><li>限制等待分发的消息的总大小</li></ul><p><code>ms_connection_ready_timeout</code> ： 指定连接在被标记为“就绪”之前等待的最长时间（秒）。如果连接在这段时间内没有准备好，它将被认为已经死亡或无法使用。</p><ul><li>控制着连接状态的超时</li></ul><p><code>ms_connection_idle_timeout</code> ：空闲连接关闭前的时间（秒）</p><ul><li>控制着连接的空闲超时</li></ul><p><code>ms_dump_on_send</code> ：在发送消息时，转储十六进制消息到调试日志</p><p><code>ms_dump_corrupt_message_level</code> ：转储十六进制损坏消息的日志级别</p><ul><li>1-20，超过20非常详细，一般不用</li></ul><p><code>ms_max_accept_failures</code> ：在考虑守护程序配置错误并中止守护程序之前，连续失败的 accept（） 调用的最大次数</p><h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p><code>log_to_file</code> ：决定是否将日志记录到文件，决定 <code>log_file是否生效</code></p><ul><li><p><code>log_file</code> ：日志文件的路径</p></li><li><p><code>log_flush_on_exit</code> ：设置进程退出处理程序以确保在退出时刷新日志文件</p><p>确定 Ceph 退出后是否应刷新日志文件。</p></li><li><p><code>log_stop_at_utilization</code> ：当设备利用率达到此比率时，停止写入日志文件</p></li><li><p><code>log_max_new</code> ：</p><p>文档中：新日志文件的最大数量。</p><p>配置文件中：在等待刷新到日志之前允许的最大未写入日志条目数</p></li><li><p><code>log_max_recent</code> ：保留在内存中的最近日志条目数，以便发生崩溃时转储</p><p>例如，debug_osd=1/5 将无条件地将 &lt;= 1 的所有内容写入日志文件，但将级别 2-5 的条目保留在内存中。如果存在段错误或断言失败，所有条目都将转储到日志中</p></li></ul><p>关于日志文件的分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src/log/Log.cc/&#123;&#125;ceph/&#123;&#125;logging</span></span><br><span class="line">void Log::dump_recent()&#123;</span><br><span class="line">	1.首先，通过std::scoped_lock对互斥量m_flush_mutex加锁，并将当前线程ID赋值给m_flush_mutex_holder。</span><br><span class="line">	</span><br><span class="line">	2.然后，在一个代码块中，通过std::scoped_lock对互斥量m_queue_mutex加锁，并将当前线程ID赋值给m_queue_mutex_holder。断言m_flush队列为空，然后将m_new队列的内容交换到m_flush队列中，并将m_queue_mutex_holder置为0。</span><br><span class="line"></span><br><span class="line">	3.调用_flush函数，将m_flush队列中的日志事件进行处理。</span><br><span class="line"></span><br><span class="line">	4.输出日志分隔线，并创建一个集合recent_pthread_ids用于存储最近线程的ID。</span><br><span class="line"></span><br><span class="line">	5.在一个临时变量t中，将m_recent队列中的日志事件移动到t中，并清空m_recent队列。然后，遍历t中的每个日志事件，将线程ID添加到recent_pthread_ids集合中，并调用_flush函数将t中的日志事件进行处理。</span><br><span class="line"></span><br><span class="line">	6.输出日志级别信息，遍历m_subs-&gt;m_subsys中的每个子系统，输出其日志级别和收集级别。同时，输出系统日志和标准错误日志的阈值。</span><br><span class="line"></span><br><span class="line">	7.输出线程ID与线程名称的映射关系，遍历recent_pthread_ids集合中的每个线程ID，获取其线程名称，并调用_log_message函数输出线程ID和线程名称。</span><br><span class="line"></span><br><span class="line">	8. 输出最近日志事件的最大数量m_max_recent、新日志事件的最大数量m_max_new和日志文件名m_log_file。</span><br><span class="line"></span><br><span class="line">	9. 最后，输出日志分隔线，并断言m_log_buf队列为空。将m_flush_mutex_holder置为0。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>log_to_xxx 与 err_to_xxx ，二者作用独立</p><ul><li><code>log_to_syslog</code>：当这个选项设置为<code>true</code>时，所有的日志消息（包括调试、信息、警告等）都会被发送到syslog。</li><li><code>err_to_syslog</code>：这个选项用来控制错误消息是否应该被发送到syslog。即使<code>log_to_syslog</code>设置为<code>false</code>，<code>err_to_syslog</code>设置为<code>true</code>时，只有错误消息会被发送到syslog。</li></ul><blockquote><p>syslog 服务是一个在计算机系统中用于日志记录的标准协议和守护进程。</p><p>主要目的是方便地收集和分析来自不同系统组件的日志信息，以便进行故障排查和系统监控。</p><p>它允许应用程序和系统服务将日志消息发送到一个集中的位置，通常是日志服务器或系统日志文件。</p></blockquote><hr><ul><li><p><code>log_to_stderr</code> ：将日志行发送到 stderr</p><ul><li><p><code>log_stderr_prefix</code> ：发送到 stderr 时要为日志消息添加前缀的字符串</p><p>这在容器环境中非常有用，与 mon_cluster_log_to_stderr 组合使用。mon 的日志在每行前加上通道名称（例如，’default’、’audit’），而log_stderr_prefix可以设置为 ‘debug ‘</p></li></ul></li><li><p><code>err_to_stderr</code> ：向 stderr 发送严重错误日志行</p></li></ul><blockquote><p><code>stderr</code> 服务是操作系统提供的一种机制，用于指定和处理程序的错误输出，确保错误信息不会干扰正常的程序输出，并方便地进行日志记录和分析。</p></blockquote><hr><blockquote><p>Graylog Server 是一个开源的日志管理和分析平台，它用于收集、存储、搜索、分析和可视化来自不同来源的日志数据</p><p>Graylog 使用 Elasticsearch 作为其数据存储引擎，并且可以与其他工具（如 Kibana）集成，以提供丰富的日志分析功能。</p></blockquote><p>理论上可以在线调整，但是与之相关的配置项</p><p><code>log_to_graylog</code> ：将日志行发送到远程 Graylog Server</p><p>为了简单起见，不调整</p><ul><li><p><code>log_graylog_host</code> ：要登录的graylog的地址或主机名</p><p>由特殊含义，不能随便调整</p></li><li><p><code>log_graylog_port</code> ：远程 Graylog 服务器的端口号</p><p>由特殊含义，不能随便调整</p></li></ul><p><code>err_to_graylog</code> ：将严重错误日志行发送到远程 Graylog Server</p><hr><blockquote><p><code>journald</code> 是 Linux 内核自 3.13 版本开始引入的一个日志系统，它是 <code>syslog</code> 系统的现代替代品。<code>journald</code> 提供了日志记录、过滤、索引和搜索功能，并且它的设计是为了更好地适应现代系统日志的需求，比如高吞吐量和系统日志的完整性。</p></blockquote><p><code>log_to_journald</code> ：控制是否将日志行发送到 journald</p><p><code>err_to_journald</code> ：控制将严重错误日志行发送到 journald</p><hr><p><code>log_coarse_timestamps</code> ：来自粗略系统时钟的时间戳日志条目，以提高性能</p><hr><p><code>clog_to_syslog</code> ：控制守护进程是否将集群日志消息发送到 syslog</p><ul><li><p><code>clog_to_syslog_level</code> ：发送到syslog的集群日志消息级别</p></li><li><p><code>clog_to_syslog_facility</code> ：用于集群日志消息的 Syslog 工具</p></li></ul><hr><p><code>clog_to_graylog</code> ：控制是否让守护进程将集群日志发送到 graylog</p><ul><li><code>clog_to_graylog_host</code>：集群日志消息的graylog主机</li><li><code>clog_to_graylog_port</code> ：集群消息日志主机的端口</li></ul><h3 id="compressor"><a href="#compressor" class="headerlink" title="compressor"></a>compressor</h3><p><strong>压缩算法</strong></p><p><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/radosgw/compression/">https://docs.ceph.com/en/latest/radosgw/compression/</a></p><p>支持的压缩插件包括：lz4、snappy、zlib、zstd。每个压缩对象都会记住使用了哪个压缩插件，因此对此设置的任何更改都不会影响 Ceph 解压缩现有对象的能力，也不会重新压缩现有对象。</p><p>zlib</p><ul><li><code>compressor_zlib_isal</code> ：使用英特尔 ISA-L 加速 zlib 实现（如果可用）</li><li><code>compressor_zlib_level</code> ：要使用的 Zlib 压缩级别</li><li><code>compressor_zlib_winsize</code> ：winsize 使用的Zlib压缩</li></ul><p><code>qat_compressor_enabled</code> ：启用英特尔 QAT 加速支持以进行压缩（如果可用）</p><p><code>plugin_crypto_accelerator</code> ：要使用的加密加速器库</p><p>zstd</p><ul><li><code>compressor_zstd_level</code> ：要使用的 Zstd 压缩级别</li><li></li></ul><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p><code>enable_experimental_unrecoverable_data_corrupting_features</code> ：启用可能未经测试、危险和/或导致永久性数据丢失的命名（或全部带有“”）实验性功能</p><p><code>plugin_dir</code> ：动态加载的插件的基本目录</p><p><code>perf</code> ：启用内部性能指标</p><ul><li>收集并公开内部运行状况指标</li><li>参数调优过程的集群性能指标来源，所以不能为 false</li></ul><p><code>crush_location_hook_timeout</code> ：<a target="_blank" rel="noopener" href="https://docs.ceph.com/en/quincy/rados/operations/crush-map/#crush-location">https://docs.ceph.com/en/quincy/rados/operations/crush-map/#crush-location</a></p><h3 id="immutable-object-cache"><a href="#immutable-object-cache" class="headerlink" title="immutable_object_cache"></a>immutable_object_cache</h3><p><code>immutable_object_cache_watermark</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/tools/immutable_object_cache</span></span><br><span class="line">ObjectCacheStore::<span class="built_in">ObjectCacheStore</span>(CephContext *cct)</span><br><span class="line">      : <span class="built_in">m_cct</span>(cct), <span class="built_in">m_rados</span>(<span class="keyword">new</span> librados::<span class="built_in">Rados</span>()) &#123;</span><br><span class="line">          <span class="type">double</span> cache_watermark =</span><br><span class="line">    m_cct-&gt;_conf.<span class="built_in">get_val</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;immutable_object_cache_watermark&quot;</span>);</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">if</span> ((cache_watermark &lt;= <span class="number">0</span>) || (cache_watermark &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">lderr</span>(m_cct) &lt;&lt; <span class="string">&quot;Invalid water mark provided, set it to default.&quot;</span> &lt;&lt; dendl;</span><br><span class="line">    cache_watermark = <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><code>immutable_object_cache_qos_iops_limit</code> ：所需的不可变对象缓存每秒 IO 操作限制</p><p><code>immutable_object_cache_qos_iops_burst</code> ：不可变对象缓存 IO 操作所需的突发限制</p><p><code>immutable_object_cache_qos_iops_burst_seconds</code> ：不可变对象缓存 IO 操作所需的突发持续时间（以秒为单位）</p><h3 id="ceph-exporter"><a href="#ceph-exporter" class="headerlink" title="ceph_exporter"></a>ceph_exporter</h3><p><code>exporter_prio_limit</code> 是 Ceph 集群中的一个配置参数，它与数据导出功能有关，通常用于控制数据导出时的优先级限制。了解这个参数的作用需要了解 Ceph 中数据导出的优先级管理。</p><p><strong>解释</strong>：该参数定义了在数据导出操作中使用的最大优先级。优先级（priority）是 Ceph 用于调度和资源分配的一个重要指标，数值越低表示优先级越高。</p><p><strong>作用</strong>：通过设置 <code>exporter_prio_limit</code>，可以控制数据导出任务的优先级范围，从而影响数据导出任务在系统资源分配中的优先级。</p><h2 id="Mon"><a href="#Mon" class="headerlink" title="Mon"></a>Mon</h2><h3 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h3><p><code>mon_data</code> ：monitors 的数据存储位置</p><p><code>mon_data_size_warn</code> ：当 MON 数据库超过此大小时发出MON_DISK_BIG运行状况警告</p><p><code>mon_data_avail_warn</code> ：当容纳监视器数据存储的文件系统报告其可用容量小于或等于此百分比时，引发 HEALTH_WARN 状态。</p><p><code>mon_data_avail_crit</code> ：当 MON 可用空间低于此百分比时出现MON_DISK_CRIT运行状况错误</p><ul><li>当容纳监视器数据存储的文件系统报告其可用容量小于或等于此百分比时，引发 HEALTH_ERR 状态。</li></ul><p><code>mon_warn_on_cache_pools_without_hit_sets</code> ：当缓存池未配置 hit_set_type 值时，引发 HEALTH_WARN。</p><p><code>mon_warn_on_crush_straw_calc_version_zero</code> ：当 CRUSH sketch_calc_version 为零时引发 HEALTH_WARN</p><p><code>mon_warn_on_legacy_crush_tunables</code> ：如果 CRUSH 可调对象早于 mon_crush_min_required_version，则发出OLD_CRUSH_TUNABLES运行状况警告</p><p><code>mon_crush_min_required_version</code> ：用于mon_warn_on_legacy_crush_tunables的最小 Ceph 发行版</p><ul><li>取值是ceph的版本</li></ul><p><code>mon_warn_on_osd_down_out_interval_zero</code> ：如果mon_osd_down_out_interval为零，则发出OSD_NO_DOWN_OUT_INTERVAL运行状况警告</p><ul><li>将 mon_osd_down_out_interval 设置为 0 意味着不会自动标记关闭的 OSD，并且集群不会在没有管理员干预的情况下自行修复。</li><li>在领导者上将此选项设置为零的行为非常类似于 noout 标志。很难弄清楚没有设置 noout 标志但表现得一样的集群出了什么问题，因此我们在这种情况下报告警告。</li></ul><p><code>mon_warn_on_pool_no_redundancy</code> ：如果任何池配置为没有副本，则引发 HEALTH_WARN。</p><p><code>mon_cache_target_full_warn_ratio</code> ：当缓存池利用率超过此可用空间比率时发出CACHE_POOL_NEAR_FULL运行状况警告</p><ul><li>mon_cache_target_full_warn_ratio &lt; osd_pool_default_cache_target_full_ratio</li><li>池的cache_target_full和target_max_object之间我们开始发出警告的位置</li><li>不能在线调整</li></ul><p><code>mon_health_to_clog</code> ：将监视运行状况记录到cluster日志</p><ul><li><p><code>mon_health_to_clog_interval</code> ：记录监控运行状况到群集日志的频率</p><p>监视器向集群日志发送运行状况摘要的频率（以秒为单位）（非正数禁用）。</p><p>监视器始终会向集群日志发送摘要，无论它是否与之前的摘要不同。</p></li><li><p><code>mon_health_to_clog_tick_interval</code> ：</p><p>监视器向集群日志发送运行状况摘要的频率（以秒为单位）（非正数禁用）。</p><p>如果当前运行状况摘要为空或与上次相同，监视器将不会将其发送到集群日志。</p><ul><li>调试级参数</li><li>应该会和上一参数冲突，不调这个</li></ul></li></ul><p><code>mon_warn_on_older_version</code> ：如果守护程序并非都运行相同的版本，则发出DAEMON_OLD_VERSION运行状况警告</p><ul><li><code>mon_warn_older_version_delay</code> ：在此时间过后发出DAEMON_OLD_VERSION运行状况警告</li></ul><h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><p><code>mon_osd_full_ratio</code> ：OSD 被视为已满之前已使用的设备空间的阈值百分比。</p><p><code>mon_osd_backfillfull_ratio</code> ：在 OSD 被认为太满而无法回填之前所使用的设备空间的阈值百分比。</p><p><code>mon_osd_nearfull_ratio</code> ：OSD 之前使用的设备空间的阈值百分比被视为接近满。</p><h3 id="监视器仲裁-quorum"><a href="#监视器仲裁-quorum" class="headerlink" title="监视器仲裁(quorum)"></a>监视器仲裁(quorum)</h3><p><code>mon_force_quorum_join</code> ：强制监视器加入quorum，即使它之前已从map中删除</p><h3 id="monitor-synchronization"><a href="#monitor-synchronization" class="headerlink" title="monitor synchronization"></a>monitor synchronization</h3><p><code>mon_sync_timeout</code> ：Ceph集群中的监控节点之间同步信息的最大等待时间（秒）。在等待时间内，监视器会等待 provider 提供的下一条更新信息。一旦超过，则会放弃并引导下一条更新信息</p><p><code>mon_sync_max_payload_size</code> 和 <code>mon_sync_max_payload_keys</code> 用于控制监控节点（Monitoring Service，简称Mon）之间同步信息时的最大数据量。</p><ol><li><code>mon_sync_max_payload_size</code>：这个选项定义了监控节点之间同步信息时，单个消息的最大大小。当一个监控节点尝试与另一个监控节点同步时，如果消息的大小超过了这个值，Ceph将不会发送该消息，而是将其分割成更小的部分。</li><li><code>mon_sync_max_payload_keys</code>：这个选项定义了监控节点之间同步信息时，单个消息可以包含的最大键数量。当一个监控节点尝试与另一个监控节点同步时，如果消息中包含的键数量超过了这个值，Ceph将不会发送该消息，而是将其分割成更小的部分。</li></ol><p>如果消息的大小超过了 <code>mon_sync_max_payload_size</code>，Ceph将尝试通过分割消息来减小其大小。如果消息中包含的键数量超过了 <code>mon_sync_max_payload_keys</code>，Ceph也将尝试通过分割消息来减小其键的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/Monitor.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Monitor::handle_sync_get_chunk</span><span class="params">(MonOpRequestRef op)</span></span>&#123;</span><br><span class="line">	<span class="number">1.</span> 输入解析与验证:</span><br><span class="line">    	获取操作请求中的MMonSync消息实例m，并打印调试信息。</span><br><span class="line">        验证请求携带的cookie是否存在于sync_providers映射中，如果不存在，则回复无此cookie的错误信息并直接返回。</span><br><span class="line"></span><br><span class="line">	<span class="number">2.</span>安全检查与超时重置:</span><br><span class="line">    	断言确认配置项mon_sync_provider_kill_at不等于<span class="number">2</span>，这是一个内部保护机制</span><br><span class="line">		获取与cookie关联的SyncProvider实例sp，并重置其超时时间，通常是默认超时时间的两倍。</span><br><span class="line">            </span><br><span class="line">	<span class="number">3.</span>同步状态检查:</span><br><span class="line">    	检查同步请求者的最新提交版本是否落后于Paxos的首个提交版本，如果落后则清理本地状态并回复无cookie错误。</span><br><span class="line"></span><br><span class="line">	<span class="number">4.</span>构建回复消息与事务准备:</span><br><span class="line">    	创建一个新的MMonSync回复消息实例reply，设置其操作类型为OP_CHUNK，并指定cookie。</span><br><span class="line">		初始化一个数据库事务tx，用于存放即将同步的数据。</span><br><span class="line"></span><br><span class="line">	<span class="number">5.</span>同步数据块处理:</span><br><span class="line">    	根据配置限制（最大负载大小和键数），循环从Paxos状态中读取数据块，直到达到任一限制或同步至最新版本。</span><br><span class="line">    	对每个数据块，从存储中获取其内容，添加到事务tx中，并更新剩余的字节和键计数</span><br><span class="line">		记录日志信息，显示已包含的Paxos状态版本。</span><br><span class="line">	# 也就是这两个参数必须大于<span class="number">0</span>，才能正确构造同步数据块</span><br><span class="line">	<span class="type">int</span> bytes_left = <span class="built_in">g_conf</span>()-&gt;mon_sync_max_payload_size;</span><br><span class="line">  	<span class="type">int</span> keys_left = <span class="built_in">g_conf</span>()-&gt;mon_sync_max_payload_keys;</span><br><span class="line">  	<span class="keyword">while</span> (sp.last_committed &lt; paxos-&gt;<span class="built_in">get_version</span>() &amp;&amp;</span><br><span class="line">		bytes_left &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	 	keys_left &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="number">6.</span>额外同步数据处理:</span><br><span class="line">    	如果同步提供者标记为全量同步且还有余量（字节和键），则调用同步器的get_chunk_tx方法来进一步填充事务，并更新最后的键信息到回复消息中。</span><br><span class="line"></span><br><span class="line">	<span class="number">7.</span>判断是否为最后一个数据块:</span><br><span class="line">		根据是否还有更多数据块待同步（全量同步且有下一个数据块，或者Paxos版本未完全同步），决定是否标记回复消息为最后一个数据块（OP_LAST_CHUNK）。</span><br><span class="line">		如果是最后一个数据块，断言确认配置项mon_sync_provider_kill_at不等于<span class="number">3</span>，作为内部保护，并清理该cookie对应的本地状态。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>paxos_max_join_drift</code> ：我们必须首先同步监控数据存储之前的最大 Paxos 迭代次数。当监视器发现其对等方领先于它太多时，它将首先与数据存储同步，然后再继续。</p><p>必须大于等于0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/AuthMonitor.cc</span></span><br><span class="line"><span class="function"><span class="type">version_t</span> <span class="title">AuthMonitor::get_trim_to</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> max = <span class="built_in">g_conf</span>()-&gt;paxos_max_join_drift * <span class="number">2</span>;</span><br><span class="line">  <span class="type">version_t</span> version = <span class="built_in">get_last_committed</span>();</span><br><span class="line">  <span class="keyword">if</span> (mon.<span class="built_in">is_leader</span>() &amp;&amp; (version &gt; max))</span><br><span class="line">    <span class="keyword">return</span> version - max;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>paxos_stash_full_interval</code> ：存储 PaxosService 状态的完整副本的频率（以提交为单位）。当前此设置仅影响 mds、mon、auth 和 mgr PaxosServices。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#src/mon/PaxosService.cc</span></span><br><span class="line"><span class="comment">//typedef uint64_t version_t;</span></span><br><span class="line"><span class="comment">//typedef __u32 epoch_t;       // map epoch  (32bits -&gt; 13 epochs/second for 10 years)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PaxosService::should_stash_full</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="number">1.</span> 首先，函数调用<span class="built_in">get_version_latest_full</span>()获取最新的完整提案的版本号，并将其存储在latest_full变量中。</span><br><span class="line">	<span class="number">2.</span> 然后，函数使用逻辑或运算符进行条件判断：</span><br><span class="line">		如果latest_full为<span class="number">0</span>或空值，则返回<span class="literal">true</span>，表示应该存档全部提案。</span><br><span class="line">		如果latest_full小于等于<span class="built_in">get_trim_to</span>()的返回值，则返回<span class="literal">true</span>，表示应该存档全部提案。</span><br><span class="line">		如果最新提交的提案版本号与latest_full的差值大于配置文件中指定的paxos_stash_full_interval值，则返回<span class="literal">true</span>，表示应该存档全部提案。</span><br><span class="line">	<span class="number">3.</span>如果以上条件都不满足，则返回<span class="literal">false</span>，表示不需要存档全部提案。</span><br><span class="line">	<span class="keyword">return</span> (!latest_full ||</span><br><span class="line">            (latest_full &lt;= <span class="built_in">get_trim_to</span>()) ||</span><br><span class="line">            (<span class="built_in">get_last_committed</span>() - latest_full &gt; (<span class="type">version_t</span>)<span class="built_in">g_conf</span>()-&gt;paxos_stash_full_interval));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>paxos_propose_interval</code> ：在实际提出 map 更新提议之前，Ceph 监视器（monitor）会等待一定的时间，聚集在这个时间间隔内收到的所有更新。</p><ul><li>例如，如果 <code>paxos_propose_interval</code> 设置为 2 秒，那么监视器会收集所有在最近 2 秒内收到的更新，并在 2 秒时间到达时，将这些更新作为一个提议提交给集群。</li></ul><p><code>paxos_min</code> ：保留的 Paxos 状态的最小数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/Paxos.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Paxos::trim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    # 保留paxos_min个最近版本，最多裁剪paxos_trim_max个版本</span><br><span class="line">    # 所以[first_committed,first_committed+paxos_trim_max]</span><br><span class="line">    # [cur_version-paxos_min,cur_version],取<span class="built_in">min</span>(first_committed+paxos_trim_max,cur_version-paxos_min)</span><br><span class="line">	<span class="type">version_t</span> end = std::<span class="built_in">min</span>(<span class="built_in">get_version</span>() - <span class="built_in">g_conf</span>()-&gt;paxos_min,</span><br><span class="line">                             <span class="built_in">get_first_committed</span>() + <span class="built_in">g_conf</span>()-&gt;paxos_trim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>paxos_min_wait</code> ：一段时间不活动后收集更新的最短时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># paxos_propose_interval作为提案间隔时间，其逻辑意义在于控制两次提案之间的最小时间间隔，因此它应该是非负数。若取负数，则逻辑上讲不通，可能会导致频繁或者不合理的提案行为。</span><br><span class="line">#paxos_min_wait在代码中它是作为在特定条件下提议需要等待的最短时间出现，理论上同样应为非负数，因为负的等待时间没有实际意义</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PaxosService::should_propose</span><span class="params">(<span class="type">double</span>&amp; delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// simple default policy: quick startup, then some damping.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">get_last_committed</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    delay = <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">utime_t</span> now = <span class="built_in">ceph_clock_now</span>();</span><br><span class="line">    <span class="keyword">if</span> ((now - paxos.last_commit_time) &gt; <span class="built_in">g_conf</span>()-&gt;paxos_propose_interval)</span><br><span class="line">      delay = (<span class="type">double</span>)<span class="built_in">g_conf</span>()-&gt;paxos_min_wait;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      delay = (<span class="type">double</span>)(<span class="built_in">g_conf</span>()-&gt;paxos_propose_interval + paxos.last_commit_time</span><br><span class="line">		       - now);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>paxos_trim_min</code> ：允许修剪的额外最小提案数量</p><p><code>paxos_trim_max</code> ：允许修剪的额外最大提案数量</p><p><code>paxos_service_trim_min</code> ：触发修剪的最小版本数量（0 禁用它）</p><p><code>paxos_service_trim_max</code> ：触发修剪的大版本数量（0 禁用它）</p><p><code>paxos_service_trim_max_multiplier</code> ：当修剪大小较高时，paxos_service_trim_max将乘以以获得新的上限的系数（0 禁用它）</p><p><code>mon_osd_cache_size</code> ：定义了 osdmaps 缓存的大小，不依赖于底层存储的缓存。这是一个具体值，用于设置缓存的大小。</p><ul><li>不依赖底层store的缓存</li></ul><p><code>mon_election_timeout</code> ：选举提议者proposer在等待所有确认（ACKs）时的最大等待时间（以秒为单位）。它直接影响到选举过程的超时设置。</p><p><code>mon_lease</code> ：监控器版本的租约时长（秒）。此设置控制 mon 仲裁对间歇性网络问题或其他故障的敏感程度</p><ul><li><p>如果将<code>mon_lease</code>设置为0：</p><ul><li><p>可能导致系统无法正确处理监视器之间的故障检测和恢复，因为没有足够的时间间隔来判断一个监视器是否失效。</p></li><li><p>客户端和服务端之间的一致性保证可能会被削弱，因为没有租约机制来确保操作的持续有效时间。</p></li><li><p>系统可能会变得不稳定，因为许多基于时间的同步和健康检查逻辑依赖于一个合理的租约时间来正常工作。</p></li></ul></li><li><p>因此，从功能和稳定性角度考虑，<code>mon_lease</code>应当设置为一个正值，其具体数值根据系统的响应速度、网络延迟以及整体稳定性要求来合理配置。</p></li></ul><p><code>mon_lease_ack_timeout_factor</code> ：调用新选举之前租用确认间隔的mon_lease倍数</p><ul><li>Leader 将等待 Provider 确认租约延期的最大时间为 mon_lease * mon_lease_ack_timeout_factor 。</li><li><strong>选举超时与租约</strong>：<code>mon_election_timeout</code> 通常应大于等于 <code>mon_lease * mon_lease_ack_timeout_factor</code>，以确保在触发新选举之前有足够的时间等待租用确认。</li></ul><p><code>mon_lease_renew_interval_factor</code> ：续租间隔的mon_lease倍数。租约必须在超时之前续订。较小的值意味着频繁续订，而接近 1 的值则使租约到期的可能性更大</p><ul><li>mon_lease * mon_lease_renew_interval_factor 将是 Leader 续订其他监视器租约的时间间隔。</li></ul><p><code>mon_accept_timeout_factor</code> ：追随者 mons 在发起新选举之前，接受提议的状态更改的 mon_lease 倍数</p><ul><li>Leader 将等待 mon_lease * mon_accept_timeout_factor 以便请求者接受 Paxos 更新。它也在 Paxos 恢复阶段用于类似目的。</li></ul><p><code>mon_max_log_epochs</code> ：要存储的过去集群日志epoch的最大数目</p><p><code>mon_elector_ping_timeout</code> ：ping “time out”且连接被视为已关闭的时间</p><p><code>mon_elector_ignore_propose_margin</code> ：在peon停止忽略非仲裁PROPOSE之前允许的连接得分差异</p><h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3><p><code>mon_tick_interval</code> ：监视器的tick时间间隔（以秒为单位）。</p><p>监视器之间发送心跳消息的间隔时间。尽管它与时钟漂移直接无关，但频繁的心跳有助于及时检测任何时钟漂移。设置较短的 <code>mon_tick_interval</code> 可以提高检测到时钟漂移的及时性。</p><p><code>mon_clock_drift_allowed</code> ：在发出健康警告之前允许的时钟漂移（以秒为单位）</p><p>定义了监视器之间允许的时钟漂移量。如果心跳消息的时间戳显示时钟漂移超过这个值，会触发健康警告。</p><p><code>mon_clock_drift_warn_backoff</code> ：用于在集群日志中记录时钟漂移警告的指数退避因子</p><p>这个参数控制了时钟漂移警告的记录频率，以防止过多的日志警告信息。虽然它不会直接影响其他参数，但它确保了在频繁的时钟漂移警告情况下，日志不会被填满。</p><p><code>mon_timecheck_interval</code> ：Leader 的时间检查间隔（时钟漂移检查）以秒为单位。</p><ul><li>在Leader为正常情况下进行时钟漂移检查的时间间隔。</li></ul><p><code>mon_timecheck_skew_interval</code> ：当 Leader 存在以秒为单位的偏差时，时间检查间隔（时钟漂移检查）以秒为单位。</p><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p><code>mon_osd_initial_require_min_compat_client</code> ：集群与客户端兼容的最小版本</p><p><code>mon_client_ping_interval</code>：</p><ul><li>定义了客户端向监控节点发送心跳请求的时间间隔。</li></ul><p><code>mon_client_ping_timeout</code>：</p><ul><li>定义了客户端等待监控节点响应心跳请求的超时时间。</li><li>如果监控节点在指定时间内没有响应，客户端会认为监控节点可能已经失败，并尝试重新发送心跳请求。</li></ul><p>如果 <code>mon_client_ping_timeout</code> 设置得大于 <code>mon_client_ping_interval</code>，那么客户端在发送心跳请求后，如果监控节点在 <code>mon_client_ping_interval</code> 指定的时间内没有响应，客户端会开始重试发送心跳请求。这意味着客户端会等待更长的时间（<code>mon_client_ping_timeout</code> 的值）来接收监控节点的响应，</p><p><code>mon_client_log_interval</code> ：我们向 mon 发送队列中的集群日志消息的频率</p><p><code>mon_client_hunt_parallel</code> ：客户端在认为监控节点已经失败时，控制同时向多个监控节点发送心跳请求的数量，以提高性能。</p><p><code>mon_client_hunt_interval</code>：</p><ul><li>客户端在认为监控节点已经失败时，尝试与下一个监控节点建立连接的时间间隔。如果仍然无法建立连接，客户端会继续尝试，直到成功连接到一个监控节点或达到某个超时阈值。</li></ul><p><code>mon_client_hunt_interval_backoff</code>：</p><ul><li>客户端在连续多次未收到监控节点响应时，<code>mon_client_hunt_interval</code> 的倍数增长速率。</li><li>例如，如果 <code>mon_client_hunt_interval</code> 是3秒，<code>mon_client_hunt_interval_backoff</code> 是2，那么第二次未收到响应时，间隔将是6秒，第三次是12秒，依此类推。</li></ul><p><code>mon_client_hunt_interval_min_multiple</code> 和 <code>mon_client_hunt_interval_max_multiple</code>：</p><ul><li><code>mon_client_hunt_interval</code> 的最小和最大倍数。</li><li>这意味着即使 <code>mon_client_hunt_interval_backoff</code> 设置为无穷大，<code>mon_client_hunt_interval</code> 也不会超过 <code>mon_client_hunt_interval_max_multiple</code> 指定的倍数。</li></ul><p><code>mon_client_max_log_entries_per_message</code> ：监视器将为每个客户端消息生成的日志条目的最大数量。</p><p><code>mon_client_bytes</code> ：MON 将从网络上读取的未完成客户端消息的最大字节数</p><ul><li>内存中允许的客户端消息数据量（以字节为单位）。</li></ul><p><code>mon_client_directed_command_retry</code> ：尝试向特定监视器发送命令的次数</p><h3 id="mon-pool"><a href="#mon-pool" class="headerlink" title="mon_pool"></a>mon_pool</h3><p><code>mon_allow_pool_delete</code> ：无论池标志如何，监视器是否应该允许删除池</p><p><code>mon_fake_pool_delete</code> ：通过重命名 RADOS 池来伪造池删除</p><ul><li>不进行池的物理删除，仅重命名池</li></ul><p><code>osd_pool_default_ec_fast_read</code> ：为新的纠删码池设置ec_fast_read</p><ul><li>是否打开池上的快速读取。如果在创建时未指定，将为新创建的纠删码池默认设置为 fast_read 。</li></ul><p><code>osd_pool_default_flag_hashpspool</code> ：在新池上设置 hashpspool（更好的哈希方案）标志</p><p><code>osd_pool_default_flag_nodelete</code> ：在新池上设置 nodelete 标志</p><p><code>osd_pool_default_flag_nopgchange</code> ：在新池上设置 nopgchange 标志</p><p><code>osd_pool_default_flag_nosizechange</code> ：在新池上设置 nosizechange 标志</p><p><code>osd_pool_default_flag_bulk</code> ：在新池上设置批量标志</p><p><code>mon_pool_quota_warn_threshold</code> <code>mon_pool_quota_crit_threshold</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/PGMap/cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PGMap::get_health_checks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  CephContext *cct,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> OSDMap&amp; osdmap,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">health_check_map_t</span> *checks)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> warn_threshold = (<span class="type">float</span>)<span class="built_in">g_conf</span>().<span class="built_in">get_val</span>&lt;<span class="type">int64_t</span>&gt;(<span class="string">&quot;mon_pool_quota_warn_threshold&quot;</span>)/<span class="number">100</span>;</span><br><span class="line">    <span class="type">float</span> crit_threshold = (<span class="type">float</span>)<span class="built_in">g_conf</span>().<span class="built_in">get_val</span>&lt;<span class="type">int64_t</span>&gt;(<span class="string">&quot;mon_pool_quota_crit_threshold&quot;</span>)/<span class="number">100</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (crit_threshold &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		   sum.num_objects &gt;= pool.quota_max_objects*crit_threshold) &#123;</span><br><span class="line">	  ss &lt;&lt; <span class="string">&quot;pool &#x27;&quot;</span> &lt;&lt; pool_name</span><br><span class="line">	     &lt;&lt; <span class="string">&quot;&#x27; has &quot;</span> &lt;&lt; sum.num_objects &lt;&lt; <span class="string">&quot; objects&quot;</span></span><br><span class="line">	     &lt;&lt; <span class="string">&quot; (max &quot;</span> &lt;&lt; pool.quota_max_objects &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	  full_detail.<span class="built_in">push_back</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">	  full = <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (warn_threshold &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		   sum.num_objects &gt;= pool.quota_max_objects*warn_threshold) &#123;</span><br><span class="line">	  ss &lt;&lt; <span class="string">&quot;pool &#x27;&quot;</span> &lt;&lt; pool_name</span><br><span class="line">	     &lt;&lt; <span class="string">&quot;&#x27; has &quot;</span> &lt;&lt; sum.num_objects &lt;&lt; <span class="string">&quot; objects&quot;</span></span><br><span class="line">	     &lt;&lt; <span class="string">&quot; (max &quot;</span> &lt;&lt; pool.quota_max_objects &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	  nearfull_detail.<span class="built_in">push_back</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">	  nearfull = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mon-other"><a href="#mon-other" class="headerlink" title="mon_other"></a>mon_other</h3><p><code>mon_globalid_prealloc</code> ：为客户端和集群中的进程预分配的 global id</p><ul><li>这个设置限制了在监视器执行写操作以预分配更多 ID 之前，能够与集群进行身份验证的新客户端的数量。较大的值会更快地耗尽 64 位 ID 空间。</li><li>即超过这个值会自动扩展</li></ul><p><code>mon_max_osd</code> ：集群中的最大OSD数量</p><p><code>mon_subscribe_interval</code> ：订阅的刷新间隔（以秒为单位）。订阅机制可以获取 cluster map 和日志信息。</p><ul><li>dev级参数：J版之前的客户端订阅间隔</li></ul><p><code>mon_stat_smooth_intervals</code> ：我们计算整个集群的平均读写吞吐量的 PG Maps 统计信息的数量</p><ul><li><p>这个参数对性能评估有影响</p></li><li><p>当 <code>mon_stat_smooth_intervals</code> 的值设置为 1 时，意味着 Ceph 只考虑最近的一个 PG 映射版本来进行统计数据的平滑。这将提供非常近期的性能数据，但可能包含更多的短期波动和噪声。</p><p>而当该参数设置为默认值 6 时，Ceph 会考虑最近 6 个 PG 映射版本来进行统计数据的平滑。这样可以减少短期波动的影响，提供一个更长期、更平滑的性能趋势视图。</p></li><li><p>如果需要统计数据能够即时反映当前系统的状态，可以选择较小的 <code>mon_stat_smooth_intervals</code>，例如 1。</p><p>如果更关注统计数据的稳定性，希望能够看出长期趋势，可以选择较大的 <code>mon_stat_smooth_intervals</code>，例如 6。</p></li></ul><p><code>mon_probe_timeout</code>：在 Bootstrap 预选阶段查询其他 mon 的超时（秒）</p><ul><li>监视器在引导之前等待找到对等点的超时秒数。</li></ul><p><code>mon_daemon_bytes</code> ：Mon 将从网络上读取的最大未完成消息的字节数</p><ul><li>元数据服务器和 OSD 消息的消息内存上限（以字节为单位）。</li></ul><p><code>mon_max_log_entries_per_event</code> ：每个 Paxos 事件的最大集群日志条目数</p><p><code>mon_osd_prime_pg_temp</code> ：通过在映射更改后启动pg_temp值来最大程度地减少对等互连工作</p><ul><li><p>当 <code>out</code> 的OSD 返回集群时，启用或禁用使用先前的 OSD 启动 PGMap。</p><p>true ，客户端将继续使用以前的 OSD，直到 PG 的新 <code>in</code> OSD 建立对等关系。</p></li></ul><p><code>mon_osd_prime_pg_temp_max_time</code> ：在 map 更改上预先计算 PG 映射所花费的最长时间（秒）</p><ul><li>当出局 OSD 返回集群时，监视器应花费多少时间（以秒为单位）来尝试准备 PGMap</li></ul><p><code>mon_osd_prime_pg_temp_max_estimate</code> ：如果估计的 PG 变化比例高于此数量，则计算所有 PG 映射</p><ul><li><p>在并行准备所有 PG 之前，预计的每个 PG 花费的最大时间。</p></li><li><p>小于 mon_osd_prime_pg_temp_max_time</p></li></ul><p><code>mon_mds_skip_sanity</code> ：跳过 FSMap/MDSMap 上的健全性检查。如果 FSMap 健全性检查失败，监视器将终止，但我们可以通过启用此选项来禁用它。</p><p><code>mon_max_mdsmap_epochs</code> ：FSMaps/MDSMaps要存储的最大 epoch 数</p><ul><li>在一个提案期间要修剪的 mdsmap 的最大 epoch 数。</li><li>这是为了限制在一次更新中可以删除的旧 mdsmap epoch 的数量，以避免过快地删除旧数据，可能导致数据恢复问题。</li></ul><p><code>mon_config_key_max_entry_size</code> ：定义允许在单个配置键条目中保存的字节数</p><p><code>mon_compact_on_start</code> ：在ceph-mon 启动时，压缩用作Ceph monitor 存储的数据库。如果常规压缩失败，手动压缩有助于缩小监控数据库并提高其性能。</p><p><code>mon_compact_on_bootstrap</code> ：在集群 bootstrap 时，压缩用作 Ceph Monitor 存储的数据库。监视器在引导后相互探测以建立法定仲裁人数。如果监视器在加入法定人数之前超时，它将重新启动并再次引导。</p><p><code>mon_compact_on_trim</code> ：当我们修剪某个前缀（包括 paxos）的旧状态时，压缩它。</p><p><code>mon_cpu_threads</code> ：监视器上，用于 CPU 密集型后台工作的工作线程</p><p><code>mon_osd_mapping_pgs_per_chunk</code> ：我们以块的形式计算从归置组到 OSD 的映射。此选项指定每个块的归置组数量。</p><ul><li>由源码可见，必须是非负数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/OSDMonitor.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OSDMonitor::start_mapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// initiate mapping job</span></span><br><span class="line">    # 检查并取消前一个映射任务：如果mapping_job不为<span class="literal">nullptr</span>，说明有之前的映射任务正在执行或待执行。这时，函数会打印日志信息并调用mapping_job-&gt;<span class="built_in">abort</span>()来取消这个任务。</span><br><span class="line">    <span class="keyword">if</span> (mapping_job) &#123;</span><br><span class="line">        <span class="built_in">dout</span>(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; canceling previous mapping_job &quot;</span> &lt;&lt; mapping_job.<span class="built_in">get</span>() &lt;&lt; dendl;</span><br><span class="line">    	mapping_job-&gt;<span class="built_in">abort</span>();</span><br><span class="line">  	&#125;</span><br><span class="line">    # 判断是否存在存储池：通过检查osdmap.<span class="built_in">get_pools</span>().<span class="built_in">empty</span>()来确定是否有存储池存在。</span><br><span class="line">  	<span class="keyword">if</span> (!osdmap.<span class="built_in">get_pools</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        #创建完成回调对象：如果存在存储池，则创建一个新的C_UpdateCreatingPGs对象（fin），它是一个完成回调，用于在映射作业完成后执行某些操作，这里主要是记录开始映射的epoch。</span><br><span class="line">    	<span class="keyword">auto</span> fin = <span class="keyword">new</span> <span class="built_in">C_UpdateCreatingPGs</span>(<span class="keyword">this</span>, osdmap.<span class="built_in">get_epoch</span>());</span><br><span class="line">        <span class="meta"># mapping.start_update的声明函数</span></span><br><span class="line">        <span class="meta"># std::unique_ptr<span class="string">&lt;MappingJob&gt;</span> start_update(</span></span><br><span class="line">    	<span class="meta">#	const OSDMap&amp; map,</span></span><br><span class="line">    	#	ParallelPGMapper&amp; mapper,</span><br><span class="line">    	<span class="meta">#	unsigned pgs_per_item)</span></span><br><span class="line">        # 启动映射作业：接下来，调用mapping.<span class="built_in">start_update</span>()方法来启动新的映射作业。这个方法会根据当前的OSD映射(osdmap)、映射器(mapper)以及配置的每批处理的PG数量来更新映射信息。新启动的映射任务会被赋值给mapping_job。</span><br><span class="line">    	mapping_job = mapping.<span class="built_in">start_update</span>(osdmap, mapper,</span><br><span class="line">				       <span class="built_in">g_conf</span>()-&gt;mon_osd_mapping_pgs_per_chunk);</span><br><span class="line">    	<span class="built_in">dout</span>(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; started mapping job &quot;</span> &lt;&lt; mapping_job.<span class="built_in">get</span>()</span><br><span class="line">	     &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; fin-&gt;start &lt;&lt; dendl;</span><br><span class="line">        # 设置完成事件与日志记录：为刚启动的映射任务设置完成事件（通过mapping_job-&gt;<span class="built_in">set_finish_event</span>(fin)），即当任务完成时将调用前面创建的fin。同时，记录一条日志信息，表明映射作业已启动及其开始的位置。</span><br><span class="line">    	mapping_job-&gt;<span class="built_in">set_finish_event</span>(fin);</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        # 无存储池时的操作：如果不存在存储池，函数会记录一条日志信息，并将mapping_job置为<span class="literal">nullptr</span>，表示无需执行任何映射任务。</span><br><span class="line">    	<span class="built_in">dout</span>(<span class="number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; no pools, no mapping job&quot;</span> &lt;&lt; dendl;</span><br><span class="line">    	mapping_job = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mon_session_timeout</code> ：在这几秒钟后关闭非活动的 MON 客户端连接</p><p><code>mon_memory_autotune</code> ：自动调整用于 osd 监视器和 kv 数据库的缓存</p><ul><li><p><code>mon_memory_target</code> ：在启用缓存自动调整的情况下，限制 osd 监视器缓存和 kv 缓存应保留在内存中的字节数</p></li><li><p><code>mon_osd_cache_size_min</code> ： OSD 监视器缓存应保持在内存中的最小字节数。这是一个底线值，确保缓存不会低于这个大小。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/OSDMonitor.cc</span></span><br><span class="line"># 都是uint</span><br><span class="line"><span class="type">int</span> OSDMonitor::_set_cache_sizes()&#123;</span><br><span class="line">    # 条件检查：首先检查是否启用了内存自动调整功能（<span class="built_in">g_conf</span>()-&gt;mon_memory_autotune）。如果启用，则继续执行后续的缓存大小设置逻辑；否则，函数直接返回<span class="number">0</span>，不做任何调整。</span><br><span class="line">  	<span class="keyword">if</span> (<span class="built_in">g_conf</span>()-&gt;mon_memory_autotune) &#123;</span><br><span class="line">    	<span class="comment">// set the new osdmon cache targets to be managed by pcm</span></span><br><span class="line">        # 获取配置参数：从配置中读取多个与内存管理和缓存大小相关的参数，包括mon_osd_cache_size、rocksdb_cache_size、基础内存大小mon_memory_base、预期内存碎片化比例mon_memory_fragmentation、目标内存使用量mon_memory_target，以及最小缓存大小mon_memory_min。</span><br><span class="line">    	mon_osd_cache_size = <span class="built_in">g_conf</span>()-&gt;mon_osd_cache_size;</span><br><span class="line">    	rocksdb_cache_size = <span class="built_in">g_conf</span>()-&gt;rocksdb_cache_size;</span><br><span class="line">    	mon_memory_base = cct-&gt;_conf.<span class="built_in">get_val</span>&lt;Option::<span class="type">size_t</span>&gt;(<span class="string">&quot;osd_memory_base&quot;</span>);</span><br><span class="line">    	mon_memory_fragmentation = cct-&gt;_conf.<span class="built_in">get_val</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;osd_memory_expected_fragmentation&quot;</span>);</span><br><span class="line">    	mon_memory_target = <span class="built_in">g_conf</span>()-&gt;mon_memory_target;</span><br><span class="line">    	mon_memory_min = <span class="built_in">g_conf</span>()-&gt;mon_osd_cache_size_min;</span><br><span class="line">        </span><br><span class="line">        # 参数有效性检查：确认mon_memory_target和mon_memory_min都大于<span class="number">0</span>，若任一值无效（小于等于<span class="number">0</span>），则通过错误日志输出相关信息，并返回-EINVAL错误码，表示提供了无效的大小配置选项。</span><br><span class="line">	    <span class="keyword">if</span> (mon_memory_target &lt;= <span class="number">0</span> || mon_memory_min &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     		derr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; mon_memory_target:&quot;</span> &lt;&lt; mon_memory_target</span><br><span class="line">           		&lt;&lt; <span class="string">&quot; mon_memory_min:&quot;</span> &lt;&lt; mon_memory_min</span><br><span class="line">           		&lt;&lt; <span class="string">&quot;. Invalid size option(s) provided.&quot;</span></span><br><span class="line">           		&lt;&lt; dendl;</span><br><span class="line">      		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">    	&#125;</span><br><span class="line">    	# 设置初始缓存大小：如果所有参数有效，会将两个LRU缓存（增量缓存inc_osd_cache和全量缓存full_osd_cache）的大小设为mon_memory_min。这意味着至少会分配最小量的内存给这些缓存使用。</span><br><span class="line">    	inc_osd_cache.<span class="built_in">set_bytes</span>(mon_memory_min);</span><br><span class="line">    	full_osd_cache.<span class="built_in">set_bytes</span>(mon_memory_min);</span><br><span class="line">        # 记录自动调整状态：最后，将mon_memory_autotune标记为当前的自动调整配置状态。</span><br><span class="line">    	mon_memory_autotune = <span class="built_in">g_conf</span>()-&gt;mon_memory_autotune;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mon_osd_snap_trim_queue_warn_on</code> ：当快照修剪队列太大（或更大）时发出警告</p><ul><li>当至少一个 PG 的对齐修剪队列长度超过此值时发出警告，因为这表示对齐修剪器跟不上，浪费磁盘空间</li></ul><p><code>mon_mgr_proxy_client_bytes_ratio</code> ：代理 mgr 命令在出错到客户端之前可以消耗的mon_client_bytes比率</p><p><code>mon_auth_validate_all_caps</code> ：是否解析“ceph auth …”设置的 non-monitor 功能命令。禁用此功能会将 CPU 保存在显示器上，但允许设置无效功能，并且仅在以后使用时拒绝它们</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Whether to parse non-monitor capabilities set by the &#x27;ceph auth ...&#x27; commands. Disabling this saves CPU on the monitor, but allows invalid capabilities to be set, and only be rejected later, when they are used</span><br></pre></td></tr></table></figure><p><code>mon_mds_blocklist_interval</code> ：MDS 守护的blocklist 条目在OSD map中保留的事件</p><p><code>mon_osd_blocklist_default_expire</code> ：客户端的阻止列表条目保留在 OSD 映射中的持续时间（以秒为单位）</p><h3 id="heartbeat-1"><a href="#heartbeat-1" class="headerlink" title="heartbeat"></a>heartbeat</h3><p>修改心跳设置时，应将它们包含在配置文件的 [global] 部分中。</p><h4 id="mon-health"><a href="#mon-health" class="headerlink" title="mon_health"></a>mon_health</h4><p><code>mon_osd_warn_op_age</code> ：如果 OSD 操作速度慢于此期限（秒），则发出REQUEST_SLOW运行状况警告</p><p><code>mon_osd_warn_num_repaired</code> ：如果 OSD 的读取修复次数超过此数量，则发出OSD_TOO_MANY_REPAIRS运行状况警告</p><p><code>mon_smart_report_timeout</code> ：smarctl 运行超时（以秒为单位），默认值设置为 5</p><p><strong>mon自动标记osd down</strong></p><p><code>mon_osd_min_up_ratio</code> ：如果 <code>up</code> 的 OSD 少于此数量，则不会自动将 OSD 标记为 <code>out</code> / <code>down</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/OSDMonitor</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OSDMonitor::can_mark_down</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    # 获取OSD总数</span><br><span class="line">	<span class="type">int</span> num_osds = osdmap.<span class="built_in">get_num_osds</span>();</span><br><span class="line">    # 获取OSD up的数量</span><br><span class="line">    <span class="type">int</span> up = osdmap.<span class="built_in">get_num_up_osds</span>() - pending_inc.<span class="built_in">get_net_marked_down</span>(&amp;osdmap);</span><br><span class="line">    # 计算OSD的实际up率</span><br><span class="line">    <span class="type">float</span> up_ratio = (<span class="type">float</span>)up / (<span class="type">float</span>)num_osds;</span><br><span class="line">    # # 小于参数配置的最小up 率，则报错</span><br><span class="line">    <span class="keyword">if</span> (up_ratio &lt; <span class="built_in">g_conf</span>()-&gt;mon_osd_min_up_ratio) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mon_osd_min_in_ratio</code> ：如果 <code>in</code> 的 OSD 少于此数量，则不会自动将 OSD 标记为 <code>out</code></p><p><code>mon_osd_down_out_interval</code> ：将所有已 <code>down</code> 这么长时间（秒）的 OSD标记为 <code>out</code></p><p><code>mon_osd_down_out_subtree_limit</code> ：如果此大小的整个子树都已 down ，则不会自动将 OSD 标记为“out”</p><ul><li>Ceph 不会自动标记的最小 CRUSH 单元类型。例如，如果设置为 host，并且 host 的所有 OSD 都已 down，Ceph 将不会自动标记这些 OSD。</li></ul><p><code>mon_osd_report_timeout</code> ：宣布无响应的 Ceph OSD 守护进程 <code>down</code> 之前的宽限期（以秒为单位）。</p><p><code>mon_osd_min_down_reporters</code> ：来自不同子树中的OSD报告某个OSD为 <code>down</code> 的最小数量</p><p><code>mon_osd_reporter_subtree_level</code> ：报告者在哪个级别的父存储桶中计数</p><ul><li>报告者被计入父存储桶的哪个级别。如果 OSD 发现对等点没有响应，则会向监视器发送故障报告。监视器将报告的 OSD 标记为 <code>out</code> ，然后在宽限期后 <code>down</code></li></ul><p><code>mon_osd_destroyed_out_interval</code> ：标记任何已被“destroy”这么长时间（秒）的 OSD“out”</p><hr><p><strong>OSD滞后</strong></p><p><code>mon_osd_laggy_halflife</code>、<code>mon_osd_laggy_weight</code> 和 <code>mon_osd_laggy_max_interval</code>：这些参数分别影响到监控器评估OSD滞后状态的敏感度、时间尺度和最大滞后时间间隔。定义了监控器如何计算OSD的 <code>laggy_probability</code> 和 <code>laggy_interval</code></p><p><code>mon_osd_laggy_halflife</code> ：OSD“滞后”因子的半衰期</p><ul><li><p>滞后多少秒秒数将会衰减</p></li><li><p>源码：大于0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># src/mon/OSDMonitor.cc</span></span><br><span class="line"><span class="function"><span class="type">utime_t</span> <span class="title">OSDMonitor::get_grace_time</span><span class="params">(<span class="type">utime_t</span> now,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="type">int</span> target_osd,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="type">failure_info_t</span>&amp; fi)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> halflife = (<span class="type">double</span>)<span class="built_in">g_conf</span>()-&gt;mon_osd_laggy_halflife;</span><br><span class="line">    <span class="type">double</span> decay_k = ::<span class="built_in">log</span>(<span class="number">.5</span>) / halflife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>mon_osd_laggy_weight</code> ：滞后估计衰减中新样本的权重。</p><p>OSD在整体laggy_probability中标记自己为备份的权重有多大</p><ul><li>1.0 意味着 OSD 将自身标记为备份（因为它被标记为关闭但实际上并未死亡）意味着 100% laggy_probability;</li><li>0.0 有效禁用laggy_probability跟踪</li></ul><p><code>mon_osd_laggy_max_interval</code> ：在 滞后时间间隔 (laggy_interval) 计算时，标记OSD的周期上限</p><ul><li>OSD 滞后估计中的最大滞后时间间隔（以秒为单位）。监控器使用自适应方法来评估特定 OSD 的 laggy_interval。这个值将用于计算该 OSD 的宽限时间。</li></ul><p><code>mon_osd_adjust_heartbeat_grace</code> ：如果对等方看起来滞后，则增加 OSD 心跳宽限度</p><ul><li><p>如果 OSD 被标记为 <code>down</code> ，但随后又将自身标记为 <code>up</code> ，则意味着它实际上并未 <code>down</code> ，但无法响应心跳。如果此选项为 true，则可以使用计算的 laggy_probability 和 laggy_interval 值来覆盖这种情况，以增加此 OSD 的检测信号宽限期，以便它不会再次被标记为 <code>down</code> 。laggy_probability 是给定 OSD 因为滞后（实际上不是 <code>down</code> ）而 <code>down</code> 的估计概率，laggy_interval是对滞后时它保持 <code>down</code> 时间的估计。</p></li><li><p>这个参数决定了是否根据OSD的 laggy_probability 和 laggy_interval 来调整心跳宽限期，以防止OSD被错误地标记为宕机。</p></li><li>即使 <code>mon_osd_adjust_heartbeat_grace</code> 设置为 <code>false</code>，<code>mon_osd_laggy_halflife</code>、<code>mon_osd_laggy_weight</code> 和 <code>mon_osd_laggy_max_interval</code> 仍然会影响监控器对OSD滞后行为的评估</li></ul><p><code>mon_osd_adjust_down_out_interval</code> ：如果 OSD 看起来滞后，则增加mon_osd_down_out_interval</p><ul><li>默认为true</li></ul><hr><p><strong>OSD 自动标记为in</strong></p><p><code>mon_osd_auto_mark_in</code> ：Ceph 将标记Ceph 存储集群中任何启动的 Ceph OSD 守护进程为 <code>in</code></p><p><code>mon_osd_auto_mark_auto_out_in</code> ：将自动标记为 <code>out</code> 的所有 OSD 标记为 <code>in</code></p><ul><li>由 <code>mon_osd_down_out_interval</code> 自动标记为 <code>out</code></li></ul><p><code>mon_osd_auto_mark_new_in</code> ：Ceph将新启动的OSD进程自动标记为 <code>in</code></p><hr><p><code>mon_warn_on_slow_ping_time</code>：这个配置选项提供了一个替代方案，允许你直接指定一个阈值，当心跳的延迟超过这个阈值（以毫秒为单位）时，Ceph将发出健康警告。这个阈值是固定的，不受 <code>osd_heartbeat_grace</code> 影响。</p><p>只有其为0，mon_warn_on_slow_ping_ratio才生效</p><ul><li><code>mon_warn_on_slow_ping_ratio</code>：这个配置选项定义了一个百分比，当心跳的延迟超过这个百分比时，Ceph将发出健康警告。这个百分比是基于 <code>osd_heartbeat_grace</code> 的，也就是说，如果心跳延迟超过了 <code>osd_heartbeat_grace</code> 的某个百分比，就会触发警告</li></ul><p>因此，<code>mon_warn_on_slow_ping_ratio</code> 和 <code>mon_warn_on_slow_ping_time</code> 都可以用来设置心跳延迟的健康警告阈值，但它们的工作方式略有不同。<code>mon_warn_on_slow_ping_ratio</code> 是基于 <code>osd_heartbeat_grace</code> 的百分比，而 <code>mon_warn_on_slow_ping_time</code> 是一个固定的阈值。</p><h4 id="OSD-health"><a href="#OSD-health" class="headerlink" title="OSD_health"></a>OSD_health</h4><p><code>osd_heartbeat_interval</code> ：Ceph OSD 守护进程 ping 其对等方的间隔时间（以秒为单位）。</p><ul><li>对等OSD之间相邻两次 ping 的间隔（以秒为单位）</li><li>1-20</li></ul><p><code>osd_heartbeat_grace</code>：这个配置选项定义了心跳（ping）的超时时间。当一个OSD（Object Storage Device，对象存储设备）没有在规定的时间内发送心跳，Ceph将认为该OSD可能已经 <code>down</code> ，并启动故障转移（failover）过程。</p><ul><li>必须配置在 [global] [osd] [mon] 中都配置</li><li><code>osd_heartbeat_grace</code> 通常应该大于或等于 <code>osd_heartbeat_interval</code>，以确保有足够的时间来检测 OSD 是否真的无法响应。</li><li>20</li></ul><p><code>osd_heartbeat_stale</code> ：间隔（以秒为单位），我们将无响应的检测信号对等节点标记为过时 <code>stable</code> 。</p><ul><li><p>自动将无响应的检测信号会话标记为过时 <code>stable</code> 并将其删除。主要好处是 OSD 不需要在内存中保留大量阻塞的心跳消息</p></li><li><p><code>osd_mon_heartbeat_stale</code> 应该大于 <code>osd_heartbeat_grace</code>，以确保在心跳对等方被标记为 stable 之前，有足够的时间来执行相应的恢复操作</p></li><li>600</li></ul><p><code>osd_mon_heartbeat_interval</code> ：如果没有 Ceph OSD 守护进程对等方，Ceph OSD 守护进程对 Ceph 监视器执行 ping 操作的频率。</p><ul><li>定义OSD与mon之间的 ping 频率</li><li>30</li></ul><p><code>osd_mon_heartbeat_stat_stale</code> ：等待这么长时间后仍没有更新，停止报告心跳 ping 时间。设置为零以禁用此操作。</p><ul><li>3600</li></ul><p><code>osd_mon_report_interval</code> ：OSD 向 mon 报告对等故障、满状态更改的频率</p><ul><li>Ceph OSD 守护进程在启动或发生其他可报告事件后向 Ceph Monitor 报告之前可能等待的秒数</li><li>5</li><li>独立于心跳间隔设置，因为它是针对状态报告的频率，通常希望较短以便及时响应。</li></ul><p><code>osd_mon_report_max_in_flight</code> ：</p><p><code>osd_beacon_report_interval</code> ：数定义了 OSD（对象存储守护进程）向监视器（Monitor）发送 beacon 报告的时间间隔。</p><ul><li>Beacon 报告用于检查 OSD 的健康状态和在线状态。通过定期发送 beacon，监视器可以判断 OSD 是否正常运行。</li></ul><p><code>osd_pg_stat_report_interval_max</code> ：定义了 OSD 向监视器报告 PG（Placement Group）状态的最大时间间隔。</p><ul><li>PG 状态报告用于更新 PG 的健康状况和统计信息。通过定期发送 PG 状态报告，监视器可以获取到最新的 PG 状态信息。</li></ul><p><code>osd_heartbeat_use_min_delay_socket</code> 参数用于控制是否使用最小延迟套接字。</p><p><code>osd_heartbeat_min_size</code> ：心跳数据包的最小大小（以字节为单位）。如果心跳数据包小于这个大小，将添加填充数据以达到最小大小。</p><h3 id="mon-log"><a href="#mon-log" class="headerlink" title="mon_log"></a>mon_log</h3><p><code>mon_log_max</code> ：要保留的集群最近日志消息数</p><p><code>mon_log_max_summary</code> ：要的集群最近重复数据删除的集群日志消息数</p><p><code>mon_log_full_interval</code> ：在编码最近日志 keys 的完整副本之前有多少个 epoch</p><p><code>mon_max_log_entries_per_event</code> ：每个 Paxos 事件的最大集群日志条目数</p><ol><li><code>mon_log_max</code>：这个参数定义了 Ceph 集群要保留的最近日志消息的数量。这是一个简单的计数，用于限制日志消息的总数。</li><li><code>mon_log_max_summary</code>：这个参数定义了要保留的经过重复数据删除的集群日志消息的数量。重复数据删除意味着相似或相同的日志消息会被合并，以减少存储和处理的日志量。</li><li><code>mon_log_full_interval</code>：这个参数定义了在两次对最近日志 keys 进行完整编码的 epoch 间隔。这可以看作是一种时间或事件的数量限制，用于控制日志数据的压缩和优化。</li><li><code>mon_max_log_entries_per_event</code>：这个参数定义了每个 Paxos 事件（Paxos 是一种分布式一致性算法）中允许的最大集群日志条目数。Paxos 事件通常用于处理分布式系统中的状态变更。</li></ol><p><code>mon_health_to_clog_tick_interval</code>：</p><ul><li><strong>解释</strong>：这是健康状态检查的周期性时间间隔，控制监视器每隔多长时间检查一次集群的健康状态。单位通常是秒。</li><li><strong>作用</strong>：这个参数设置了健康检查的频率。</li></ul><p><code>mon_health_to_clog_interval</code>：</p><ul><li><strong>解释</strong>：这是将健康状态信息记录到集群日志（clog）的时间间隔。单位通常是秒。也就是说，即使健康检查更频繁地执行，健康状态信息只有在这个间隔时间内才会被记录到日志中。</li><li><strong>作用</strong>：确定了这些检查结果中，有多少次检查结果会实际被记录到集群日志中。</li></ul><p><code>mon_op_log_threshold</code> ：最大要显示的slow ops</p><p><code>mon_op_history_slow_op_threshold</code> ：被视为历史慢速 OP 的 OP 持续时间</p><h3 id="mon-osdmap"><a href="#mon-osdmap" class="headerlink" title="mon_osdmap"></a>mon_osdmap</h3><p><code>mon_osdmap_full_prune_enabled</code> ：当我们遍历给定数量的map时，允许修剪完整的 OSDMAP 版本</p><ul><li><code>mon_osdmap_full_prune_min</code> ：存储中触发完整map修剪的最小版本数</li><li><code>mon_osdmap_full_prune_interval</code> ：不会修剪的map之间的间隔;中间的map将被修剪。</li><li><code>mon_osdmap_full_prune_txsize</code> ：我们将在每次迭代中修剪的地图数量</li></ul><p><code>mon_clean_pg_upmaps_per_chunk</code> ：PG upmap验证后台工作的粒度</p><h3 id="KVstore"><a href="#KVstore" class="headerlink" title="KVstore"></a>KVstore</h3><p><code>mon_keyvaluedb</code> ：用于 MON 数据库的数据库后端</p><h2 id="身份认证相关参数"><a href="#身份认证相关参数" class="headerlink" title="身份认证相关参数"></a>身份认证相关参数</h2><p><code>auth_supported</code> ：所需的身份验证方法（废弃）</p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>CephX 协议默认启用，提供的身份加密验证具有一定的计算成本，但这通常应该相当低。如果连接客户端和服务器主机的网络环境非常安全并且您无法承担身份验证，则可以禁用它。所以关于节点身份验证协议是一种用户定制化行为，不应该为性能调优打开或关闭该协议。</p><blockquote><p>控制的是身份验证（Authentication）的要求，决定是否需要对 Ceph 存储集群的守护进程或客户端进行身份验证。</p></blockquote><p><code>auth_cluster_required</code> ：如果启用此配置设置，则 Ceph 存储集群守护进程（即 ceph-mon、ceph-osd、ceph-mds 和 ceph-mgr）需要相互进行身份验证。有效设置为 cephx 或 none。</p><p><code>auth_service_required</code> ：如果启用此配置设置，则只有当这些客户端通过 Ceph 存储集群进行身份验证时，Ceph 客户端才能访问 Ceph 服务（如对象存储、文件系统等）。有效设置为 cephx 或 none。</p><p><code>auth_client_required</code> ：如果启用此配置设置，则仅当 Ceph 存储集群针对 Ceph 客户端进行身份验证时，才能建立 Ceph 客户端和 Ceph 存储集群之间的通信。有效设置为 cephx 或 none。</p><p><code>cephx_require_version</code> ：Cephx的版本</p><ul><li>1：表示M版之前</li><li>2：表示M版之后</li></ul><p><code>cephx_cluster_require_version</code></p><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><blockquote><p>控制的是消息签名（Message Signing）的要求，决定是否需要对 Ceph 守护进程之间或客户端与守护进程之间的消息进行签名以确保完整性和防止篡改。</p></blockquote><p><code>cephx_require_signatures</code> ：如果此配置设置设置为 true，Ceph 需要对 Ceph 客户端和 Ceph 存储集群之间以及 Ceph 存储集群内的守护进程之间的所有消息流量进行签名。</p><ul><li>Ceph Argonaut 和 3.19 之前的 Linux 内核版本都不支持签名；如果这些客户端之一正在使用，则可以禁用 cephx_require_signatures 以允许客户端连接</li></ul><ol><li><strong>安全性</strong>：设置 <code>cephx_require_signatures</code> 为 <code>true</code> 可以提高 Ceph 集群的安全性，因为签名可以防止未授权的访问和数据篡改。</li><li><strong>性能</strong>：使用签名验证会增加客户端和服务端之间的通信开销，因此在高负载情况下可能会影响性能。</li><li><strong>资源消耗</strong>：签名验证需要额外的计算资源，因此在资源有限的集群中可能会成为一个问题。</li></ol><p><code>cephx_cluster_require_signatures</code> ：如果此配置设置设置为 true，Ceph 需要对 Ceph 存储集群内的 Ceph 守护进程之间的所有消息流量进行签名。</p><p><code>cephx_service_require_signatures</code> ：如果此配置设置设置为 true，Ceph 需要对 Ceph 客户端和 Ceph 存储集群之间的所有消息流量进行签名。</p><p><code>cephx_sign_messages</code> ：如果此配置设置设置为 true，并且 Ceph 版本支持消息签名，则 Ceph 将对所有消息进行签名，以便更难以欺骗。</p><h3 id="密钥相关"><a href="#密钥相关" class="headerlink" title="密钥相关"></a>密钥相关</h3><p>共同控制密钥的生命周期和可用性。</p><ol><li><code>max_rotating_auth_attempts</code>：<ul><li>定义了在尝试初始化更换密钥时可以进行的最大尝试次数。</li><li>如果在这个次数内无法成功初始化旋转密钥，Ceph将停止尝试并记录错误。</li></ul></li><li><code>rotating_keys_bootstrap_timeout</code>：<ul><li>定义了在引导（bootstrap）阶段获取更换密钥的超时时间（以秒为单位）。</li><li>在引导阶段，Ceph节点需要获取初始密钥对，以便与其他节点通信。</li></ul></li><li><code>rotating_keys_renewal_timeout</code>：<ul><li>定义了更新密钥的超时时间（以秒为单位）。</li><li>密钥更新是周期性的，以保持系统的安全性。</li></ul></li></ol><p><code>max_rotating_auth_attempts</code> 确保在密钥初始化或更新过程中，系统有足够的机会成功完成任务。<code>rotating_keys_bootstrap_timeout</code> 和 <code>rotating_keys_renewal_timeout</code> 则分别定义了引导阶段和密钥更新阶段的超时时间，确保这些关键操作在一定时间内完成，从而维护系统的安全性和性能。</p><h4 id="凭证有效时间"><a href="#凭证有效时间" class="headerlink" title="凭证有效时间"></a>凭证有效时间</h4><p><code>auth_mon_ticket_ttl</code> ：定义了监控节点票证的有效期，即从创建到过期的时间长度。当票证过期时，它将不再有效，客户端将需要重新请求一个新的票证来访问集群资源。</p><h3 id="一些警告"><a href="#一些警告" class="headerlink" title="一些警告"></a>一些警告</h3><p><code>auth_allow_insecure_global_id_reclaim</code> ：允许收回global_id，而无需出示证明以前确实拥有该global_id的有效票据</p><ul><li>允许使用未经授权的global_id（重复）会带来安全风险。遗憾的是，较旧的客户端可能会在重新连接时省略其票证，因此依赖于允许在客户端实例的生命周期内保留其global_id。将此值设置为 false 将立即阻止来自这些客户端的新连接（假设auth_expose_insecure_global_id_reclaim设置为 true），并最终中断现有会话（无论auth_expose_insecure_global_id_reclaim设置如何）。</li></ul><p><code>auth_expose_insecure_global_id_reclaim</code> ：强制可能在重新连接时省略其票证的旧客户端在建立会话时重新连接</p><ul><li>在宽松模式（auth_allow_insecure_global_id_reclaim设置为 true）中，这有助于识别未修补的客户端。在强制模式（auth_allow_insecure_global_id_reclaim设置为 false）中，这是一种快速失败机制：不要建立一个以后几乎不可避免地会中断的会话</li></ul><p><code>mon_warn_on_insecure_global_id_reclaim</code> ：如果任何连接的客户端不安全地回收AUTH_INSECURE_GLOBAL_ID_RECLAIM global_id，则发出运行状况警告</p><p><code>mon_warn_on_insecure_global_id_reclaim_allowed</code> ：如果允许不安全global_id回收，则发出AUTH_INSECURE_GLOBAL_ID_RECLAIM_ALLOWED运行状况警告</p><p><code>mon_warn_on_msgr2_not_enabled</code> ：如果监视器都运行 Nautilus及以上的版本，但并非所有监视器都绑定到 msgr2 端口，则发出MON_MSGR2_NOT_ENABLED运行状况警告</p><h2 id="CRUSH"><a href="#CRUSH" class="headerlink" title="CRUSH"></a>CRUSH</h2><p><code>crush_location</code> ：</p><p><code>crush_location_hook</code></p><h2 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h2><p><code>rados_mon_op_timeout</code> ：监视器（如 statfs）处理的操作超时（0 表示无限制）</p><p><code>rados_osd_op_timeout</code> ：</p><p><code>rados_tracing</code> ：tracing 结尾的参数会生成大量日志，仅用于调试目的</p><h2 id="cephsqlite"><a href="#cephsqlite" class="headerlink" title="cephsqlite"></a>cephsqlite</h2><p><code>cephsqlite_lock_renewal_interval</code> 指定了锁续期的频率，而 <code>cephsqlite_lock_renewal_timeout</code> 指定了锁的总有效时间。如果锁在 <code>cephsqlite_lock_renewal_timeout</code> 指定的时间内没有被续期，那么它将自动失效，以防止数据库损坏。换句话说，<code>cephsqlite_lock_renewal_interval</code> 应该小于或等于 <code>cephsqlite_lock_renewal_timeout</code>，以确保在锁超时之前有足够的机会进行续期。</p><h2 id="开发相关参数"><a href="#开发相关参数" class="headerlink" title="开发相关参数"></a>开发相关参数</h2><h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><p><code>mempool_debug</code> ：调试内存池？</p><p><code>thp</code> ：启用透明大页面 （THP） 支持</p><ul><li>众所周知，Ceph 会因使用 THP 而遭受内存碎片的困扰。这由配置的内存目标上方的 RSS 使用情况指示。在 Ceph 有选择地使用 THP 之前，目前不鼓励启用 THP。</li></ul><h3 id="msgr相关"><a href="#msgr相关" class="headerlink" title="msgr相关"></a>msgr相关</h3><p><code>ms_die_on_bad_msg</code> ：当收到错误的网络消息时，诱导守护程序崩溃退出</p><ul><li>文档明确指出不要调：<a target="_blank" rel="noopener" href="https://docs.ceph.com/en/quincy/rados/configuration/network-config-ref/?highlight=ms_die#confval-ms_die_on_bad_msg">https://docs.ceph.com/en/quincy/rados/configuration/network-config-ref/?highlight=ms_die#confval-ms_die_on_bad_msg</a></li></ul><p><code>ms_die_on_unhandled_msg</code> ：当收到无法识别的消息时诱导守护程序崩溃退出</p><p><code>ms_die_on_old_message</code> ：当收到旧的、不可解码的消息时，诱导守护进程崩溃退出</p><p><code>ms_die_on_skipped_message</code> ：如果发送方跳过消息序列号，则诱导守护程序崩溃退出</p><p><code>ms_die_on_bug</code> ：在各种错误上诱导崩溃退出（用于测试目的）</p><p><code>ms_pq_max_tokens_per_priority</code> ：文档没有，且无描述</p><p><code>ms_pq_min_cost</code></p><p><code>ms_inject_socket_failures</code> ：每 N 个套接字操作注入一个套接字故障</p><p>注入各种内部延迟以诱导争用（秒）</p><ul><li><code>ms_inject_delay_type</code> ：要为其注入延迟的实体类型</li><li><code>ms_inject_delay_max</code> ：注入的最大延迟</li><li><code>ms_inject_delay_probability</code> ：延迟注入的概率</li><li><code>ms_inject_internal_delays</code> ：</li></ul><p><code>ms_blackhole_osd</code> 、<code>ms_blackhole_mon</code> 、<code>ms_blackhole_mds</code> 、<code>ms_blackhole_mgr</code> 、<code>ms_blackhole_client</code> 、</p><p><code>inject_early_sigterm</code> ：这个参数的主要用途是在程序启动的早期阶段模拟接收到 SIGTERM 信号的情况。SIGTERM（信号终止）是一个常见的信号，用于请求进程安全地终止。在正常运行中，当系统管理员想要关闭一个进程时，会发送这个信号给该进程</p><ul><li>在启动期间尽早向自己发送 SIGTERM，终止进程启动，仅用作调试</li></ul><h3 id="heartbeat-2"><a href="#heartbeat-2" class="headerlink" title="heartbeat"></a>heartbeat</h3><p><code>heartbeat_inject_failure</code> ：心跳检测注入失败</p><h3 id="cephadm-1"><a href="#cephadm-1" class="headerlink" title="cephadm"></a>cephadm</h3><p><code>lockdep</code> ：与cephadm的开发与有关，不能在线调整</p><p><code>lockdep_force_backtrace</code>：始终在每个锁处收集当前的回溯</p><h3 id="mon"><a href="#mon" class="headerlink" title="mon"></a>mon</h3><p><code>mon_sync_debug</code> ：在 Mon 同步期间启用额外调试</p><ul><li>mon_inject_sync_get_chunk_delay</li></ul><p><code>mon_debug_no_require_bluestore_for_ec_overwrites</code> ：控制是否在启用纠删码（Erasure Coding，简称EC）重写（overwrites）功能时，是否要求 Bluestore 作为 OSD的存储后端</p><p>为 <code>true</code> 时，Ceph 将允许在非Bluestore的 OSD 上执行纠删码重写操作。这个选项应该只在开发或测试环境中使用，以帮助诊断和调试与纠删码重写相关的问题。在生产环境中，为了保持性能和数据一致性，应该将这个选项设置为 <code>false</code>。</p><p><code>mon_debug_dump_transactions</code> ：输出详细的 Paxos 事务到日志，查看和分析 Paxos 事务的细节便于定位相关问题。会对集群性能产生影响</p><ol><li><strong>日志文件大小</strong>：输出详细的 Paxos 事务到日志可能会导致日志文件迅速增长，尤其是在高负载或复杂的工作负载下。</li><li><strong>性能影响</strong>：输出详细的 Paxos 事务到日志可能会增加监控节点的计算和网络负载，这可能会对集群的性能产生影响。</li></ol><p><code>mon_debug_deprecated_as_obsolete</code> ：控制是否将过时的监控节点（Monitoring Service，简称Mon）命令视为废弃的命令</p><p>为<code>true</code> 时，Ceph 将把那些标记为过时的监控节点命令视为废弃的命令。如果客户端尝试使用这些过时的命令，Ceph 将会拒绝执行这些命令，并可能记录错误日志。</p><p>这个选项对 Ceph 集群的性能和稳定性没有直接影响，但它可以帮助管理员识别和处理过时的命令，从而确保集群的稳定性和安全性。在生产环境中，为了保持集群的稳定性和安全性，通常会将这个选项设置为 <code>false</code>。</p><p><code>mon_debug_block_osdmap_trim</code> ：控制是否阻止 OSDMap 的修剪操作</p><p>为 <code>true</code> 时</p><ol><li><strong>OSDMap 数据积累</strong>：阻止 OSDMap 修剪会导致旧的 OSDMap 数据在监控节点上积累，这可能会占用更多的存储空间。</li><li><strong>性能影响</strong>：随着 OSDMap 数据的积累，监控节点的性能可能会受到影响，因为它们需要处理和存储更多的数据。</li><li><strong>状态一致性</strong>：阻止 OSDMap 修剪可能会导致集群的状态不一致，因为 OSDMap 数据可能不再反映当前集群的状态。</li></ol><p>这个选项应该只在开发或测试环境中使用，以帮助诊断和调试与 OSDMap 修剪相关的问题。在生产环境中，为了保持性能和状态一致性，应该将这个选项设置为 <code>false</code>。</p><p><code>mon_debug_extra_checks</code> ：控制是否启用一些额外的监控检查。包含了一些调试或测试时可能非常有用的功能，但在生产环境中可能会增加不必要的开销。</p><ol><li><strong>额外的计算和网络负载</strong>：额外的监控检查可能会增加监控节点的计算负载，并可能导致额外的网络通信，这可能会对集群的性能产生影响。</li><li><strong>资源消耗</strong>：这些额外的检查可能会消耗更多的内存、CPU或其他资源，这在资源有限的集群中可能会成为一个问题。</li><li><strong>稳定性风险</strong>：某些额外的检查可能会发现集群中的问题，但这些问题可能不会在生产环境中出现。在启用这些检查时，可能会增加集群出现不稳定性或性能问题的风险。</li></ol><p>这些检查的成本太高而无法在生产系统上运行，或者仅在测试或调试时才相关</p><p><code>mon_mds_force_trim_to</code> ：强制监视器将 mdsmap 修剪到但不包括此 FSMap epoch。值为 0 会禁用（默认）此配置。该命令有潜在危险，请谨慎使用。</p><p><code>mon_osd_force_trim_to</code> ：强制监控节点（Monitoring Service，简称Mon）修剪到指定 epoch 的 OSDMap。</p><ul><li>修剪操作是 Ceph 用来保持 OSDMap 最新和精简的过程，它移除过时的信息并更新集群的状态。</li></ul><p>如果监控节点无法修剪到指定 epoch 的 OSDMap，可能会导致以下问题：</p><ol><li><strong>性能问题</strong>：OSDMap 的修剪操作可能会因为无法修剪到指定 epoch 而延迟，影响集群的性能。</li><li><strong>稳定性问题</strong>：OSDMap 中的过时信息可能会导致集群的状态不一致，影响集群的稳定性。</li></ol><p>在实际应用中，当监控节点执行某些操作时，如执行 OSDMap 的修剪操作，它将尝试修剪到指定 epoch 的 OSDMap。如果无法修剪到指定 epoch，监控节点可能会继续尝试，直到成功修剪或达到某个超时阈值。</p><p><code>mon_inject_transaction_delay_max</code> ：控制注入到 Paxos 事务中的最大延迟持续时间，这可以帮助模拟和测试在延迟条件下 Paxos 算法的性能和一致性。</p><ul><li>Paxos 是一个算法，用于在分布式系统中达成一致。在 Ceph 中，Paxos 用于实现高可用性和一致性的分布式存储。</li></ul><p>这个选项对 Ceph 集群的性能和稳定性没有直接影响，但它可以帮助管理员模拟和测试在网络延迟或系统故障条件下的 Paxos 性能。</p><p>与之相关的是 <code>mon_inject_transaction_delay_probability</code></p><p><code>mon_inject_pg_merge_bounce_probability</code> ：在执行 PG（Placement Group）合并操作时，将 PG 数量减少的操作失败并回滚的概率。</p><ul><li>PG 合并操作是 Ceph 用来优化集群性能和存储效率的过程，它通过合并多个 PG 来减少存储资源的占用。</li></ul><p>为 <code>true</code> 时，模拟在执行 PG 合并操作时可能发生的失败和回滚情况，这可以帮助你测试和验证 PG 合并策略的健壮性和恢复能力。</p><p>这个选项对 Ceph 集群的性能和稳定性没有直接影响，但它可以帮助管理员模拟和测试在执行 PG 合并操作时可能遇到的失败情况。</p><p><code>mon_sync_provider_kill_at</code> ：在监控节点同步操作的某个特定阶段（由 epoch 标识）执行provider的终止操作。可以帮助你测试和验证监控节点在执行同步操作时在不同阶段的行为和恢复能力。</p><p><code>mon_sync_requester_kill_at</code> ：在监控节点同步操作的某个特定阶段（由 epoch 标识）执行requester的终止操作</p><p><code>mon_debug_unsafe_allow_tier_with_nonempty_snaps</code> ：默认情况下，Ceph 禁止在非空快照的情况下创建层级，这是出于数据一致性和保护的考虑。如果一个池（pool）中已经有快照存在，创建层级可能会导致快照数据的丢失或损坏。</p><p><code>mon_client_directed_command_retry</code> ：客户端向特定监控节点发送定向命令（directed command）时尝试发送的次数。</p><ul><li>允许客户端在向特定监控节点发送定向命令时，重复尝试发送该命令的次数。如果在这个次数内无法成功发送定向命令，客户端将停止尝试并记录错误。</li><li>对 Ceph 集群的性能和稳定性没有直接影响，</li></ul><h3 id="objector"><a href="#objector" class="headerlink" title="objector"></a>objector</h3><p><code>objecter_completion_locks_per_session</code> ：控制对象执行器（Objecter）在处理每个会话时可以持有的完成锁（completion locks）的最大数量。</p><ul><li>完成锁是用于协调和同步多个对象执行器操作的机制，以确保数据的一致性和完整性。</li></ul><p><code>objecter_inject_no_watch_ping</code> 选项允许对象执行器在发送心跳请求时模拟不响应的情况，这可以帮助模拟和测试在心跳请求未响应时的行为和恢复能力。</p><ul><li>在生产环境中，为了保持性能和稳定性，通常会将这个选项设置为 <code>false</code>。然而，在开发或测试环境中，启用 <code>objecter_inject_no_watch_ping</code> 可以有助于诊断和调试与心跳相关的问题。</li></ul><p><code>objecter_retry_writes_after_first_reply</code> 控制对象执行器（Objecter）是否在接收到第一个回复后重试写操作，即使之前的写操作已经被确认。这可以帮助模拟和测试在写操作可能失败时的行为和恢复能力。</p><ul><li>在生产环境中，为了保持性能和稳定性，通常会将这个选项设置为 <code>false</code>。然而，在开发或测试环境中，启用 <code>objecter_retry_writes_after_first_reply</code> 可以有助于诊断和调试与写操作相关的问题。</li></ul><p><code>objecter_debug_inject_relock_delay</code> ：控制对象执行器（Objecter）是否在释放完成锁（completion lock）后注入一个延迟。这可以帮助模拟和测试在完成锁释放后可能遇到的问题。</p><ul><li>为了保持性能和稳定性，通常会将这个选项设置为 <code>false</code>。然而，在开发或测试环境中，启用 <code>objecter_debug_inject_relock_delay</code> 可以有助于诊断和调试与完成锁相关的问题。</li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/2744181762/" title="Ceph参数注解-MON">https://amostian.github.io/posts/2744181762/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 存储</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 分布式存储</a> <a href="/tags/Ceph/" rel="tag"><i class="fa fa-tags"></i> Ceph</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/3924783311/" rel="prev" title="Ceph参数注解-mgr"><i class="fa fa-chevron-left"></i> Ceph参数注解-mgr</a></div><div class="post-nav-item"><a href="/posts/2245133153/" rel="next" title="Ceph参数注解-CephFS">Ceph参数注解-CephFS <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E5%8F%82%E6%95%B0"><span class="nav-text">引导参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#network"><span class="nav-text">network</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bootstrap-mon"><span class="nav-text">bootstrap-mon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bootstrap-osd"><span class="nav-text">bootstrap-osd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cephadm"><span class="nav-text">cephadm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster"><span class="nav-text">cluster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#daemon"><span class="nav-text">daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user"><span class="nav-text">user</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data-path"><span class="nav-text">data_path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restapi"><span class="nav-text">restapi</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keys"><span class="nav-text">keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heartbeat"><span class="nav-text">heartbeat</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#networks"><span class="nav-text">networks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-text">bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#messenger"><span class="nav-text">messenger</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ms-async"><span class="nav-text">ms_async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp"><span class="nav-text">tcp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#msgr2"><span class="nav-text">msgr2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#connection-mode"><span class="nav-text">connection mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#compression-mode"><span class="nav-text">compression mode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#basic"><span class="nav-text">basic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#logs"><span class="nav-text">logs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compressor"><span class="nav-text">compressor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other"><span class="nav-text">other</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#immutable-object-cache"><span class="nav-text">immutable_object_cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ceph-exporter"><span class="nav-text">ceph_exporter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mon"><span class="nav-text">Mon</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DATA"><span class="nav-text">DATA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F"><span class="nav-text">存储容量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E8%A7%86%E5%99%A8%E4%BB%B2%E8%A3%81-quorum"><span class="nav-text">监视器仲裁(quorum)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitor-synchronization"><span class="nav-text">monitor synchronization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clock"><span class="nav-text">clock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client"><span class="nav-text">client</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mon-pool"><span class="nav-text">mon_pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mon-other"><span class="nav-text">mon_other</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heartbeat-1"><span class="nav-text">heartbeat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mon-health"><span class="nav-text">mon_health</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSD-health"><span class="nav-text">OSD_health</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mon-log"><span class="nav-text">mon_log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mon-osdmap"><span class="nav-text">mon_osdmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVstore"><span class="nav-text">KVstore</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="nav-text">身份认证相关参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="nav-text">身份验证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#signature"><span class="nav-text">signature</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%9B%B8%E5%85%B3"><span class="nav-text">密钥相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%AD%E8%AF%81%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4"><span class="nav-text">凭证有效时间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E8%AD%A6%E5%91%8A"><span class="nav-text">一些警告</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRUSH"><span class="nav-text">CRUSH</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RADOS"><span class="nav-text">RADOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cephsqlite"><span class="nav-text">cephsqlite</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="nav-text">开发相关参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-text">内存相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msgr%E7%9B%B8%E5%85%B3"><span class="nav-text">msgr相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heartbeat-2"><span class="nav-text">heartbeat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cephadm-1"><span class="nav-text">cephadm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mon"><span class="nav-text">mon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objector"><span class="nav-text">objector</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">234</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">84</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1249.6k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">50:22</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>