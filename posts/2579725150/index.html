<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="题目来源于 leetcode 编程能力学习计划"><meta property="og:type" content="article"><meta property="og:title" content="0.编程能力"><meta property="og:url" content="https://amostian.github.io/posts/2579725150/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="题目来源于 leetcode 编程能力学习计划"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220213085838921.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220213115943771.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220213120538464.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220218232211583.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/1598145577-ziwCvD-1.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220219085741763.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220219104501728.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220219110527978.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220220083956249.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220220085120762.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220220100306035.png"><meta property="og:image" content="https://amostian.github.io/posts/2579725150/image-20220220100242997.png"><meta property="article:published_time" content="2024-01-26T10:53:42.184Z"><meta property="article:modified_time" content="2023-03-24T14:00:12.229Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="算法"><meta property="article:tag" content="编程能力"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/2579725150/image-20220213085838921.png"><link rel="canonical" href="https://amostian.github.io/posts/2579725150/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>0.编程能力 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">375</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/2579725150/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">0.编程能力</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-01-26 18:53:42" itemprop="dateCreated datePublished" datetime="2024-01-26T18:53:42+08:00">2024-01-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2023-03-24 22:00:12" itemprop="dateModified" datetime="2023-03-24T22:00:12+08:00">2023-03-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/" itemprop="url" rel="index"><span itemprop="name">编程能力</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">9.7k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>30 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>题目来源于 leetcode 编程能力学习计划</p></blockquote><span id="more"></span><h2 id="0-1-基本数据类型"><a href="#0-1-基本数据类型" class="headerlink" title="0.1 基本数据类型"></a>0.1 基本数据类型</h2><h3 id="1523-在区间范围内统计奇数数目"><a href="#1523-在区间范围内统计奇数数目" class="headerlink" title="1523.在区间范围内统计奇数数目"></a>1523.在区间范围内统计奇数数目</h3><p>奇数，第一反应是 <code>n%2==1</code> ,所以直接写成下面代码，结果超时。计算除法的代价显然比加减法大得多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOdds</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=low;i &lt;= high;++i)</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>又想整数，一定是 <strong>奇、偶、…</strong> 或 <strong>偶、奇…</strong></p><p>所以已经给定区间范围，[左,右]，右-左= (左,右] 或 [左,右) 包含的整数个数，折半则为奇数个数</p><p>且分为以下情况</p><ol><li>[奇,奇]</li><li>[奇,偶]</li><li>[偶,奇]</li><li>[偶,偶]</li></ol><p>故需判断一侧边界是否为奇数，若其为奇数，则个数加1。由于闭区间的对称性，两侧都要判断，且左右判别式间关系为或。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOdds</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(low % <span class="number">2</span>==<span class="number">1</span>  || high%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        cnt += (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="前缀和思想"><a href="#前缀和思想" class="headerlink" title="前缀和思想"></a>前缀和思想</h4><p>pre(x)为区间 $[0,x]$ 内奇数个数，显然 $pre(x)=\lfloor \frac{x+1}{2} \rfloor$ ,故区间[low,high]内奇数个数为 pre(high)-pre(low-1)</p><p><strong>计算机中乘除法运算没有移位运算快</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOdds</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pre</span>(high) - <span class="built_in">pre</span>(low - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>判断奇偶的方法</strong>：<code>x&amp;1</code></p><h3 id="1491-去掉最低工资和最高工资后的工资平均值"><a href="#1491-去掉最低工资和最高工资后的工资平均值" class="headerlink" title="1491. 去掉最低工资和最高工资后的工资平均值"></a>1491. 去掉最低工资和最高工资后的工资平均值</h3><p>第一想法，简单选择，一轮遍历，以为会超时竟然过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; salary)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> min = salary[<span class="number">0</span>];</span><br><span class="line">        <span class="type">double</span> max = salary[<span class="number">0</span>];</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; salary.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; salary[i])</span><br><span class="line">                min = salary[i];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; salary[i])</span><br><span class="line">                max = salary[i];</span><br><span class="line">            sum += salary[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum-min-max)/(salary.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>因为是新手村的入门题，甚至连数据都是唯一的，非常友好了。</li></ul><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>答案想法类似，只是用了 <strong>容器</strong> 的内置方法寻找最值</p><ul><li><code>algorithm</code> 库的 <code>max_element()、min_element()</code> 返回容器中最小值和最大值的 <strong>指针</strong></li><li><code>numeric</code> 库的 <code>accumulate(起点,终点,权值)</code> ：直接计算数组或者容器中C++内置数据类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//max_element()、min_element()</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; salary)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> maxValue = *<span class="built_in">max_element</span>(salary.<span class="built_in">begin</span>(), salary.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">double</span> minValue = *<span class="built_in">min_element</span>(salary.<span class="built_in">begin</span>(), salary.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">double</span> sum = <span class="built_in">accumulate</span>(salary.<span class="built_in">begin</span>(), salary.<span class="built_in">end</span>(), - maxValue - minValue);</span><br><span class="line">        <span class="keyword">return</span> sum / <span class="built_in">int</span>(salary.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution/qu-diao-zui-di-gong-zi-he-zui-gao-gong-zi-hou-de-4/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="0-2-运算符"><a href="#0-2-运算符" class="headerlink" title="0.2 运算符"></a>0.2 运算符</h2><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h3><p>第一想法是位运算，结合上面奇数的判断方法 <code>n&amp;1==1</code> ，则当前位为1，故1的个数加1。因为输入的二进制字符串长度不变呢，所以右移位数确定，循环判断条件也可是 <code>for(int i = 0;i &lt; 32;++i)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;<span class="comment">//右移一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>本题一开始卡在右移， <code>n&gt;&gt;1</code> 忘写赋值符号 <code>n&gt;&gt;=1</code> 导致死循环，判别为超时</li></ul><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>答案的第一种做法和上述类似，只是移位方向不同，第一想法是1不动，数字右移，答案第一种是数字不动，用1左移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode-solution-jnwf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>方法二：</p><p>这个真想不出来：n&amp;(n - 1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果</p><p>就是说</p><p>11111111111111111111111111111111 &amp; 11111111111111111111111111111110 变为 11111111111111111111111111111110</p><p>11111111111111111111111111111110 &amp; 11111111111111111111111111111101 变为 11111111111111111111111111111100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode-solution-jnwf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><ul><li>真值的二进制为logn,故时间复杂度为logn</li></ul><h3 id="1281-整数的各位积和之差"><a href="#1281-整数的各位积和之差" class="headerlink" title="1281. 整数的各位积和之差"></a>1281. 整数的各位积和之差</h3><p>求每个数位上的数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="type">int</span> a = n%<span class="number">10</span>;</span><br><span class="line">            sum += a;</span><br><span class="line">            product *= a;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product-sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(logN)$ 由于整数N的位数为 $\lceil log_{10}N = \frac{log_2{N}}{log_210} \rceil$ 即相差常数，故数量级为O(logN)</p><p>空间复杂度：O(1)</p><h2 id="0-3-条件语句"><a href="#0-3-条件语句" class="headerlink" title="0.3 条件语句"></a>0.3 条件语句</h2><h3 id="976-三角形的最大周长"><a href="#976-三角形的最大周长" class="headerlink" title="976. 三角形的最大周长"></a>976. 三角形的最大周长</h3><p>最初考虑只有三个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestPerimeter</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//122 112</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]+nums[<span class="number">1</span>] &lt;= nums[<span class="number">2</span>] || nums[<span class="number">2</span>]-nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/posts/2579725150/image-20220213085838921.png" alt></p><p>显然想简单了</p><p><strong>排序+贪心</strong>，从数组尾部开始逆序遍历，若找到可以构成三角形的，则直接输出其周长，若迭代器回到 <code>nums.begin()+1</code> 都不能构成三角形，则返回0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestPerimeter</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator it = nums.<span class="built_in">end</span>()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(it != nums.<span class="built_in">begin</span>()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it-*(it<span class="number">-2</span>) &lt; *(it<span class="number">-1</span>) &amp;&amp; *(it<span class="number">-2</span>)+*(it<span class="number">-1</span>) &gt; *it)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">accumulate</span>(it<span class="number">-2</span>,it+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            it--;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/posts/2579725150/image-20220213115943771.png" alt></p><p>显然效率不够高。还是看题解</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p><img src="/posts/2579725150/image-20220213120538464.png" alt></p><p>这么一看咱思想还是跟的上的。</p><h3 id="1779-找到最近的有相同-X-或-Y-坐标的点"><a href="#1779-找到最近的有相同-X-或-Y-坐标的点" class="headerlink" title="1779. 找到最近的有相同 X 或 Y 坐标的点"></a>1779. 找到最近的有相同 X 或 Y 坐标的点</h3><p>就一些数学库函数的运用，在设置 <code>min</code> 时，一开始用 $10^4$ 不对，以下示例会出错</p><p><img src="/posts/2579725150/image-20220218232211583.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nearestValidPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        <span class="type">int</span> idx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; points.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]==x || points[i][<span class="number">1</span>]==y)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; <span class="built_in">abs</span>(x-points[i][<span class="number">0</span>])+<span class="built_in">abs</span>(y-points[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                    min = <span class="built_in">abs</span>(x-points[i][<span class="number">0</span>])+<span class="built_in">abs</span>(y-points[i][<span class="number">1</span>]);</span><br><span class="line">                    idx = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0-4-循环"><a href="#0-4-循环" class="headerlink" title="0.4 循环"></a>0.4 循环</h2><h3 id="1822-数组元素积的符号"><a href="#1822-数组元素积的符号" class="headerlink" title="1822. 数组元素积的符号"></a>1822. 数组元素积的符号</h3><p>看完题，发现其返回只有 <code>-1/0/1</code> 三种，那就分三种情况</p><ul><li>有0，一定是0</li><li>负数个数是偶数，则1</li><li>负数个数是奇数，则-1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arraySign</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>) != nums.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果有0，则product与符号一定是0</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> negative = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(it != nums.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it&lt;<span class="number">0</span>)</span><br><span class="line">                negative++;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(negative&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种思路是逢-1变号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">arraySign</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">             <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sign *= <span class="number">-1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> sign;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="1502-判断能否形成等差数列"><a href="#1502-判断能否形成等差数列" class="headerlink" title="1502. 判断能否形成等差数列"></a>1502. 判断能否形成等差数列</h3><p>等差数列，就是每两个之间步长是相等的，排序后遍历一次，若发现有不相等的步长，则返回 <code>false</code> ，若可遍历到尾部，则返回 <code>true</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> step = arr[<span class="number">1</span>]-arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; arr.<span class="built_in">size</span>()<span class="number">-1</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(arr[i+<span class="number">1</span>]-arr[i]!=step)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>答案是利用等差数列相邻三项间的和的性质，但。。。加减法效率不应该比乘法效率高吗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] * <span class="number">2</span> != arr[i - <span class="number">1</span>] + arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><strong>递归+归纳</strong></p><ul><li>终止条件</li></ul><p>递归思想要解决的第一个问题是终止条件是什么，即什么情况下不是快乐数</p><p>我的做法是已知1一定是快乐数，返回<code>true</code></p><p>最开始想法是 <code>n&lt;10</code> ，将1剔除出去，剩下的返回 <code>false</code>。但是运行后，有实例没通过(7)</p><p>故将10以内的数挨个计算，最后只有 1 和 7 满足快乐数的要求</p><ul><li>递归内运算</li></ul><p>求出各位数字后平方求和，再调用递归函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isHappy</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><h5 id="集合元素的唯一性"><a href="#集合元素的唯一性" class="headerlink" title="集合元素的唯一性"></a>集合元素的唯一性</h5><p>若元素是快乐数，则经过运算，最后都会变为1</p><p>若元素不是快乐数，则经过运算，会进入循环，即运算过程中的数字会再次出现。</p><p>所以利用集合中元素的唯一性，将运算过程中的数字放入一个集合，若无法放入，说明已经有循环，则返回 <code>false</code>。若出现1，则返回 <code>true</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; s.<span class="built_in">find</span>(n) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(n);</span><br><span class="line">            n = <span class="built_in">getNext</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h5><blockquote><p>思想：将运算过程中的数，抽象为单链表的结点。若单链表有环，则说明运算过程重复，不是快乐数；若无环，说明是快乐数</p></blockquote><p>判断单链表是否有环的方法：<strong>快慢指针</strong></p><ul><li>初始化快慢指针</li><li>快指针转换两次，慢指针转换一次</li><li>当快指针<code>==</code>慢指针时，说明有环<ul><li>此时，当慢指针<code>==</code>1，说明是1的无限环，是快乐数</li><li>而慢指针!=1，说明不是快乐数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowRunner = n;</span><br><span class="line">        <span class="type">int</span> fastRunner = <span class="built_in">getNext</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = <span class="built_in">getNext</span>(slowRunner);</span><br><span class="line">            fastRunner = <span class="built_in">getNext</span>(<span class="built_in">getNext</span>(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="1790-仅执行一次字符串交换能否使两个字符串相等"><a href="#1790-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="1790. 仅执行一次字符串交换能否使两个字符串相等"></a>1790. 仅执行一次字符串交换能否使两个字符串相等</h3><ul><li><p>长度不同，则交换一次必不能相等</p></li><li><p>若本来相等，则返回 <code>true</code></p></li><li><p>长度相等且字符串不等，字符串逐字符遍历</p><ul><li><p>字符第一次不等，记录</p><p><strong>漏掉的情况</strong>：只有第一次不等，也需返回 <code>false</code></p><ul><li>aa 与 ac 就是上面的情况</li></ul></li><li><p>字符第二次不等，若与第一个不等位置交换后相等，则返回 <code>true</code></p></li><li><p>若字符第三次不等，则返回 <code>false</code></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">areAlmostEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>()!=s2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//长度不等必不成立</span></span><br><span class="line">        <span class="keyword">if</span>(s1==s2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> beg=<span class="number">-1</span>,end=s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s2.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(beg==<span class="number">-1</span> &amp;&amp; s2[i]!=s1[i])&#123;</span><br><span class="line">                beg = i;<span class="comment">//第一次不等</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(end==s2.<span class="built_in">size</span>() &amp;&amp; s2[i]!=s1[i])&#123;</span><br><span class="line">                end=i;</span><br><span class="line">                <span class="keyword">if</span>(s2[end]==s1[beg]&amp;&amp;s2[beg]==s1[end])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="comment">//第二次不等</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(beg != <span class="number">-1</span> &amp;&amp; end != s2.<span class="built_in">size</span>()  &amp;&amp; s2[i]!= s1[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//还有不等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(beg != <span class="number">-1</span> &amp;&amp; end == s2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//&quot;aa&quot;与&quot;ac&quot;的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><blockquote><p>构成两个字符串的字符即其出现的次数应该相同，并且最多只会出现两个位置的字符不同</p></blockquote><p>涉及到<strong>频次</strong>相关的问题，考虑采用<strong>哈希表</strong>去做。由于题目已提示 s1 和 s2 <strong>仅由小写英文字母</strong>组成，因此可以采用<strong>长度为 26 的整型数组模拟哈希表</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">areAlmostEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;<span class="comment">//记录字符串中各字符出现的频次</span></span><br><span class="line">            hash[s1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;<span class="comment">//如果某个字符出现次数是1，则不成立</span></span><br><span class="line">            <span class="keyword">if</span> (hash[s2[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">                cnt++;<span class="comment">//只有两个字符不等，则一次交换就可成功。才是true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//若超过两个字符不相等，则必不成立</span></span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">2</span> || cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0-5-函数"><a href="#0-5-函数" class="headerlink" title="0.5 函数"></a>0.5 函数</h2><h3 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a>1232. 缀点成线</h3><p>基本思路：找出一个线性关系，若所有点都满足该线性关系，则返回 <code>true</code> ,否则返回 <code>false</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求直线方程</span></span><br><span class="line">        <span class="type">double</span> k = (coordinates[<span class="number">0</span>][<span class="number">1</span>]-coordinates[<span class="number">1</span>][<span class="number">1</span>])/(coordinates[<span class="number">0</span>][<span class="number">0</span>]-coordinates[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="type">double</span> b = coordinates[<span class="number">0</span>][<span class="number">1</span>] - k*coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历，是否中间有点不在直线上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; coordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coordinates[i][<span class="number">1</span>] != k*coordinates[i][<span class="number">0</span>]+b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>报错原因：除零错误</p><p>[[0,0],[0,1],[0,-1]]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当斜率无穷大时</span></span><br><span class="line">        <span class="keyword">if</span>(coordinates[<span class="number">0</span>][<span class="number">0</span>]-coordinates[<span class="number">1</span>][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//若某一点横坐标值不相等，则不是一条直线</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; coordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coordinates[i][<span class="number">0</span>] != coordinates[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//求直线方程</span></span><br><span class="line">            <span class="type">double</span> k = (coordinates[<span class="number">0</span>][<span class="number">1</span>]-coordinates[<span class="number">1</span>][<span class="number">1</span>])/(coordinates[<span class="number">0</span>][<span class="number">0</span>]-coordinates[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="type">double</span> b = coordinates[<span class="number">0</span>][<span class="number">1</span>] - k*coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历，是否中间有点不在直线上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; coordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coordinates[i][<span class="number">1</span>] != k*coordinates[i][<span class="number">0</span>]+b)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是有错</p><p>[[2,1],[4,2],[6,3]] 预期结果 <code>true</code></p><p>原因：整型除法会截取整数结果，最后在转化为double</p><p>比如 <code>(double)(1/2)=double(0) = 0</code> 显然是错误的，正确做法是给分母或分子强制转化为浮点数类型，这样二元运算过程中，会将另一小范围数值转化为浮点数类型，使得最后结果为浮点数类型</p><p>如 <code>(double)1/2=1.0/2.0=0.5</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当斜率无穷大时</span></span><br><span class="line">        <span class="keyword">if</span>(coordinates[<span class="number">0</span>][<span class="number">0</span>]-coordinates[<span class="number">1</span>][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//若某一点横坐标值不相等，则不是一条直线</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; coordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coordinates[i][<span class="number">0</span>] != coordinates[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//求直线方程</span></span><br><span class="line">            <span class="type">double</span> k = (<span class="type">double</span>)(coordinates[<span class="number">0</span>][<span class="number">1</span>]-coordinates[<span class="number">1</span>][<span class="number">1</span>])/(coordinates[<span class="number">0</span>][<span class="number">0</span>]-coordinates[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="type">double</span> b = coordinates[<span class="number">0</span>][<span class="number">1</span>] - k*coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//遍历，是否中间有点不在直线上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; coordinates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coordinates[i][<span class="number">1</span>] != k*coordinates[i][<span class="number">0</span>]+b)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为避免 <strong>除0问题</strong> 和 <strong>精度问题</strong> 。将除法转化为乘法</p><script type="math/tex;mode=display">将判别式 \frac{y-y_0}{x-x_0}==\frac{y_1-y_0}{x_1-x_0}，变为(y_1-y_0)*(x-x_0)==(x_1-x_0)(y-y_0)</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=coordinates.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> dy=coordinates[<span class="number">0</span>][<span class="number">1</span>]-coordinates[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">double</span> dx=coordinates[<span class="number">0</span>][<span class="number">0</span>]-coordinates[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> x=coordinates[i][<span class="number">0</span>]-coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">double</span> y=coordinates[i][<span class="number">1</span>]-coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(x*dy!=y*dx)      </span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：sui-yi-fan-che</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/check-if-it-is-a-straight-line/solution/cxie-lu-zhuan-hua-wei-cheng-fa-de-jian-d-4qlr/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h3><p>二重循环，暴力破解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(nums1.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; nums1.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>(),nums1[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(it != nums2.<span class="built_in">end</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator ij = it+<span class="number">1</span>;ij != nums2.<span class="built_in">end</span>() ;++ij)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(*(ij) &gt; nums1[i])&#123;</span><br><span class="line">                        hash[i] = *ij;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m*n)</p><p>乘法阶的时间复杂度来源于每一轮都要查找nums2中的每个元素，若提前对nums2中元素进行O(m)处理，得到nums2中每个元素的目标元素，则整个算法的时间复杂度变为两轮遍历的时间复杂度O(m+n)</p><h4 id="求下一个更大的元素-单调栈-哈希表"><a href="#求下一个更大的元素-单调栈-哈希表" class="headerlink" title="求下一个更大的元素(单调栈+哈希表)"></a>求下一个更大的元素(单调栈+哈希表)</h4><ul><li><p>从右向左遍历：因要求的是从左到右的第一个，所以预处理时，从右向左处理，最后处理的元素即为最左元素</p></li><li><p>用单调栈中维护当前位置右边的更大的元素列表</p></li><li>每次我们移动到数组中一个新的位置 ii，就将当前单调栈中所有小于 nums2[i] 的元素弹出单调栈，当前位置右边的第一个更大的元素即为栈顶元素</li></ul><p>凡是求最近最XX的元素都可以用单调栈+哈希表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*单调栈+哈希表预处理*/</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashmap;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> num = nums2[i];</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; num &gt;= st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[num] = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运算过程</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res[i] = hashmap[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Next-Greater-Element模板"><a href="#Next-Greater-Element模板" class="headerlink" title="Next Greater Element模板"></a>Next Greater Element模板</h4><p>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]</p><p><img src="/posts/2579725150/1598145577-ziwCvD-1.png" alt></p><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i]) &#123; <span class="comment">// 判定个子高矮</span></span><br><span class="line">            s.<span class="built_in">pop</span>(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]); <span class="comment">// 进队，接受之后的身高判定吧！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="589-N-叉树的前序遍历"><a href="#589-N-叉树的前序遍历" class="headerlink" title="589. N 叉树的前序遍历"></a>589. N 叉树的前序遍历</h3><p>一开始以为要建树，想复杂了,所以直接看了答案，就是先序遍历的非递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        stack&lt;Node *&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Node *p = s.<span class="built_in">top</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">reverse</span>(p-&gt;children.<span class="built_in">begin</span>(),p-&gt;children.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; p-&gt;children.<span class="built_in">size</span>();++i)</span><br><span class="line">                s.<span class="built_in">push</span>(p-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>附上递归做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">(Node *root,vector&lt;<span class="type">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span>(Node *p:root-&gt;children)</span><br><span class="line">            <span class="built_in">Traverse</span>(p,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">Traverse</span>(root,ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0-6-数组"><a href="#0-6-数组" class="headerlink" title="0.6 数组"></a>0.6 数组</h2><h3 id="1588-所有奇数长度子数组的和"><a href="#1588-所有奇数长度子数组的和" class="headerlink" title="1588. 所有奇数长度子数组的和"></a>1588. 所有奇数长度子数组的和</h3><p>部分和，想到了前缀和的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求前缀和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(arr.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; arr.<span class="built_in">size</span>();++i)</span><br><span class="line">            s[i+<span class="number">1</span>] = s[i]+arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxodd = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((arr.<span class="built_in">size</span>()&amp;<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">            maxodd = arr.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(maxodd!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = arr.<span class="built_in">size</span>();i &gt;= maxodd;i--)&#123;</span><br><span class="line">                sum += s[i]-s[i-maxodd];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxodd -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(n)$</p><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><p>借助一个辅助数组，快慢指针，最后末尾补零</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                tmp[cnt++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            nums[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;<span class="comment">//nums游标为快指针</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;j &lt; len;++j)</span><br><span class="line">            nums[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1672-最富有客户的资产总量"><a href="#1672-最富有客户的资产总量" class="headerlink" title="1672. 最富有客户的资产总量"></a>1672. 最富有客户的资产总量</h3><p>求和，遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumWealth</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> len = accounts.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">accumulate</span>(&amp;accounts[i][<span class="number">0</span>],&amp;accounts[i][<span class="number">0</span>]+accounts[i].<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(max &lt; sum)</span><br><span class="line">                max = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1572-矩阵对角线元素的和"><a href="#1572-矩阵对角线元素的和" class="headerlink" title="1572. 矩阵对角线元素的和"></a>1572. 矩阵对角线元素的和</h3><p>求对角线元素的和</p><ul><li><p>主对角线：横纵坐标下标相等</p></li><li><p>副对角线：横+纵=方阵维度-1</p></li><li><p>当是奇数维方阵，会加两次中心元素</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diagonalSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = mat.<span class="built_in">size</span>();<span class="comment">//矩阵的行</span></span><br><span class="line">        <span class="type">int</span> sum = r&amp;<span class="number">1</span>?sum = -mat[r/<span class="number">2</span>][r/<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; mat.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; mat[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                    sum += mat[i][j];</span><br><span class="line">                <span class="keyword">if</span>(i+j == r<span class="number">-1</span>)</span><br><span class="line">                    sum += mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$</p><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>由于目标元素下标的关系</p><ul><li><p>主对角线：横纵坐标下标相等</p></li><li><p>副对角线：横+纵=方针维度-1</p></li></ul><p>第一行(0)：a[0][0]+a[0][n-1-0]</p><p>第二行(1)：a[1][1]+a[1][n-1-1]</p><p>第三行(2)：a[2][2]+a[2][n-1-2]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diagonalSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = mat.<span class="built_in">size</span>(), sum = <span class="number">0</span>, mid = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += mat[i][i] + mat[i][n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - mat[mid][mid] * (n &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/matrix-diagonal-sum/solution/ju-zhen-dui-jiao-xian-yuan-su-de-he-by-leetcode-so/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$</p><h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a>566. 重塑矩阵</h3><p>由于vector的二维矩阵行之间不连续，所以不能直接按一维数组使用，需转成一维数组，在转为二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123; </span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="type">int</span> ElementCount = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; array;<span class="comment">//二维变一维</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; mat.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; mat[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                ElementCount++;</span><br><span class="line">                array.<span class="built_in">push_back</span>(mat[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不合法输入</span></span><br><span class="line">        <span class="keyword">if</span>(r*c &gt; ElementCount)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(r,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c));</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;<span class="comment">//一维数组下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; r;++i)&#123;</span><br><span class="line">            ans[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; c;++j)&#123;</span><br><span class="line">                ans[i].<span class="built_in">push_back</span>(array[idx++]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输入：</p><p>[[1,2]] 1 1</p><p>输出：</p><p>[[1]]</p><p>预期结果：</p><p>[[1,2]]</p><p>这谁顶得住，题意是说 <code>r*c != ElementCount</code> ，就输出原矩阵，我以为目标矩阵元素数小于原矩阵会发生截取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123; </span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="type">int</span> ElementCount = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; array;<span class="comment">//二维变一维</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; mat.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; mat[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                ElementCount++;</span><br><span class="line">                array.<span class="built_in">push_back</span>(mat[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不合法输入</span></span><br><span class="line">        <span class="keyword">if</span>(r*c != ElementCount)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(r,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c));</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;<span class="comment">//一维数组下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; r;++i)&#123;</span><br><span class="line">            ans[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; c;++j)&#123;</span><br><span class="line">                ans[i].<span class="built_in">push_back</span>(array[idx++]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="多个二维数组下标之间的映射关系"><a href="#多个二维数组下标之间的映射关系" class="headerlink" title="多个二维数组下标之间的映射关系"></a>多个二维数组下标之间的映射关系</h4><p>来看答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m * n != r * c) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; m * n; ++x) &#123;</span><br><span class="line">            ans[x / c][x % c] = nums[x / n][x % n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/reshape-the-matrix/solution/zhong-su-ju-zhen-by-leetcode-solution-gt0g/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>相当于模拟一个一维数组，mat映射到array中，array中数组再映射到ans数组中</p><p>$mat[i][j]\Rightarrow array[idx]$</p><script type="math/tex;mode=display">idx = i*n+j(n为mat的列数)</script><p>$array[idx]\Rightarrow ans[p][q]$</p><script type="math/tex;mode=display">p = idx/c(c为ans列数)\\
q = idx\%c</script><p>故可由一维数组下标建立两个二维数组之间关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c));<span class="comment">//初始化定义ans的行，每行初值</span></span><br><span class="line"><span class="comment">//ans(行数,每行初值为长度为c的vector&lt;int&gt;类型的一维数组)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; m * n; ++x) &#123;</span><br><span class="line">    ans[x / c][x % c] = nums[x / n][x % n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-7-字符串"><a href="#0-7-字符串" class="headerlink" title="0.7 字符串"></a>0.7 字符串</h2><h3 id="1768-交替合并字符串"><a href="#1768-交替合并字符串" class="headerlink" title="1768. 交替合并字符串"></a>1768. 交替合并字符串</h3><p>类似于链表合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">mergeAlternately</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len1 = word1.<span class="built_in">size</span>(),len2 = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len1&amp;&amp;j &lt; len2;++i,++j)&#123;</span><br><span class="line">            ans += word1[i];</span><br><span class="line">            ans += word2[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i != len1)</span><br><span class="line">            ans += word1.<span class="built_in">substr</span>(i,len1-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j != len2)</span><br><span class="line">            ans += word2.<span class="built_in">substr</span>(i,len2-j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1678-设计-Goal-解析器"><a href="#1678-设计-Goal-解析器" class="headerlink" title="1678. 设计 Goal 解析器"></a>1678. 设计 Goal 解析器</h3><p>字符串遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">interpret</span><span class="params">(string command)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; command.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(command[i] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">                ans += <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(command[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(command[i+<span class="number">1</span>]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    ans += <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(command[i+<span class="number">1</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                    ans += <span class="string">&quot;al&quot;</span>;</span><br><span class="line">                    i = i+<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n)$</p><h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><ul><li>将”()”replace为”o”</li><li>将”(“replace为””</li><li>将”)”replace为””</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replace_all</span><span class="params">(string &amp;src,string old,<span class="type">int</span> n0,string newStr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用newStr全局替换old中的n0个字符</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            idx = src.<span class="built_in">find</span>(old,idx+<span class="number">1</span>);<span class="comment">//从字符串的str[idx]开始查找old,返回找到的第一个</span></span><br><span class="line">            <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            src.<span class="built_in">replace</span>(idx,n0,newStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">interpret</span><span class="params">(string command)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">replace_all</span>(command,<span class="string">&quot;()&quot;</span>,<span class="number">2</span>,<span class="string">&quot;o&quot;</span>);</span><br><span class="line">        <span class="built_in">replace_all</span>(command,<span class="string">&quot;(&quot;</span>,<span class="number">1</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">replace_all</span>(command,<span class="string">&quot;)&quot;</span>,<span class="number">1</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a>389. 找不同</h3><p>一开始以为不同的字符一定只出现一次，所以只要找t中有且其哈希表为0的字符即可，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            bucket[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; t.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[t[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输入：</p><p>“a” “aa”</p><p>输出：</p><p>“”</p><p>预期结果：</p><p>“a”</p><p>那就设两个哈希表，对比不相等的字符数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket1</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket2</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            bucket1[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; t.<span class="built_in">size</span>();++i)</span><br><span class="line">            bucket2[t[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">26</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket1[i] != bucket2[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>+i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>同样是哈希啊，人家只用了一个辅助数组</p><p>s中的+，t中的-</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            cnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            cnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/find-the-difference/solution/zhao-bu-tong-by-leetcode-solution-mtqf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n)$</p><h4 id="ASCII本质也是数值"><a href="#ASCII本质也是数值" class="headerlink" title="ASCII本质也是数值"></a>ASCII本质也是数值</h4><p>每个字符求和，两字符和差值即为添加的字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            as += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: t) &#123;</span><br><span class="line">            at += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> at - as;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/find-the-difference/solution/zhao-bu-tong-by-leetcode-solution-mtqf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="709-转换成小写字母"><a href="#709-转换成小写字母" class="headerlink" title="709. 转换成小写字母"></a>709. 转换成小写字母</h3><p>没仔细看题，以为是由大小写字母组成字符串s</p><p><img src="/posts/2579725150/image-20220219085741763.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toLowerCase</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 97-65</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; <span class="number">97</span>)</span><br><span class="line">                s[i] += <span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toLowerCase</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 97-65</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                s[i] += <span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h4><p>方法一：algorithm有自带的函数 <code>s.tolower(),s.toupper()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toLowerCase</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; ch: s) &#123;</span><br><span class="line">            ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/to-lower-case/solution/zhuan-huan-cheng-xiao-xie-zi-mu-by-leetc-5e29/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>方法二：按位或替代加法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toLowerCase</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="number">65</span> &amp;&amp; ch &lt;= <span class="number">90</span>) &#123;</span><br><span class="line">                ch |= <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/to-lower-case/solution/zhuan-huan-cheng-xiao-xie-zi-mu-by-leetc-5e29/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="1309-解码字母到整数映射"><a href="#1309-解码字母到整数映射" class="headerlink" title="1309. 解码字母到整数映射"></a>1309. 解码字母到整数映射</h3><p>atoi()的参数是 const char<em> ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char</em>类型的,而stoi()的参数是const string<em>,不需要转化为 const char</em>；</p><p>第一想法是正序遍历，找到#后回溯，处理完两位数的在处理一位数的，时间复杂度为 $O(n^2)$,源于for循环内的find</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">freqAlphabets</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找到所有#</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>;<span class="comment">//记录#下标</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//记录#个数</span></span><br><span class="line">        string ss = s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            idx = s.<span class="built_in">find</span>(<span class="string">&quot;#&quot;</span>,idx+<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">if</span>(idx == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//替换每个#组合</span></span><br><span class="line">            string t;</span><br><span class="line">            t.<span class="built_in">push_back</span>((<span class="type">char</span>)(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(idx<span class="number">-2</span>,<span class="number">2</span>))+<span class="number">96</span>)); </span><br><span class="line">            ss.<span class="built_in">replace</span>(idx<span class="number">-2</span><span class="number">-2</span>*cnt,<span class="number">3</span>,t);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ss.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[i] &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; ss[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                ss[i] = <span class="string">&#x27;a&#x27;</span>+ss[i]<span class="number">-49</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对上述代码优化，变为 $O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">freqAlphabets</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找到所有#</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>;<span class="comment">//记录#下标</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//记录#个数</span></span><br><span class="line">        string ss = s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">            idx = s.<span class="built_in">find</span>(<span class="string">&quot;#&quot;</span>,idx+<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">if</span>(idx == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//替换每个#组合</span></span><br><span class="line">            string t;</span><br><span class="line">            t.<span class="built_in">push_back</span>((<span class="type">char</span>)(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(idx<span class="number">-2</span>,<span class="number">2</span>))+<span class="number">96</span>)); </span><br><span class="line">            ss.<span class="built_in">replace</span>(idx<span class="number">-2</span><span class="number">-2</span>*cnt,<span class="number">3</span>,t);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ss.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[i] &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; ss[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                ss[i] = <span class="string">&#x27;a&#x27;</span>+ss[i]<span class="number">-49</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/posts/2579725150/image-20220219104501728.png" alt></p><p>不管怎么说都算是优化了吧</p><p>第二种思路是逆序，不需要两层循环，若是 # ，则回退三步；若是数字，则直接变字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">freqAlphabets</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                string t;</span><br><span class="line">                t.<span class="built_in">push_back</span>((<span class="type">char</span>)(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(i<span class="number">-2</span>,<span class="number">2</span>))+<span class="number">97</span><span class="number">-1</span>));</span><br><span class="line">                <span class="comment">// cout &lt;&lt; char(stoi(s.substr(i-2,2))+97-1) &lt;&lt; endl;</span></span><br><span class="line">                s.<span class="built_in">replace</span>(i<span class="number">-2</span>,<span class="number">3</span>,t);</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="number">48</span> &amp;&amp; s[i] &lt;= <span class="number">57</span>)&#123;</span><br><span class="line">                <span class="comment">// s[i] = s[i]-48+97-1;</span></span><br><span class="line">                s[i] = s[i]+<span class="number">48</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/posts/2579725150/image-20220219110527978.png" alt></p><p>这个有点匪夷所思，时间复杂度是$O(n)$ ,空间差这么多</p><h4 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h4><p>对哈，正序直接新建空字符串开始也行啊。我的麻烦点在于折腾一些库函数浪费了时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">freqAlphabets</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ans += <span class="built_in">char</span>((s[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i + <span class="number">1</span>] - <span class="string">&#x27;1&#x27;</span>) + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="built_in">char</span>(s[i] - <span class="string">&#x27;1&#x27;</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/solution/jie-ma-zi-mu-dao-zheng-shu-ying-she-by-leetcode-so/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="953-验证外星语词典"><a href="#953-验证外星语词典" class="headerlink" title="953. 验证外星语词典"></a>953. 验证外星语词典</h3><p>建立 $abc…xyz\rightarrow 1,3,…,26$ 映射的哈希表，按 <code>order</code> 顺序，第一个为权值为26，依次递减。</p><p>匹配：</p><ul><li>相邻单词长度相等，符合字典序</li><li>第一个单词时第二个单词的前缀，符合字典序，如：<code>[&quot;app&quot;,&quot;apple&quot;]</code></li><li>第一个单词是第二个单词的后缀，不符合字典序，如：<code>[&quot;apple&quot;,&quot;app&quot;]</code></li><li>一般情况：hash[s1[i]] &lt; hash[s2[i]]，则返回 <code>false</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建立哈希表</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;++i)&#123;</span><br><span class="line">            hash[order[i]<span class="number">-97</span>] = <span class="number">26</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历单词表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; words.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//找到相邻单词的第一个不相等字母</span></span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; words[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(words[i][j] != words[i+<span class="number">1</span>][j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//相邻单词相等情况</span></span><br><span class="line">           	<span class="keyword">if</span>(j == words[i].<span class="built_in">size</span>() &amp;&amp; j == words[i+<span class="number">1</span>].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果前一个单词时前一个单词后缀，则返回false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == words[i+<span class="number">1</span>].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//如果前一个单词时后一个单词前缀，继续遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == words[i].<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果前一个单词的hash小于后一个单词，则犯规false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(hash[words[i][j]<span class="number">-97</span>] &lt; hash[words[i+<span class="number">1</span>][j]<span class="number">-97</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="08-链表-amp-树"><a href="#08-链表-amp-树" class="headerlink" title="08. 链表&amp;树"></a>08. 链表&amp;树</h2><h3 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a>1290. 二进制链表转整数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链表不为空，所以不判断空</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != <span class="number">0</span>)   </span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里就把链表当做一个数组，只不过遍历方式不同</p><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h3><p>笨办法：两轮遍历，第一轮获取长度，第二轮获取结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = cnt/<span class="number">2</span>;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; mid;++i)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/posts/2579725150/image-20220220083956249.png" alt></p><p>带点套路：快慢指针，快指针走两步，慢指针走一步</p><p><img src="/posts/2579725150/image-20220220085120762.png" alt></p><p>链表判空，给人整不会了</p><h4 id="题解——快慢指针"><a href="#题解——快慢指针" class="headerlink" title="题解——快慢指针"></a>题解——快慢指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//单数情况为fast-&gt;next ==NULL,双数情况是fast为NULL</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p>用递归层数表示树的最大深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//r的左子树深度与右子树深度取最大值max,返回max+1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根为空</span></span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(r-&gt;left == <span class="literal">NULL</span> &amp;&amp; r-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftdep = <span class="number">0</span>;<span class="comment">//左子树深度</span></span><br><span class="line">        <span class="type">int</span> rightdep = <span class="number">0</span>;<span class="comment">//右子树深度</span></span><br><span class="line">        <span class="keyword">if</span>(r-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            leftdep = <span class="built_in">maxDepth</span>(r-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            rightdep = <span class="built_in">maxDepth</span>(r-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftdep &gt; rightdep)</span><br><span class="line">            <span class="keyword">return</span> leftdep+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> rightdep+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p><p>空间复杂度：$O(height)$，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p><h4 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h4><p>层序遍历，借助一个队列</p><p>根入队，队不空</p><ul><li>队中所有结点出队</li><li>每出一个结点，将其子节点全部入队</li><li>每判空一次，深度加一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空树，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="type">int</span> cnt = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(cnt)&#123;</span><br><span class="line">                TreeNode* p = Q.<span class="built_in">front</span>();</span><br><span class="line">                Q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    Q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    Q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h3><p>还是递归，如果直接走到叶子结点，无法判断是左叶子还是右叶子，而且不想引入多余父指针，所以判断叶子结点的父结点</p><ul><li><p>第一种情况是左子树为左叶子，右子树为空，此时只需要返回左叶子值即可</p><p><img src="/posts/2579725150/image-20220220100306035.png" alt></p></li><li><p>第二种情况是左子树为左叶子，右子树不为空，此时，需要判断右子树是否也有左叶子</p><p><img src="/posts/2579725150/image-20220220100242997.png" alt></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回左子树左叶子+右子树左叶子</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumTree</span><span class="params">(TreeNode * r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左叶子的上一层结点</span></span><br><span class="line">        <span class="comment">//第一种情况是左子树为左叶子，右子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(r-&gt;right == <span class="literal">nullptr</span> &amp;&amp; r-&gt;left &amp;&amp; r-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; r-&gt;left-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> r-&gt;left-&gt;val;</span><br><span class="line">        <span class="comment">//第二种情况是左子树为左叶子，右子树不空</span></span><br><span class="line">        <span class="keyword">if</span>(r-&gt;right &amp;&amp; r-&gt;left &amp;&amp; r-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; r-&gt;left-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            sum = r-&gt;left-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r-&gt;left)</span><br><span class="line">            sum += <span class="built_in">sumTree</span>(r-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;right)</span><br><span class="line">            sum += <span class="built_in">sumTree</span>(r-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//只有一个根结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumTree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二种思路是迭代：层序遍历（广搜）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只有一个根结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode *&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *p = Q.<span class="built_in">front</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                Q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                Q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left &amp;&amp; p-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; p-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">                ans += p-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/2579725150/" title="0.编程能力">https://amostian.github.io/posts/2579725150/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tags"></i> 算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/" rel="tag"><i class="fa fa-tags"></i> 编程能力</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1093045828/" rel="prev" title="注解与反射"><i class="fa fa-chevron-left"></i> 注解与反射</a></div><div class="post-nav-item"><a href="/posts/1907208344/" rel="next" title="1.函数">1.函数 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">0.1 基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1523-%E5%9C%A8%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%BB%9F%E8%AE%A1%E5%A5%87%E6%95%B0%E6%95%B0%E7%9B%AE"><span class="nav-text">1523.在区间范围内统计奇数数目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E6%83%B3"><span class="nav-text">前缀和思想</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1491-%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B7%A5%E8%B5%84%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-text">1491. 去掉最低工资和最高工资后的工资平均值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3"><span class="nav-text">题解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-2-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">0.2 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">191. 位1的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-1"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1281-%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE"><span class="nav-text">1281. 整数的各位积和之差</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-3-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-text">0.3 条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF"><span class="nav-text">976. 三角形的最大周长</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-2"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1779-%E6%89%BE%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E6%9C%89%E7%9B%B8%E5%90%8C-X-%E6%88%96-Y-%E5%9D%90%E6%A0%87%E7%9A%84%E7%82%B9"><span class="nav-text">1779. 找到最近的有相同 X 或 Y 坐标的点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-4-%E5%BE%AA%E7%8E%AF"><span class="nav-text">0.4 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1822-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="nav-text">1822. 数组元素积的符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1502-%E5%88%A4%E6%96%AD%E8%83%BD%E5%90%A6%E5%BD%A2%E6%88%90%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97"><span class="nav-text">1502. 判断能否形成等差数列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-3"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-text">202. 快乐数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-4"><span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="nav-text">集合元素的唯一性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-text">快慢指针法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1790-%E4%BB%85%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E6%8D%A2%E8%83%BD%E5%90%A6%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89"><span class="nav-text">1790. 仅执行一次字符串交换能否使两个字符串相等</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-5"><span class="nav-text">题解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-5-%E5%87%BD%E6%95%B0"><span class="nav-text">0.5 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF"><span class="nav-text">1232. 缀点成线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I"><span class="nav-text">496. 下一个更大元素 I</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0-%E5%8D%95%E8%B0%83%E6%A0%88-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">求下一个更大的元素(单调栈+哈希表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Next-Greater-Element%E6%A8%A1%E6%9D%BF"><span class="nav-text">Next Greater Element模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#589-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">589. N 叉树的前序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-6-%E6%95%B0%E7%BB%84"><span class="nav-text">0.6 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C"><span class="nav-text">1588. 所有奇数长度子数组的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-text">283. 移动零</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-text">快慢指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1672-%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F"><span class="nav-text">1672. 最富有客户的资产总量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1572-%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C"><span class="nav-text">1572. 矩阵对角线元素的和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-6"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5"><span class="nav-text">566. 重塑矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="nav-text">多个二维数组下标之间的映射关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-7-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">0.7 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1768-%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">1768. 交替合并字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1678-%E8%AE%BE%E8%AE%A1-Goal-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">1678. 设计 Goal 解析器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-7"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#389-%E6%89%BE%E4%B8%8D%E5%90%8C"><span class="nav-text">389. 找不同</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-text">哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ASCII%E6%9C%AC%E8%B4%A8%E4%B9%9F%E6%98%AF%E6%95%B0%E5%80%BC"><span class="nav-text">ASCII本质也是数值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D"><span class="nav-text">709. 转换成小写字母</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-8"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1309-%E8%A7%A3%E7%A0%81%E5%AD%97%E6%AF%8D%E5%88%B0%E6%95%B4%E6%95%B0%E6%98%A0%E5%B0%84"><span class="nav-text">1309. 解码字母到整数映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-9"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#953-%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8"><span class="nav-text">953. 验证外星语词典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#08-%E9%93%BE%E8%A1%A8-amp-%E6%A0%91"><span class="nav-text">08. 链表&amp;树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-text">1290. 二进制链表转整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="nav-text">876. 链表的中间结点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-text">题解——快慢指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-10"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-text">404. 左叶子之和</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">375</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">60</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">78</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">954.8k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">40:11</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>