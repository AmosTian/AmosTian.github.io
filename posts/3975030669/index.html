<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="线性表是一种逻辑结构   本文总结的应用部分代码来源于王道数据结构相应部分课后题"><meta property="og:type" content="article"><meta property="og:title" content="2.线性表"><meta property="og:url" content="https://amostian.github.io/posts/3975030669/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="线性表是一种逻辑结构   本文总结的应用部分代码来源于王道数据结构相应部分课后题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124121623414.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124172446352.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124173242186.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125101604574.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220122195235320.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124185509245.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124193849811.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124194720668.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124202604073.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124223844512.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124233748401.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220124233713884.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125093841548.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125100324388.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125102922240.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125112441908.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125184445502.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125222539554.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125224019771.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125224111965.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220125231352529.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220126180218361.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220126182807378.png"><meta property="og:image" content="https://amostian.github.io/posts/3975030669/image-20220126192811630.png"><meta property="article:published_time" content="2024-01-26T10:50:57.955Z"><meta property="article:modified_time" content="2023-03-22T13:37:50.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="计算机基础"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/3975030669/image-20220124121623414.png"><link rel="canonical" href="https://amostian.github.io/posts/3975030669/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>2.线性表 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">61</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">390</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/3975030669/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">2.线性表</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2024-01-26 18:50:57" itemprop="dateCreated datePublished" datetime="2024-01-26T18:50:57+08:00">2024-01-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2023-03-22 21:37:50" itemprop="dateModified" datetime="2023-03-22T21:37:50+08:00">2023-03-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">12.4k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>31 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>线性表是一种逻辑结构</p><p>本文总结的应用部分代码来源于王道数据结构相应部分课后题</p></blockquote><span id="more"></span><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><blockquote><p><strong>线性表</strong>：具有相同数据类型的 n ($n\ge0$)个数据元素的有限序列</p><p>$n=0$ 为 <em>空表</em></p></blockquote><p>表示为：</p><blockquote><p>L = ($a_1,a_2…,a_i,a_{i+1},…,a_n$)</p></blockquote><p>（1）存在唯一一个被称为 “第一个” 的数据元素—— $a_1$：<em>表头元素</em></p><p>（2）存在唯一一个被称为 “最后一个” 的数据元素—— $a_n$：<em>表尾元素</em></p><p>（3）除第一个之外，集合中的每个数据元素只有一个 <em>直接前驱</em></p><p>（4）除最后一个外，集合中每个数据元素只有一个 <em>直接后继</em></p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点"></a>2.1.1 特点</h3><ol><li><p>数据元素个数有限</p></li><li><p>元素间有逻辑上的顺序性</p></li><li><p>表中元素都是 <em>数据元素</em></p><p>元素具有抽象性：只讨论元素间的逻辑关系，不考虑具体表示什么</p></li><li><p>表中元素 <em>数据类型相同</em></p><p>单个元素占用的存储空间相同</p></li></ol><blockquote><p>当数据元素由若干数据项组成：</p><ul><li>记录：数据元素</li><li>文件：含有大量记录的线性表</li></ul></blockquote><div style="page-break-after:always"></div><h3 id="2-1-2-线性表是一种逻辑结构"><a href="#2-1-2-线性表是一种逻辑结构" class="headerlink" title="2.1.2 线性表是一种逻辑结构"></a>2.1.2 线性表是一种逻辑结构</h3><blockquote><p>表示元素之间一对一的相邻关系</p></blockquote><p>实现线性表的两种存储结构</p><ul><li>顺序存储</li><li>链式存储</li></ul><p>线性表基本操作的实现</p><ul><li>存储结构不同，算法实现也不同</li><li>&amp;：C++引用</li></ul><h3 id="2-1-3-基本操作"><a href="#2-1-3-基本操作" class="headerlink" title="2.1.3 基本操作"></a>2.1.3 基本操作</h3><ul><li>InitList(&amp;L);初始化线性表</li><li>Length(L);获取线性表中元素个数</li><li>LocateElem(L,e);获取元素e在线性表中的位置</li><li>GetElem(L,i);获取第i个元素</li><li>ListInsert(&amp;L,i,e);将e插入到第i个位置</li><li>PrintList(L);输出线性表中元素</li><li>DetoryList(&amp;L);销毁线性表</li></ul><div style="page-break-after:always"></div><h2 id="2-2-线性表的存储"><a href="#2-2-线性表的存储" class="headerlink" title="2.2 线性表的存储"></a>2.2 线性表的存储</h2><h3 id="2-2-1-线性表的顺序存储——顺序表"><a href="#2-2-1-线性表的顺序存储——顺序表" class="headerlink" title="2.2.1 线性表的顺序存储——顺序表"></a>2.2.1 线性表的顺序存储——顺序表</h3><p><strong>位序与下标的区别</strong></p><ul><li>位序：$1\le i \le length$</li><li>下标：$0\le i \le length-1$</li></ul><p><strong>动态分配</strong></p><ul><li>动态分配属于 <em>顺序存储</em> 结构，分配 $n$ 个空间时仍需要 $n$ 个连续存储空间</li></ul><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><ul><li><p>随机存取—— $O(1)$</p><p>$Loc(a_i)=Loc(a_0)+(i-1)*sizeof(ElemType)$</p></li><li><p>存储密度高——只存数据元素</p></li><li><p>存储关系映射逻辑关系</p></li><li><p>插入删除效率低</p></li></ul><h4 id="2-结点定义"><a href="#2-结点定义" class="headerlink" title="2. 结点定义"></a>2. 结点定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">/* 静态分配 */</span></span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INITSIZE 10<span class="comment">//初始空间容量</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INCREMENT 10<span class="comment">//增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">/* 动态分配 */</span></span><br><span class="line">	ElemType *elem;	<span class="comment">//存储空间基址</span></span><br><span class="line">	<span class="type">int</span> length;		<span class="comment">//线性表当前长度</span></span><br><span class="line">    <span class="type">int</span> listSize;	<span class="comment">//存储容量</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h4 id="3-基本操作实现"><a href="#3-基本操作实现" class="headerlink" title="3. 基本操作实现"></a>3. 基本操作实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态分配 初始化一个空表</span></span><br><span class="line">Status <span class="title function_">ListInit_sq</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    L.elem = (ElemType *)<span class="built_in">malloc</span>(INITSIZE*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!L.elem)</span><br><span class="line">        <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listSize = INITSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType x)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断输入是否正确 </span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">//2.判断表空间是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= L.listSize)&#123;</span><br><span class="line">		ElemType* newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem,(L.listSize+INCREMENT)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listSize += INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.插入位置元素与之后元素要后移</span></span><br><span class="line">	ElemType* p = &amp;(L[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(ElemType* p = &amp;(L[length<span class="number">-1</span>]);p&gt;=q;)</span><br><span class="line">        *(p+<span class="number">1</span>) = *p;</span><br><span class="line">    <span class="comment">//4.插入数据</span></span><br><span class="line">    *q = x;</span><br><span class="line">    L.length++;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;x)</span> &#123;</span><br><span class="line">	<span class="comment">//1.判断输入是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) </span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="comment">//2.找到删除位置</span></span><br><span class="line">	ElemType* p = &amp;(L[i<span class="number">-1</span>]);</span><br><span class="line">    x = L.data[i - <span class="number">1</span>];<span class="comment">//返回待删除元素</span></span><br><span class="line">    <span class="comment">//3.删除元素</span></span><br><span class="line">    <span class="keyword">while</span>(p&lt;&amp;(L[L.length<span class="number">-1</span>]))&#123;</span><br><span class="line">        *p = *(p+<span class="number">1</span>);<span class="comment">//从第i个元素，将其后继元素前移一位</span></span><br><span class="line">    	p++;</span><br><span class="line">    &#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>插入</th><th>删除</th><th>按值查找</th></tr></thead><tbody><tr><td>最好</td><td>表尾插入，不移动元素 $O(1)$</td><td>表尾删除，不移动元素 $O(1)$</td><td>遍历一次$O(1)$</td></tr><tr><td>最坏</td><td>表头插入，移动 $n$ 个元素 $O(n)$</td><td>表头删除，移动 $n-1$ 各元素 $O(n)$</td><td>表尾，$O(n)$</td></tr><tr><td>期望</td><td>$\sum_{i=1}^n{p_i(n-i+1)}$</td><td>$\sum_{i=1}^nq_i{(n-i)}$</td><td></td></tr><tr><td>平均移动次数</td><td>$\frac{1}{n+1}\sum_{i=1}^n{(n-i+1)} = \frac{n}{2}$</td><td>$\frac{1}{n}\sum_{i=1}^n{(n-i)} = \frac{n-1}{2}$</td><td></td></tr><tr><td>平均时间复杂度</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td></tr><tr><td>空间复杂度</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table></div><blockquote><p>假设对每个元素访问的等概率,即期望中的概率为算数平均数</p></blockquote><div style="page-break-after:always"></div><h4 id="4-顺序表应用"><a href="#4-顺序表应用" class="headerlink" title="4. 顺序表应用"></a>4. 顺序表应用</h4><ul><li><p>辨别 <em>顺序表</em> 和 <em>有序表</em></p><ul><li>顺序表 ：线性表的顺序 <em>存储结构</em></li><li>有序表：表中元素按某一关键字递增或递减排序的 <em>线性表</em></li></ul></li><li><p><em>插入</em> 总是发生在 <em>顺序表尾</em></p></li><li>顺序表的修改操作，一定会涉及遍历元素<ul><li>只要是顺序遍历，时间复杂度不会低于 $O(n)$<ul><li>最短时间遍历一般要用 <em>折半查找</em></li></ul></li></ul></li></ul><h5 id="两表合并"><a href="#两表合并" class="headerlink" title="两表合并"></a>两表合并</h5><h6 id="顺序表合并返回顺序表"><a href="#顺序表合并返回顺序表" class="headerlink" title="顺序表合并返回顺序表"></a>顺序表合并返回顺序表</h6><blockquote><p><em>思路</em> ：短表的下标为结果表的下标</p><p>时间复杂度：$O(n)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Merge</span><span class="params">(SqList A, SqList B, SqList &amp;C)</span> </span>&#123;<span class="comment">//合并两表</span></span><br><span class="line">	<span class="keyword">if</span> (A.length + B.length &gt; C.MaxSize + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//超长退出</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A.data[i] &lt;= B.data[j]) <span class="comment">//两两比较，小者插入</span></span><br><span class="line">			C.data[k++] = A.data[i++];</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			C.data[k++] = B.data[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有一表为遍历完情况</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; A.length) </span><br><span class="line">		C.data[k++] = A.data[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt; B.length) </span><br><span class="line">		C.data[k++] = B.data[j++];</span><br><span class="line">	</span><br><span class="line">	C.length = k;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><h6 id="有序顺序表去重"><a href="#有序顺序表去重" class="headerlink" title="有序顺序表去重"></a>有序顺序表去重</h6><blockquote><p><em>思路</em> ：快慢指针，<code>i</code> 为慢指针，即结果表游标</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteDuplicate</span><span class="params">(SqList &amp;L)</span> </span>&#123;<span class="comment">//从有序顺序表删除重复值</span></span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> i, j;<span class="comment">//j为工作指针，遍历每个元素</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; L.length; ++j)</span><br><span class="line">		<span class="keyword">if</span> (L.data[j] != L.data[i])</span><br><span class="line">			L.data[++i] = L.data[j];</span><br><span class="line">	L.length = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h6><blockquote><p><em>思路</em> ：<code>k</code> 为慢指针，即结果表游标；<code>i</code> 为快指针，即原表游标</p><p>时间复杂度：$O(n)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DelX1</span><span class="params">(SqList &amp;L,ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针，删除L中所有值为x的值</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L.data[i] != x) &#123;</span><br><span class="line">			L.data[k++] = L.data[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><blockquote><p><code>i</code>​ ：快指针</p><p><code>cnt_x</code> ：记录 <code>x</code> 的个数，将不为 <code>x</code> 的值插入到表尾；</p><p><code>i-k</code>：慢指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DelX2</span><span class="params">(SqList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt_x = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//工作游标</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; L.length) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L.data[i] == x)</span><br><span class="line">			cnt_x++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			L.data[i-cnt_x] = L.data[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length = L.length - cnt_x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="删除有序表指定范围元素"><a href="#删除有序表指定范围元素" class="headerlink" title="删除有序表指定范围元素"></a>删除有序表指定范围元素</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">del_s_t</span><span class="params">(SqList &amp;L,ElemType s,ElemType t)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s &gt; t || L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//找下界对应的下标</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; L.length &amp;&amp; L.data[i] &lt; s;i++);</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//找上界对应的下标</span></span><br><span class="line">    <span class="keyword">for</span>(j=i;j &lt; L.length &amp;&amp; L.data[j] &lt;=t;j++);</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前移</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; L.length)</span><br><span class="line">        L.data[i++] = L.data[j++];<span class="comment">//i：慢指针；j：快指针</span></span><br><span class="line">    </span><br><span class="line">    L.length = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="删除无序表指定范围元素"><a href="#删除无序表指定范围元素" class="headerlink" title="删除无序表指定范围元素"></a>删除无序表指定范围元素</h6><blockquote><p><code>i</code>​ ：快指针</p><p><code>cnt_x</code>​：记录范围内值的个数，将范围外的值插入表尾</p><p><code>i-cnt_x</code>：慢指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">del_s_t</span><span class="params">(SqList &amp;L,ElemTtpe s,ElemType t)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> cnt_x = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span> || s &gt;= t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; L.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] &gt;= s &amp;&amp; L.data &lt;= t)</span><br><span class="line">            cnt_x++;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//慢指针跳过值为x的元素</span></span><br><span class="line">            L.data[i-cnt_x] = L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = cnt_x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="无序表去重"><a href="#无序表去重" class="headerlink" title="无序表去重"></a>无序表去重</h6><blockquote><p>排序：$O(nlogn)$ 遍历：$O(n)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ElemType a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    ElemType pivot = a[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt; pivot)</span><br><span class="line">            --high;<span class="comment">//找到第一个比枢轴小的位置</span></span><br><span class="line">       	a[low] = a[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt; pivot) </span><br><span class="line">            ++low;<span class="comment">//找到第一个比枢轴大的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(ElemType a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotpos = Partition(a,low,high);</span><br><span class="line">        QucikSort(a,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        QucikSort(a,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Union</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    QuickSort(L.data,<span class="number">0</span>,L.length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt; L.length;++i)&#123;</span><br><span class="line">        <span class="comment">//i为快指针，j为慢指针</span></span><br><span class="line">        <span class="keyword">if</span>(L.data[i] != L.data[j])</span><br><span class="line">            L.data[++j] = L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><h6 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h6><blockquote><p><em>思路</em> ：一次遍历，记录变量</p><p>时间复杂度：$O(n^2)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DelMin</span><span class="params">(SqList &amp;L ,ElemType &amp;e)</span> &#123;<span class="comment">//删除最小值,并用最后一个元素填充</span></span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	e = L.data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L.data[i] &lt; e) &#123;</span><br><span class="line">			e = L.data[i];</span><br><span class="line">			pos = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//已知元素不重复时，可以这么做</span></span><br><span class="line">	L.data[pos] = L.data[L.length - <span class="number">1</span>];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="无序顺序表去重"><a href="#无序顺序表去重" class="headerlink" title="无序顺序表去重"></a>无序顺序表去重</h6><blockquote><p><em>思路</em> ：<code>sum</code> 记录表长。逐个遍历，查找结果表中是否存在</p><p>时间复杂度：$O(n^2)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Union</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//sum 为结果串的长度，i为结果串下标,j为待和合并串下标</span></span><br><span class="line">	<span class="type">int</span> i, j, sum = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (j &lt; L.length) &#123;</span><br><span class="line">        <span class="comment">//遍历结果串，看是否已存在当前值</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sum; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (L.data[i] == L.data[j])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == sum)<span class="comment">//如果不存在，则插入</span></span><br><span class="line">			L.data[sum++] = L.data[j++];</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若存在则比较下一个</span></span><br><span class="line">			j++;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length = sum;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h5 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h5><h6 id="折半查找-1"><a href="#折半查找-1" class="headerlink" title="折半查找"></a>折半查找</h6><blockquote><p><em>要求</em> ：有序线性表，查找 <code>x</code></p><ul><li>若有，则与后继交换</li><li>若无，则添加使仍为正序</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySearch</span><span class="params">(SqList L, ElemType x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> low, high = L.length - <span class="number">1</span>,mid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">		mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (L.data[mid] == x) </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (L.data[mid] &lt; x) </span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			high = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (L.data[mid] == x &amp;&amp; mid != L.length - <span class="number">1</span>) &#123;</span><br><span class="line">		ElemType t = L.data[mid];<span class="comment">//与后继交换</span></span><br><span class="line">		L.data[mid] = L.data[mid + <span class="number">1</span>];</span><br><span class="line">		L.data[mid + <span class="number">1</span>] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (low &gt; high) &#123;<span class="comment">//无，则插入</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt; high; i--) </span><br><span class="line">			L.data[i + <span class="number">1</span>] = L.data[i];</span><br><span class="line">		L.data[i + <span class="number">1</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div>###### 原地转置——[折半] > 时间复杂度：$O(n)$ 空间复杂度：$O(1)$<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">	ElemType e;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">		e = L.data[i];</span><br><span class="line">		L.data[i] = L.data[L.length - <span class="number">1</span> - i];</span><br><span class="line">		L.data[L.length - <span class="number">1</span> - i] = e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>**转置应用** > *要求* ：`L.data[m+n]` 中存放的元素，将 `L.data` 转置，然后前m个转置，后n个转置 > > ​ $a_1,a_2,a_3...a_n,b_1,b_2...b_m$ ---> $b_m,b_{m-1}...b_1,a_n,a_{n-1}...a_1$ > > ---> $b_1,b_2...b_m,a_1,a_2,a_3...a_n$<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReverseApply</span><span class="params">(SqList &amp;L, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//转置left-&gt;right内元素</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right || right &gt;= L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= mid - left; ++i) &#123;</span><br><span class="line">		ElemType e = L.data[left + i];</span><br><span class="line">		L.data[left + i] = L.data[right - i];</span><br><span class="line">		L.data[right - i] = e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Exchange</span><span class="params">(SqList &amp;L, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//L.data[m+n]中存放的元素，前m个与后n个互换，然后m内互换，n内互换</span></span><br><span class="line">	<span class="built_in">ReverseApply</span>(L, <span class="number">0</span>, m - n + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ReverseApply</span>(L, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ReverseApply</span>(L, n, m + n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="2-2-2-线性表的链式存储"><a href="#2-2-2-线性表的链式存储" class="headerlink" title="2.2.2 线性表的链式存储"></a>2.2.2 线性表的链式存储</h3><blockquote><p>用一组未必连续的存储单元保存线性表的数据元素</p></blockquote><ul><li>结点：包含数据域和指针域<ul><li>指针域中存储的信息称作指针或链</li></ul></li><li>头指针：指向头结点的位置</li><li>头结点：链表的第一个节点之前附设一个结点，称为头结点。<ul><li>若线性表为空表，头结点的指针域指为 <code>NULL</code><ul><li>数据域不设具体数据信息</li></ul></li></ul></li></ul><p><strong>引入头结点原因：</strong></p><ul><li><p>空表和非空表统一</p><ul><li>无论是否为空，头指针指向都非空</li></ul></li><li><p>链表的第一个位置上操作和表在其他位置的操作一致，无需特殊处理</p></li></ul><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1. 特点"></a>1. 特点</h4><ul><li>不要求连续存储空间，逻辑上相邻的元素通过 <em>指针</em> 标识</li><li>链表同样可反映数据间的逻辑关系</li><li>不支持随机存取</li></ul><h4 id="2-单链表"><a href="#2-单链表" class="headerlink" title="2. 单链表"></a>2. 单链表</h4><h5 id="结点定义"><a href="#结点定义" class="headerlink" title="结点定义"></a>结点定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><h6 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h6><blockquote><ol><li><p>带不带头结点在代码实现中，区别在于对第一个结点的特殊处理</p><ul><li><p>若不带头结点，<em>表名</em> 即指向第一个数据结点</p></li><li><p>若带头结点，<em>表名</em> 指向头结点，<code>表名-&gt;next</code> 指向第一个数据结点</p><p><img src="/posts/3975030669/image-20220124121623414.png" alt></p></li></ul></li><li><p>必须将第一个头结点 <code>next</code> 设为 <code>NULL</code>，因为一直向后传递，且没有尾指针</p></li><li><p>每个结点插入时间为 $O(1)$ ，插入n个结点时间为 $O(n)$</p></li><li><p>最后一个结点的 <code>next</code> 域为NULL</p></li></ol></blockquote><p><strong>1. 头插法</strong> 多用于原地逆置</p><p><em>带头结点</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)	 </span><br><span class="line">        <span class="keyword">return</span> ERROR;  </span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">	<span class="keyword">if</span> (!L)		</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始为空链表</span></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L.length &lt; n)&#123;</span><br><span class="line">    	LNode *p = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">		<span class="keyword">if</span> (!p) 	</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);<span class="comment">//输入结点的值</span></span><br><span class="line">		p-&gt;next = L-&gt;next;</span><br><span class="line">		L-&gt;next = p;<span class="comment">//将结点插入到表头，L为头指针</span></span><br><span class="line">        L.length++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>不带头结点</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">HeadInsert2</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">	LNode *p;<span class="comment">//游标</span></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L.length &lt; n)&#123;</span><br><span class="line">        p = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		<span class="keyword">if</span> (!p) </span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = i==<span class="number">0</span> ? <span class="literal">NULL</span> : L-next;</span><br><span class="line">        </span><br><span class="line">		L = p;<span class="comment">//将结点插入到表头</span></span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 尾插法</strong></p><ul><li>表尾结点指针域为 <code>NULL</code></li></ul><p><em>带头结点</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">TailInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">	<span class="keyword">if</span> (!L)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	LNode *r = <span class="literal">NULL</span>,*p = <span class="literal">NULL</span>;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (L.length &lt; n) &#123;</span><br><span class="line">		p = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		r-&gt;next = p;</span><br><span class="line">		r = p;<span class="comment">//tail指向新的表尾结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>不带头结点</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">TailInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	LNode *r = <span class="literal">NULL</span>,*p = <span class="literal">NULL</span>;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (L.length &lt; n) &#123;</span><br><span class="line">		p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!r)&#123;<span class="comment">//第一个结点</span></span><br><span class="line">            L = p;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        r = p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h6><p><strong>1. 按序号查找</strong></p><blockquote><p>当第 <code>i</code> 个元素存在是，将钙元素的值赋给 <code>e</code> 并返回 <code>OK</code>，否则返回 <code>ERROR</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//L是带头结点的单链表头的头指针</span></span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//游标</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;<span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; k &lt; i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;<span class="comment">//循环退出的条件是游标指向第i个元素或者到达表尾</span></span><br><span class="line">    <span class="comment">//当i为小于0的违法输入是，不会进入while循环。此时k=1&gt;i</span></span><br><span class="line">    <span class="keyword">if</span>(!p || k &gt; i)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 按值查找</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">	LNode *p = L-&gt;next;</span><br><span class="line">	<span class="comment">//从第一个结点开始查找data域为e的结点</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;<span class="comment">//找到后返回该结点指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>对第 <code>i​</code> 个结点前插 $\iff$ 对第 <code>i-1</code> 个结点后插</p><p><strong>1. 插入到第 <code>i</code> 个位置</strong></p><blockquote><p>只知道插入位序</p><ul><li>查找位序时间 $O(n)$</li><li>插入时间 $O(1)$</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个后插</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	LNode *p = L-&gt;next;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; k &lt; i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;<span class="comment">//结束：p到表尾或指向第i-1个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p || k &gt; i<span class="number">-1</span>)<span class="comment">//违法输入或遍历到表尾</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 后插&amp;交换</strong></p><blockquote><p>当已知插入结点p时</p><ul><li>时间复杂度 $O(1)$</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插后交换</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsBefore2</span><span class="params">(LinkList &amp;L, LNode *p, LNode *s)</span> </span>&#123;<span class="comment">//在p之前插入s结点</span></span><br><span class="line">	<span class="comment">//将s插入到p后</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="comment">//交换数据域。使s换到p之前</span></span><br><span class="line">	ElemType tmp = s-&gt;data;</span><br><span class="line">	s-&gt;data = p-&gt;data;</span><br><span class="line">	p-&gt;data = tmp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p><strong>1. 已知索引删除</strong></p><p>从链表头开始顺序查找到 <code>p</code> 的前驱结点，执行删除操作</p><blockquote><p>时间复杂度为 $O(n)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知索引删除</span></span><br><span class="line"><span class="function">Status <span class="title">LinkListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; <span class="built_in">Length</span>(L))</span><br><span class="line">		<span class="keyword">return</span> ERROR; </span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	LNode *s, *p = L;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;<span class="comment">//寻找第 i 个结点的前驱结点</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">		s = p-&gt;next;</span><br><span class="line">		p-&gt;next = s-&gt;next;</span><br><span class="line">		e = s-&gt;data;</span><br><span class="line">		<span class="built_in">free</span>(s);<span class="comment">//释放s结点</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 已知结点删除</strong></p><blockquote><p>删除结点 <code>p</code> 的后继结点实现</p><ul><li>时间复杂度为 $O(1)$</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知结点删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Del2</span><span class="params">(LinkList &amp;L, LNode *p)</span> </span>&#123;</span><br><span class="line">	LNode *q = p-&gt;next;<span class="comment">//指向p后的结点</span></span><br><span class="line">    </span><br><span class="line">	p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h6><blockquote><p>对不带头结点的单链表，表为空时，要单独处理</p></blockquote><p><em>不带头结点</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length2</span><span class="params">(LinkList L)</span> </span>&#123;<span class="comment">//不带头结点</span></span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	LNode *p = L;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		n++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><p><em>带头结点</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	LNode *p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		n++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="公共序列"><a href="#公共序列" class="headerlink" title="公共序列"></a>公共序列</h5><h6 id="找公共-结点"><a href="#找公共-结点" class="headerlink" title="找公共 结点"></a>找公共 <strong>结点</strong></h6><blockquote><p>两个链表有公共结点，即从第一个公共结点开始，它们的 <code>next</code> 域都指向同一个结点。从第一个公共结点开始，之后它们的所有结点都是重合的，不可能出现分叉。即只能是 $Y$，不可能是 $X$。</p></blockquote><p><strong>1. 暴力</strong></p><blockquote><p>空间复杂度：$O(len1*len2)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">Search</span><span class="params">(LinkList L1,LinkList2)</span>&#123;</span><br><span class="line">    LNode *pa = L1-&gt;next,*pb = L2-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pb = L2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(pb != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        	pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)<span class="comment">//没有找到公共结点</span></span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 最优</strong></p><blockquote><p>由于从公共结点开始到最后一个结点是相同的，所以从最后一个结点回溯，可以找到第一个公共结点。若截取长链表多出来部分，并不影响公共部分。</p><p>时间复杂度：$O(len1+len2)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">Search</span><span class="params">(LinkList L1,LinkList L2)</span>&#123;</span><br><span class="line">	LinkList longList,shortList;</span><br><span class="line">	<span class="type">int</span> dist;</span><br><span class="line">    <span class="keyword">if</span>(L1.length &gt; L2.length)&#123;</span><br><span class="line">        longList = L1.length;</span><br><span class="line">        shortList = L2.length;</span><br><span class="line">        dist = L1.length-L2.length;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		shortList = L1.length;</span><br><span class="line">        longList = L2.length;</span><br><span class="line">        dist = L2.length-L1.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(dis--)</span><br><span class="line">        longList = longList-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!longList)&#123;</span><br><span class="line">		<span class="keyword">if</span>(longList == shortList)</span><br><span class="line">            <span class="keyword">return</span> longList;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            longList = longList-&gt;next;</span><br><span class="line">            shortList = shortList-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h6 id="找公共-序列"><a href="#找公共-序列" class="headerlink" title="找公共 序列"></a>找公共 <strong>序列</strong></h6><blockquote><p>实质上是模式匹配，A为主串，B为模式串</p></blockquote><p><strong>1. 暴力法</strong></p><blockquote><p>时间复杂度：$O(len1*len2)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pattern</span><span class="params">(LinkList A,LinkList B)</span>&#123;</span><br><span class="line">    LNode *p = A-&gt;next,*q = B-&gt;next;</span><br><span class="line">    LNode *pre = p;<span class="comment">//记录每轮比较A的起始点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==q-&gt;data)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            p = pre;</span><br><span class="line">            q = B-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//表示匹配成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. KMP算法</strong></p><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><blockquote><p>实质是链表的遍历</p></blockquote><h6 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h6><blockquote><p>两个递增链表，合并为一个递减链表</p></blockquote><div style="page-break-after:always"></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb)</span>&#123;</span><br><span class="line">	LNode *pa = La-&gt;next,*pb = Lb-&gt;next;</span><br><span class="line">    LNode *q;</span><br><span class="line">    La-&gt;next = <span class="literal">NULL</span>;<span class="comment">//La为结果表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;<span class="comment">//La当前结点元素小于Lb</span></span><br><span class="line">            q = pa-&gt;next;<span class="comment">//暂存La的后继链，防止断链</span></span><br><span class="line">            pa-&gt;next = La-&gt;next;</span><br><span class="line">            La-&gt;next = pa;</span><br><span class="line">            </span><br><span class="line">            pa = q;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//Lb当前结点小于Lb</span></span><br><span class="line">            q = Lb-&gt;next;</span><br><span class="line">            pb-&gt;next = La-&gt;next;</span><br><span class="line">            La-&gt;next = pb;</span><br><span class="line">            </span><br><span class="line">            pb = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">//将剩余结点插入结果表</span></span><br><span class="line">    <span class="keyword">if</span>(pa)</span><br><span class="line">        pb = pa;</span><br><span class="line">    <span class="keyword">while</span>(pb)&#123;</span><br><span class="line">        q = pb-&gt;next;</span><br><span class="line">        pb-&gt;next = La-&gt;next;</span><br><span class="line">        La-&gt;next = pb;</span><br><span class="line">        pb = q;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(Lb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="求两链表交集"><a href="#求两链表交集" class="headerlink" title="求两链表交集"></a>求两链表交集</h6><blockquote><p>只有同时出现在两链表中的元素才链接到新表</p><p>将 <code>L1</code> 作为新表，<code>L2</code> 释放</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">Union</span><span class="params">(LinkList L1,LinkList L2)</span>&#123;</span><br><span class="line">    LNode *pa = L1-&gt;next,*pb = L2-&gt;next;</span><br><span class="line">    LNode *r;<span class="comment">//指向待释放结点</span></span><br><span class="line">    LinkList pc = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    pc = pa;<span class="comment">//pc为结果表游标，指向表尾元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)&#123;</span><br><span class="line">            pc-&gt;next = pa;<span class="comment">//pc指向L1中结点</span></span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            <span class="comment">//释放L2中结点</span></span><br><span class="line">            r = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(r);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data &lt; pb-&gt;data)&#123;</span><br><span class="line">			r = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(r);</span><br><span class="line">        &#125;<span class="keyword">else</span>(pa-&gt;data &gt; pb-&gt;data)&#123;</span><br><span class="line">			r = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa)&#123;</span><br><span class="line">        r = pa;</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pb)&#123;</span><br><span class="line">        r = pb;</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(L2);</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h6 id="有序表找公共元素"><a href="#有序表找公共元素" class="headerlink" title="有序表找公共元素"></a>有序表找公共元素</h6><blockquote><p>要求不破坏原链表</p><p>值不等，则将值小的指针后移；值相等，创建一个新结点，尾插法到新表尾。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">getCommon</span><span class="params">(LinkList L1,LinkList2)</span>&#123;</span><br><span class="line">	LNode *pa = L1-&gt;next,*pb = L2-&gt;next;</span><br><span class="line">    LinkList L3 = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(!L3)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    LNode *r = L3;<span class="comment">//指向新结点表尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa != <span class="literal">NULL</span> &amp;&amp; pb != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt; pb-&gt;data)</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pb-&gt;data &lt; pa-&gt;data)</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">            s-&gt;data = p-&gt;data;</span><br><span class="line">            r-next = s;</span><br><span class="line">            r = s;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//表尾指针置为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h5 id="相关思路"><a href="#相关思路" class="headerlink" title="相关思路"></a>相关思路</h5><h6 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h6><ul><li>用于实现逆置</li></ul><p><strong>1. 逆序输出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RPrint</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    LinkList A = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    A-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;<span class="comment">//头插法建立带头结点的A</span></span><br><span class="line">        LNode *q = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        q-&gt;data = p-&gt;data;</span><br><span class="line">        q-&gt;next = A-&gt;next;</span><br><span class="line">        A-&gt;next = q;</span><br><span class="line">        </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = A-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(!p)<span class="comment">//遍历A</span></span><br><span class="line">        print(p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 就地逆置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    LNode *p,*q;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">        q = p-&gt;next;<span class="comment">//暂存p的后继链</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h6><p><strong>1. 删除指定值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelX</span><span class="params">(LinkList &amp;L,ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//游标</span></span><br><span class="line">    LNode *r = L;<span class="comment">//指向尾结点</span></span><br><span class="line">    LNode *q; <span class="comment">//暂存待删除结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data!=e)&#123;<span class="comment">//p结点值不为x时将其链接到L表尾</span></span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">            r = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//表尾结点指针域置NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 删除最小值</strong></p><blockquote><p>遍历：一趟简单选择排序</p><p>时间复杂度：$O(n)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelMin</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	LNode *pre = L,*p = pre-&gt;next;<span class="comment">//快慢指针</span></span><br><span class="line">    <span class="comment">//minpre 当前最小值结点的前驱</span></span><br><span class="line">    LNode *minpre = pre,*minp = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt; minp-&gt;data)&#123;<span class="comment">//更新</span></span><br><span class="line">			minp = p;</span><br><span class="line">            minpre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    minpre-&gt;next = minp-&gt;next;<span class="comment">//删除最小值结点</span></span><br><span class="line">	<span class="built_in">free</span>(minp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 有序表去重</strong></p><blockquote><p>有序表，则前后结点数据不相等，则不重复</p><p>若为无序表，则遍历有序表后才可判断是否重复，时间复杂度为 $O(n^2)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelDuplicate</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next,*ra = p;</span><br><span class="line">    LNode *r;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data != ra-&gt;data)&#123;</span><br><span class="line">			ra-&gt;next = p;</span><br><span class="line">            ra = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//若相等，则释放该结点</span></span><br><span class="line">            r = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(r);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h6><blockquote><p>去重</p></blockquote><p><strong>1. 删除指定值</strong></p><blockquote><p><code>p</code> ：快指针</p><p><code>pre</code>：慢指针</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelX</span><span class="params">(LinkList &amp;L,ElemType e)</span>&#123;</span><br><span class="line">	LNode *q;<span class="comment">//暂存待删除结点</span></span><br><span class="line">    LNode *p = L-&gt;next, *pre = L;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data == e)&#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//同时后移</span></span><br><span class="line">			pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 删除无序链表指定范围值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RangeDel</span><span class="params">(LinkList &amp;L,ElemType min,ElemType max)</span>&#123;</span><br><span class="line">    LNode *pre = L,*p = pre-&gt;next;<span class="comment">//快慢指针</span></span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &gt; min &amp;&amp; p-&gt;data &lt; max)&#123;</span><br><span class="line">			pre-&gt;next = p-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 有序表去重</strong></p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelDulplicate</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next,LNode *q;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == q-&gt;data)&#123;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="快慢指针实现指针反转"><a href="#快慢指针实现指针反转" class="headerlink" title="快慢指针实现指针反转"></a>快慢指针实现指针反转</h6><p><strong>1. 就地逆置</strong></p><blockquote><p><code>pre</code>：指向慢指针指向的前一个结点</p><p><code>q</code>：慢指针，初始指向头结点</p><p><code>p</code>：快指针，初始指向头结点的下一个结点</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	LNode *pre, *q = L-&gt;next,*p = q-&gt;next;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">        <span class="comment">//指针后移</span></span><br><span class="line">		pre = q;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="comment">//修改指针指向</span></span><br><span class="line">        q-&gt;next = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 排序</strong></p><blockquote><p>基于 <em>直接插入排序</em> 思想，此时前后指针是为了不断链</p><p>时间复杂度：$O(n^2)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next,*pre;<span class="comment">//pre为有序表游标</span></span><br><span class="line">    LNode *r = p-&gt;next;<span class="comment">//r指向p的下一个结点</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//构建一个只有一个结点的链表</span></span><br><span class="line">    </span><br><span class="line">    p = r;</span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">        r = p-&gt;next;     </span><br><span class="line">        pre = L;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next != <span class="literal">NULL</span> &amp;&amp; pre-&gt;data &lt; p-&gt;data)</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        p-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = p;    </span><br><span class="line">        p = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 递增输出</strong></p><blockquote><p>简单选择排序思想，若不影响原链表，则需要进行复制：$O(n^2)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AscPrint</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    LNode *r;<span class="comment">//指向被每轮被释放结点</span></span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        LNode *pre = L;<span class="comment">//最小值结点的前驱结点，确保不断链</span></span><br><span class="line">        LNode *p = pre-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;data &lt; pre-&gt;next-data)</span><br><span class="line">                pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        print(p-&gt;next-data);</span><br><span class="line">        r = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = r-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 拆分</strong></p><p>指针赋值，会使他们指向同一个存储单元。对两个指针的操作会修改同一个结点的属性</p><blockquote><p>奇数位结点元素 <code>A</code> 尾，偶数位结点元素 <code>B</code> 尾 ，结果表中元素相对位置不变</p><p>时间复杂度：$O(n)$ 空间复杂度：$O(1)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">DisCreate</span><span class="params">(LinkList &amp;A)</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//计数</span></span><br><span class="line">    B = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(!B)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  	LNode *ra = A,*rb = B;<span class="comment">//结果表表尾指针</span></span><br><span class="line">    LNode *p = ra;<span class="comment">//游标</span></span><br><span class="line">    A-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			rb-&gt;next = p;</span><br><span class="line">            rb = p;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ra-&gt;next = p;</span><br><span class="line">            ra = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ra-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">DisCreate</span><span class="params">(LinkList &amp;A)</span>&#123;</span><br><span class="line">    B = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(!B)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    LNode *p = A;<span class="comment">//游标</span></span><br><span class="line">    A-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    B-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  	LNode *ra = A,*rb = B;<span class="comment">//结果表表尾指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        ra-&gt;next = p;</span><br><span class="line">        ra = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">         	rb-&gt;next = p;</span><br><span class="line">            rb = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ra-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>奇数位结点元素入 <code>A</code> 尾，偶数位结点元素入 <code>B</code> 头</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">DisCreate</span><span class="params">(LinkList &amp;A)</span>&#123;</span><br><span class="line">    LinkList B = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    B-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = A-&gt;next,q;</span><br><span class="line">    LNode *ra = A;<span class="comment">//指向A尾结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        ra-&gt;next = p;</span><br><span class="line">        ra = p;<span class="comment">//将p链接到A表尾</span></span><br><span class="line">       	p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            q = p-&gt;next;<span class="comment">//暂存p的后续链，防止断链</span></span><br><span class="line">        p-&gt;next = B-&gt;next;</span><br><span class="line">        B-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ra-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h6><p><strong>1. 逆序输出</strong></p><blockquote><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RPrint</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    LNode * p = L-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!p)</span><br><span class="line">        Push(s,p-&gt;data);</span><br><span class="line">    <span class="keyword">while</span>(!EmptyStack(s))&#123;</span><br><span class="line">        ElemType e;</span><br><span class="line">        Pop(s,e);</span><br><span class="line">    	print(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 链表排序</strong></p><blockquote><p>将链表数据复制到数组中，采用 $O(nlonn)$ 的排序算法排序，然后将数组元素插入到链表中</p><p>时间复杂度：$O(n)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    ElemType a[MaxSize];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!p)&#123;</span><br><span class="line">        a[i++] = p-&gt;data;</span><br><span class="line">    	p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    QuickSort(a,<span class="number">0</span>,L.length<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//修改指针域</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; L.length;++i)&#123;</span><br><span class="line">        p-&gt;data = a[i];</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ElemType a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    ElemType pivot = a[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt; pivot)</span><br><span class="line">            --high;<span class="comment">//找到第一个比枢轴小的位置</span></span><br><span class="line">       	a[low] = a[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt; pivot) </span><br><span class="line">            ++low;<span class="comment">//找到第一个比枢轴大的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(ElemType a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotpos = Partition(a,low,high);</span><br><span class="line">        QucikSort(a,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        QucikSort(a,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 递增输出</strong></p><blockquote><p>将链表中数据复制到数组中，排序后输出</p></blockquote><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><ul><li>递归 = <em>出口</em> + <em>调用</em></li><li>为保证一致性：递归从第一个有数据的结点开始</li></ul><p><strong>1. 删除指定值</strong></p><blockquote><p>时间复杂度：$O(n)$</p><p>递归栈深度：$O(n)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelX</span><span class="params">(LinkList &amp;L,ElemType e)</span>&#123;</span><br><span class="line">    <span class="comment">//L不带头结点</span></span><br><span class="line">    LNode *p = <span class="literal">NULL</span>;<span class="comment">//暂存待删除结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)<span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data == e)&#123;</span><br><span class="line">		p = L;<span class="comment">//p指向待删除结点</span></span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);<span class="comment">//释放空间</span></span><br><span class="line">        DelX(L,x);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        DelX(L-&gt;next,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 逆序输出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RPrint</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;next)</span><br><span class="line">        RPrint(L-&gt;next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!L)<span class="comment">//递归出口</span></span><br><span class="line">        print(L-data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IgnoreHead</span><span class="params">(LinkList)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!L)</span><br><span class="line">        RPrint(L-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-双链表"><a href="#3-双链表" class="headerlink" title="3. 双链表"></a>3. 双链表</h4><ul><li>优化：<strong>访问前驱结点</strong> —— $O(1)$ 单链表 —&gt; $O(n)$</li></ul><h5 id="结点定义-1"><a href="#结点定义-1" class="headerlink" title="结点定义"></a>结点定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DulNode</span>&#123;<span class="comment">//定义双链表结点类型</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">DulNode</span> *prior,*next;<span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DulNode,*DulLinkList;</span><br></pre></td></tr></table></figure><h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><p><strong>插入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s为待插入结点，p为其前驱结点</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为前驱，q为待删除结点</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><h5 id="最近最高频访问"><a href="#最近最高频访问" class="headerlink" title="最近最高频访问"></a>最近最高频访问</h5><blockquote><p>双向链表中查找到值为 <code>x</code> 的结点，查找到后，将结点从链表摘下，然后顺着结点的前驱找到该结点的插入位置（频度递减，且排在同频度的第一个。即向前找到第一个比他大的结点，插在该结点位置之后）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DLinkList <span class="title function_">Locate</span><span class="params">(DLinkList &amp;L,ElemType e)</span>&#123;</span><br><span class="line">	DNode *p = L-&gt;next,*pre;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != x)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">		<span class="comment">//结点不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		p-&gt;freq++;</span><br><span class="line">        <span class="comment">//修改结点的前驱后继</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            p-&gt;next-&gt;pred = p-&gt;pred;</span><br><span class="line">        p-&gt;pred-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="comment">//寻找插入位置</span></span><br><span class="line">        pre = p-&gt;pred;</span><br><span class="line">        <span class="keyword">while</span>(pre != L &amp;&amp; pre-&gt;freq &lt;= p-&gt;freq)</span><br><span class="line">            pre = pre-&gt;pred;<span class="comment">//最后一轮，pre指向插入位置的前驱</span></span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        p-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next-&gt;pred = p;</span><br><span class="line">        p-&gt;pred = pre;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-循环链表"><a href="#4-循环链表" class="headerlink" title="4. 循环链表"></a>4. 循环链表</h4><ul><li>优化：对表尾操作—— $O(1)$<ul><li>单链表为 $O(n)$<ul><li><em>单链表删除最后一个元素</em> 需要将最后一个元素空指 —— $O(n)$</li></ul></li></ul></li></ul><h5 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h5><ul><li>表尾 <code>r-&gt;next</code> 指向头指针（判空条件）</li><li>插入删除操作<ul><li>表尾 <code>next-&gt;L</code></li></ul></li></ul><p><strong>应用</strong></p><blockquote><p>若操作多为在表头和表尾 <em>插入</em> 时，设尾指针</p><ul><li>头指针对表尾操作为 $O(n)$</li></ul></blockquote><p><strong>Note</strong></p><ul><li>若对 <em>表尾删除</em> 操作，单链表寻找其前驱结点为 $O(n)$<ul><li>需要采用 <em>循环双链表</em></li></ul></li></ul><div style="page-break-after:always"></div><h6 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pwd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">CreateLinkList</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">playing</span><span class="params">(LinkList tail,<span class="type">int</span> n,<span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList tail;</span><br><span class="line">    <span class="type">int</span> n,it;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;it);<span class="comment">//输入初始数量与初始密码</span></span><br><span class="line">    tail = CreateLinkList(n);<span class="comment">//创建不带头结点的单循环链表 </span></span><br><span class="line">    <span class="keyword">if</span>(tail)</span><br><span class="line">        playing(tail,n,it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">CreateLinkList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	LNode *p,*r; </span><br><span class="line">	p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;pwd);</span><br><span class="line">	p-&gt;no = <span class="number">1</span>;</span><br><span class="line">	p-&gt;next = p;</span><br><span class="line">	r = p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;++i)&#123;</span><br><span class="line">		p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		<span class="keyword">if</span>(!p)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;pwd);</span><br><span class="line">		p-&gt;no = i;</span><br><span class="line">		p-&gt;next = r-&gt;next; </span><br><span class="line">		r-&gt;next = p;</span><br><span class="line">		r = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/3975030669/image-20220124172446352.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7 5</span></span><br><span class="line"><span class="comment">//3 8 1 22 4 9 15</span></span><br><span class="line"><span class="comment">//===5 2 6 7 4 3 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">playing</span><span class="params">(LinkList tail,<span class="type">int</span> n,<span class="type">int</span> m)</span>&#123;</span><br><span class="line">	<span class="comment">//L为环， n为环中结点数量，m为初始密码</span></span><br><span class="line">	LNode *pre,*p; </span><br><span class="line">	m = m%n ? m%n : n;<span class="comment">//检验m为合法输入</span></span><br><span class="line">	pre  = tail;</span><br><span class="line">	p = pre-&gt;next;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">1</span>;<span class="comment">//计数器</span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;<span class="comment">//环中人数多于1时 </span></span><br><span class="line">		<span class="keyword">if</span>(k==m)&#123;<span class="comment">//数到需要出圈的人 </span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,p-&gt;no);</span><br><span class="line">			pre-&gt;next = p-&gt;next;</span><br><span class="line">			n--;</span><br><span class="line">			m = p-&gt;pwd%n ? p-&gt;pwd%n : n;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">			p = pre-&gt;next;</span><br><span class="line">			k = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k++;</span><br><span class="line">			pre = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,p-&gt;no);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><p><img src="/posts/3975030669/image-20220124173242186.png" alt="image-20220124173242186"></p><p><img src="/posts/3975030669/image-20220125101604574.png" alt="image-20220125101604574"></p><div style="page-break-after:always"></div><h6 id="将两个循环单链表连接"><a href="#将两个循环单链表连接" class="headerlink" title="将两个循环单链表连接"></a>将两个循环单链表连接</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">link</span><span class="params">(LinkList &amp;L1,LinkList &amp;L2)</span>&#123;</span><br><span class="line">    LNode *p = L1,*q = L2;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != L1)</span><br><span class="line">        p = p-&gt;next;<span class="comment">//p指向L1表尾，连接到L2表头</span></span><br><span class="line">    <span class="keyword">while</span>(q-&gt;next != L2)</span><br><span class="line">        q = q-&gt;next;<span class="comment">//q指向L2表尾，连接到L1表头</span></span><br><span class="line">    </span><br><span class="line">    p-&gt;next = L2;</span><br><span class="line">    q-&gt;next = L1;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="循环单链表选择排序"><a href="#循环单链表选择排序" class="headerlink" title="循环单链表选择排序"></a>循环单链表选择排序</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Del</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	LNode *p,*pre,*minp,*minpre;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next != L)&#123;</span><br><span class="line">		p = L-&gt;next;</span><br><span class="line">        pre = L;</span><br><span class="line">        minp = p;</span><br><span class="line">        minpre = pre;</span><br><span class="line">        <span class="keyword">while</span>(p!=L)&#123;<span class="comment">//寻找最小元素</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &lt; minp-&gt;data)&#123;</span><br><span class="line">				minp = p;</span><br><span class="line">                minpre = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        print(minp-&gt;data);</span><br><span class="line">        minpre-next = minp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(minp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h5 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h5><ol><li><p>空表条件： <code>p-&gt;pre == p-&gt;next = L</code></p></li><li><p>便于进行各种修改操作，但占有较大指针域，存储密度不高</p></li></ol><h6 id="判断循环双链表是否对称"><a href="#判断循环双链表是否对称" class="headerlink" title="判断循环双链表是否对称"></a>判断循环双链表是否对称</h6><p><code>p</code> 从左向右扫描, <code>q</code> 从右向左扫描；若相等, 则一直比较下去，直到指向同一结点(<code>p == q</code>) 或者相邻(<code>p-&gt;next==q</code> 或 <code>q-&gt;prior ==p</code> )；否则，返回0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Symmetry</span><span class="params">(DLinkList L)</span>&#123;</span><br><span class="line">    DNode *p = L-&gt;next,*q = L-&gt;prior;<span class="comment">//两头工作指针</span></span><br><span class="line">    <span class="keyword">while</span>(p != q &amp;&amp; q-&gt;next != p)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data == q-&gt;data)&#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">            q = q-&gt;prior;</span><br><span class="line">            <span class="comment">//当数据结点为偶数时，最后一轮遍历完q在p指针前，所以判断退出条件是q-&gt;next != p</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5. 静态链表"></a>5. 静态链表</h4><blockquote><p>预先分配连续的内存空间</p></blockquote><ul><li>指针 $\iff$ 游标</li><li><code>next == -1</code> 为表尾</li></ul><p><strong>结点定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 50 <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;<span class="comment">//静态链表结构类型定义</span></span><br><span class="line">	ElemType data;<span class="comment">//存储数据元素</span></span><br><span class="line">	<span class="type">int</span> next;<span class="comment">//下一个元素的数组小标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="2-2-3-顺序表与链表比较"><a href="#2-2-3-顺序表与链表比较" class="headerlink" title="2.2.3 顺序表与链表比较"></a>2.2.3 顺序表与链表比较</h3><table><tr><th></th><th>存取方式</th><th>逻辑&物理结构</th><th>查找</th><th>插&删</th><th>空间分配</th></tr><tr display="table-cell"><td align="center" rowspan="2">顺序表</td><td>顺序存取</td><td rowspan="2">逻辑相邻<br>存储相邻</td><td>无序：O(n)；<br>有序：O(logn)</td><td rowspan="2">O(n)</td><td>静态分配：<br>过大：浪费；<br>过小：内存溢出</td></tr><tr><td>随机存取</td><td>按序号：O(1)</td><td>动态分配：<br>效率低，需要移动大量元素</td></tr><tr display="table-cell"><td align="center" rowspan="2">链表</td><td rowspan="2">顺序存取</td><td rowspan="2">逻辑关系通过指针表示<br>存储密度低</td><td rowspan="2">O(n)</td><td rowspan="2">O(1)</td><td rowspan="2">按需分配，灵活高效</td></tr><tr></tr></table><h3 id="2-2-4-存储结构的选择"><a href="#2-2-4-存储结构的选择" class="headerlink" title="2.2.4 存储结构的选择"></a>2.2.4 存储结构的选择</h3><ul><li><p>较稳定——顺序存储</p></li><li><p>频繁修改——链式存储</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">&nbsp;</th><th style="text-align:left">基于存储</th><th style="text-align:left">基于运算</th><th style="text-align:left">基于运算</th></tr></thead><tbody><tr><td style="text-align:left">顺序表</td><td style="text-align:left">适用于有存储密度的要求</td><td style="text-align:left">常用操作为按序号访问</td><td style="text-align:left">不支持指针的语言；易于实现</td></tr><tr><td style="text-align:left">链表</td><td style="text-align:left">适用于难以估计存储规模</td><td style="text-align:left">常用操作为插入删除</td><td style="text-align:left">基于指针</td></tr></tbody></table></div><p><strong>Note：插入删除</strong></p><blockquote><p>链表按位序查找主要进行比较操作；顺序表主要操作是移动数据元素；</p><p>虽然时间复杂度同样为 $O(n)$ ，但显然比较操作相对优于移动操作</p></blockquote><div style="page-break-after:always"></div><h2 id="2-3-串"><a href="#2-3-串" class="headerlink" title="2.3 串"></a>2.3 串</h2><h3 id="2-3-1-基本概念"><a href="#2-3-1-基本概念" class="headerlink" title="2.3.1 基本概念"></a>2.3.1 基本概念</h3><p><img src="/posts/3975030669/image-20220122195235320.png" alt></p><ul><li>串相等：等长+对应位置元素相等</li></ul><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h4><ul><li>StrAssign：串赋值</li><li>StrCompare：串比较</li><li>StrLength：串长度</li><li>Concat(&amp;T,s1,s2)：串连接</li><li>SubStr(subStr,T,pos,len) 从pos开始的长度为len的子串在T中的位置</li></ul><h4 id="2-串-amp-线性表"><a href="#2-串-amp-线性表" class="headerlink" title="2. 串&amp;线性表"></a>2. 串&amp;线性表</h4><p><strong>数据对象</strong></p><ul><li>串限定数据对象为字符</li></ul><p><strong>操作对象</strong></p><ul><li>串：子串</li><li>线性表：单个元素</li></ul><div style="page-break-after:always"></div><h3 id="2-3-2-存储结构"><a href="#2-3-2-存储结构" class="headerlink" title="2.3.2 存储结构"></a>2.3.2 存储结构</h3><h4 id="1-定长顺序存储"><a href="#1-定长顺序存储" class="headerlink" title="1. 定长顺序存储"></a>1. 定长顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxStrLen 256</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> SqString&#123;</span><br><span class="line">    <span class="type">char</span> ch[MaxStrLen];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqString;</span><br></pre></td></tr></table></figure><h4 id="2-堆分配"><a href="#2-堆分配" class="headerlink" title="2. 堆分配"></a>2. 堆分配</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> SqString&#123;</span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqString;</span><br></pre></td></tr></table></figure><ul><li>堆：自由存储区，用 <code>malloc</code> 和 <code>free</code> 完成动态管理</li></ul><h3 id="2-3-3-模式匹配"><a href="#2-3-3-模式匹配" class="headerlink" title="2.3.3 模式匹配"></a>2.3.3 模式匹配</h3><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h4><p><img src="/posts/3975030669/image-20220124185509245.png" alt></p><p><strong>原理推导</strong></p><ol><li><p>主串游标 <code>i</code> 最大为 <code>n-m+1</code></p><p>主串第 <code>i</code> 个失配，模式串第 <code>j</code> 个适配，则有 <code>j-1</code> 个已匹配，故模式串第一个元素在主串的第 <code>i-(j-1)</code> 处，故失配后下一轮主串游标从 <code>i-j+2</code> 开始</p></li><li><p>匹配成功标志 <code>j==子串长+1</code></p><ul><li><code>i&gt;主串.len</code> 不能作为匹配失败标志</li></ul><blockquote><p>若末尾匹配成功，则 <code>i&gt;主串.len</code> 且 <code>j&gt;子串.len</code></p></blockquote></li></ol><p><strong>实现</strong></p><p>时间复杂度：$O(m*n)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SqString S,SqString P)</span>&#123;</span><br><span class="line">    <span class="comment">//主串S，模式串P</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>,j=<span class="number">1</span>;<span class="comment">//i-主串游标，j-模式串游标</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.len &amp;&amp; j &lt;= P.len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == P.ch[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(j &gt; P.len)</span><br><span class="line">        <span class="keyword">return</span> i-P.len;<span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h4 id="2-KMP"><a href="#2-KMP" class="headerlink" title="2.  KMP"></a>2. KMP</h4><h5 id="暴力法模式匹配可优化部分"><a href="#暴力法模式匹配可优化部分" class="headerlink" title="暴力法模式匹配可优化部分"></a>暴力法模式匹配可优化部分</h5><p><img src="/posts/3975030669/image-20220124193849811.png" alt></p><p>失配原因是 $S[k+4]\neq P[4]$ ，但前缀</p><p><img src="/posts/3975030669/image-20220124194720668.png" alt></p><p>即可用 $P[1,2,3] \iff S[k+1,k+2,k+2]$ 。暴力法模式匹配效率低的原因是每次失配模式串游标都要回到起点。</p><p>若可以利用等价部分提前对模式串处理，使失配后，模式串游标无需回到起点，可减少比较次数。</p><p>为避免遗漏，要是失配后模式串开头移动距离最小，即 <code>next[j]</code> 最小</p><h5 id="KMP过程"><a href="#KMP过程" class="headerlink" title="KMP过程"></a>KMP过程</h5><p><img src="/posts/3975030669/image-20220124202604073.png" alt></p><div style="page-break-after:always"></div><h5 id="next-j-怎样应用算法实现"><a href="#next-j-怎样应用算法实现" class="headerlink" title="next[j] 怎样应用算法实现"></a><code>next[j]</code> 怎样应用算法实现</h5><p>（1）若 <code>P[j] == P[next[j]]</code> ，则其 <code>next[j+1] = next[j]+1</code></p><p><img src="/posts/3975030669/image-20220124223844512.png" alt></p><p>（2）若 <code>P[j]</code> $\neq$ <code>P[next[j]]</code>，则将P再后移</p><script type="math/tex;mode=display">\begin{cases}
至满足(1)&则next[j+1]=next[next[...]]+1 \\
至next[j]=0且P[1]\neq P[j] &则next[j+1]=1(表示主串后移1)
\end{cases}</script><p><strong>例如</strong></p><p><img src="/posts/3975030669/image-20220124233748401.png" alt></p><hr><p><img src="/posts/3975030669/image-20220124233713884.png" alt="image-20220124233713884"></p><div style="page-break-after:always"></div><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><blockquote><p>时间复杂度：$O(n+m)$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SqString S,SqString P,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="comment">//返回子串P在主串中从第pos个字符开始的位置</span></span><br><span class="line">    <span class="type">int</span> i = pos;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.len &amp;&amp; j &lt;= P.len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S[i] == P[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; P.len)</span><br><span class="line">        <span class="keyword">return</span> i-P.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//next数组计算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_next</span><span class="params">(SqSting P,<span class="type">int</span> &amp;next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;<span class="comment">//游标</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= P.len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || P[i] == P[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h5 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h5><p><img src="/posts/3975030669/image-20220125093841548.png" alt></p><p>简单来说，<code>nextval[j]</code> = <code>next[next[...]]</code> ，使得 <code>P[j]</code> $\neq$ <code>P[next[next[...]]]</code></p><p>故其 <code>nextval[j]</code> 数组如下图所示，</p><p><img src="/posts/3975030669/image-20220125100324388.png" alt="image-20220125100324388"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(String P,<span class="type">int</span> &amp;nextval[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">1</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= P.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">1</span> || P.ch[i]==P.ch[j])&#123;</span><br><span class="line">            <span class="comment">//当前字符匹配，则游标后移</span></span><br><span class="line">            ++i;++j;</span><br><span class="line">            <span class="keyword">if</span>(P.ch[i] != P.ch[j])	</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span>	</span><br><span class="line">                nextval[i] = nextval[j]</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h2 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4 队列"></a>2.4 队列</h2><h3 id="2-4-1-顺序队列"><a href="#2-4-1-顺序队列" class="headerlink" title="2.4.1 顺序队列"></a>2.4.1 顺序队列</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul><li><p>先进先出（<em>FIFO</em>），后进后出</p></li><li><p>连续的存储空间 + 1队首指针 + 1队尾指针</p></li><li><p>判空：<code>Q.front==Q.rear</code></p></li><li><p>判满：<code>Q.rear==MaxSize</code></p></li><li><p>缺陷：<em>假上溢</em></p><p><img src="/posts/3975030669/image-20220125102922240.png" alt></p></li></ul><h4 id="2-结构定义"><a href="#2-结构定义" class="headerlink" title="2. 结构定义"></a>2. 结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    QElmeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h4 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//构造一个空队列</span></span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span>&#123;</span><br><span class="line">	p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//队列为空</span></span><br><span class="line">    p = Q.front-&gt;next;<span class="comment">//带头结点</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)<span class="comment">//队尾结点需要特殊处理</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="2-4-2-循环队列"><a href="#2-4-2-循环队列" class="headerlink" title="2.4.2 循环队列"></a>2.4.2 循环队列</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p><img src="/posts/3975030669/image-20220125112441908.png" alt></p><p><strong>初始条件</strong></p><p><code>Q.front</code> 指向队首元素</p><p><code>Q.rear</code> 指向队尾元素后一位置</p><p><strong>队长</strong></p><p><code>(Q.rear-Q.front+MaxSize)%MaxSize</code></p><p><strong>判断条件</strong></p><ol><li><p>队头指针在队尾指针的下一位位置作为队满的标志 <em>牺牲一空间</em></p><p>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></p><p>队空条件：<code>Q.front==Q.rear</code></p></li><li><p>结点类型中，增加表示元素个数的数据项 <code>size</code> <em>记录元素个数</em></p><p>队满条件：<code>Q.size==MaxSize</code></p><p>队空条件：<code>Q.size==0</code></p></li><li><p>结点类型中，增设 <code>tag</code> <em>不牺牲存储空间</em></p><ul><li><p>队满条件：<code>Q.rear==Q.front &amp;&amp; Q.tag==1</code></p><p>队空条件：<code>Q.rear==Q.front &amp;&amp; Q.tag==0</code></p></li><li><p>进队置 <code>tag=1</code> ，出队置 <code>tag=0</code></p><p>若因出队导致 <code>Q.rear==Q.front</code> ，此时 <code>tag=0</code> 则队空；</p><p>若因入队导致 <code>Q.rear==Q.front</code> ，此时 <code>tag=1</code> 则队满</p></li></ul></li></ol><h4 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2. 存储结构"></a>2. 存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h4 id="3-基本操作-1"><a href="#3-基本操作-1" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 初始化</span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.base = (QElemType *)<span class="built_in">malloc</span>(MAXSIZE*<span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"># 入队</span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>)%MAXSIZE == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//队满，牺牲一个存储空间作为</span></span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MAXSIZE；</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"># 出队</span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="2-4-3-链式队列"><a href="#2-4-3-链式队列" class="headerlink" title="2.4.3 链式队列"></a>2.4.3 链式队列</h3><h4 id="1-头结点对第一次入队的影响"><a href="#1-头结点对第一次入队的影响" class="headerlink" title="1. 头结点对第一次入队的影响"></a>1. 头结点对第一次入队的影响</h4><ul><li>不带头结点：判断 <code>Q.front==Q.rear</code> ，若不是，则需要将 <code>Q.front</code> 与 <code>Q.rear</code> 都指向首结点</li><li>带头结点：无需额外操作</li></ul><h4 id="2-出队操作"><a href="#2-出队操作" class="headerlink" title="2. 出队操作"></a>2. 出队操作</h4><p>若出队的是最后一个元素，则令 <code>Q.rear=Q.front</code></p><h4 id="3-判空条件"><a href="#3-判空条件" class="headerlink" title="3. 判空条件"></a>3. 判空条件</h4><p><code>Q.rear==Q.front</code></p><h4 id="4-存储结构的选择"><a href="#4-存储结构的选择" class="headerlink" title="4. 存储结构的选择"></a>4. 存储结构的选择</h4><p>一般队列：带头尾指针的 <em>非循环单链表</em></p><p>不出队：即不从最后一个删除元素，故无需寻找最后一个元素的前一个结点，这是可以选择 <em>只带尾指针的循环单链表</em></p><p>出队入队时间复杂度为 <code>O(1)</code> ：<em>带头尾指针的循环双链表</em></p><h3 id="2-4-4-双端队列"><a href="#2-4-4-双端队列" class="headerlink" title="2.4.4 双端队列"></a>2.4.4 双端队列</h3><p>队列的两端都可进行出队和入队操作</p><ol><li><p>输出受限的双端队列：只有一端输出</p><p>$\iff$ 一个栈+一个可以从栈底入栈的栈</p></li><li><p>当限定进端即出端时，变为两个栈底相接的栈</p></li></ol><div style="page-break-after:always"></div><h3 id="2-4-5-FIFO思想的应用"><a href="#2-4-5-FIFO思想的应用" class="headerlink" title="2.4.5 FIFO思想的应用"></a>2.4.5 FIFO思想的应用</h3><h4 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="1. 层序遍历"></a>1. 层序遍历</h4><blockquote><p>处理当前层的同时，就对下一层预处理。当前层处理完，可按与上一层相关联的处理顺序处理下一层</p></blockquote><p>例：</p><ul><li><p>二叉树的层序遍历</p><p>① 根结点入队</p><p>② 队列中第一个结点出队，并访问。左右子树依次入队。</p><p>③ 若队空，则遍历结束，重复②</p></li></ul><h4 id="2-应用于计算机系统"><a href="#2-应用于计算机系统" class="headerlink" title="2. 应用于计算机系统"></a>2. 应用于计算机系统</h4><p>排队等候</p><p>原因：</p><ul><li>速度不匹配<ul><li>主机与打印机速度不匹配 <em>设置打印数据缓冲区</em></li></ul></li><li>解决多用户引起的资源竞争<ul><li>CPU资源的竞争 <em>避免死锁</em></li></ul></li></ul><div style="page-break-after:always"></div><h2 id="2-5-栈"><a href="#2-5-栈" class="headerlink" title="2.5 栈"></a>2.5 栈</h2><h3 id="2-5-1-基本概念"><a href="#2-5-1-基本概念" class="headerlink" title="2.5.1 基本概念"></a>2.5.1 基本概念</h3><blockquote><p>后进先出（LIFO）</p></blockquote><h4 id="1-卡特兰数"><a href="#1-卡特兰数" class="headerlink" title="1. 卡特兰数"></a>1. 卡特兰数</h4><blockquote><p><strong>结论重要，证明仅供参考</strong> ：n个 <em>不同元素</em> 进栈，出栈序列有 $\frac{1}{n+1}C_{2n}^n$ 种</p></blockquote><h5 id="证明"><a href="#证明" class="headerlink" title="*证明"></a>*证明</h5><p>用 <code>I</code> 表示入栈，<code>O</code> 表示出栈，<code>N()</code> 表示 <code>()</code> 出现的次数：</p><p>n个元素的 <code>IO</code> 组合有 $C_{2n}^n$ 种，故 $N(合理出栈序列) = C_{2n}^n - N(不合理出栈序列)$</p><ul><li><p>问题转换为求 N(不合理出栈序列)</p><p>假设在第 $2m+1$ 位第一次出现 <code>N(O)&gt;N(I)</code> ，也即此时 $N(O)-N(I)=1$</p><ul><li>不可能是 $2m$ 位第一次出现 O的数量大于I的数量，则说明第 $2m-1$ 位为O数量与I数量相等，在一个合理的出栈入栈序列(一定是I数量等于O数量，即二者之和为偶数)中，这种情况一定不会存在。<br><img src="/posts/3975030669/image-20220125184445502.png" alt></li></ul></li></ul><script type="math/tex;mode=display">\begin{aligned}
&即在不合理的出栈序列中，N(I)=n-1且N(O)+N(I)=2n，故 N(不合理出栈序列)=C_{2n}^{n-1}\\
&从而 N(合理出栈序列)=C_{2n}^{n}-C_{2n}^{n-1}=\frac{1}{n+1}C_{2n}^n
\end{aligned}</script><div style="page-break-after:always"></div><h3 id="2-5-2-栈的存储结构"><a href="#2-5-2-栈的存储结构" class="headerlink" title="2.5.2 栈的存储结构"></a>2.5.2 栈的存储结构</h3><h4 id="1-顺序栈"><a href="#1-顺序栈" class="headerlink" title="1. 顺序栈"></a>1. 顺序栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *base;<span class="comment">//栈底指针,指向第一个元素所在的存储单元</span></span><br><span class="line">    ElemType *top;<span class="comment">//栈顶指针，此时指向的是存储单元</span></span><br><span class="line">    <span class="comment">//	int top;//栈顶指针，表示相对于基地址的偏移量</span></span><br><span class="line">    <span class="type">int</span> stackSize;<span class="comment">//当前分配的栈的存储空间数</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">StackEmpty()</span><br><span class="line">	top == base;    </span><br><span class="line">Pop(e)</span><br><span class="line">    e = *--p;</span><br><span class="line">GetTop()</span><br><span class="line">	e = *(top<span class="number">-1</span>);</span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize)&#123;<span class="comment">//top指向数据存储单元</span></span><br><span class="line">        S.base = (ElemType *)<span class="built_in">realloc</span>(S.base,</span><br><span class="line">            (S.stackSize+STACKINCREMENT)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!S) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        S.top = S.base + S.stackSize;</span><br><span class="line">        S.stackSize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top = e;    S.top++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-链栈"><a href="#2-链栈" class="headerlink" title="2. 链栈"></a>2. 链栈</h4><blockquote><p>使用 <em>单链表</em> 实现，规定所有的操作均在表头进行，无头结点</p></blockquote><ul><li>便于多个栈共享存储空间，提高存储效率</li><li>不存在栈满上溢</li></ul><div style="page-break-after:always"></div><h3 id="2-5-3-栈的应用"><a href="#2-5-3-栈的应用" class="headerlink" title="2.5.3 栈的应用"></a>2.5.3 栈的应用</h3><h4 id="1-进制转转换"><a href="#1-进制转转换" class="headerlink" title="1. 进制转转换"></a>1. 进制转转换</h4><blockquote><p>除基取余，从下到上</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> SYSTEM 2</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> STACKMAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *base;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decimal2binary</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    InitSack(S);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line"> 		Push(S,n % SYSTEM);</span><br><span class="line">        n /= SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))&#123;<span class="comment">//栈不空，一直出</span></span><br><span class="line">        Pop(S,e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-括号匹配"><a href="#2-括号匹配" class="headerlink" title="2. 括号匹配"></a>2. 括号匹配</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *base;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BracketsCheck</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">	InitStack(S);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(str[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                Push(S,<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                Push(S,<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                Push(S,<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                Pop(S,e);</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                Pop(S,e);</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                Pop(S,e);</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!StackEmpty(S))	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>		        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h4 id="3-判断字符串是否中心对称"><a href="#3-判断字符串是否中心对称" class="headerlink" title="3. 判断字符串是否中心对称"></a>3. 判断字符串是否中心对称</h4><blockquote><p>将串的前一半元素入栈。当串长度为奇数，跳过中间一个。</p><p>每从后一半串取到一个字符，都弹出栈顶一个字符，至栈为空，则中心对称。</p><p>若出现不相等，则不是中心对称</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">dc</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//串游标</span></span><br><span class="line">    <span class="comment">//求串长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>;str[len] != <span class="string">&#x27;\0&#x27;</span>;len++);</span><br><span class="line">    <span class="comment">//前一半字符入栈</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len/<span class="number">2</span>;++i)</span><br><span class="line">        Push(S,str[i]);</span><br><span class="line">    <span class="comment">//若长度是奇数，则跳过</span></span><br><span class="line">    <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="comment">//检测是否中心对称</span></span><br><span class="line">    <span class="type">char</span> e;<span class="comment">//暂存待比较字符</span></span><br><span class="line">    <span class="keyword">while</span>(str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        Pop(S,e);</span><br><span class="line">        <span class="keyword">if</span>(e != str[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h4 id="4-递归与迭代"><a href="#4-递归与迭代" class="headerlink" title="4. 递归与迭代"></a>4. 递归与迭代</h4><h5 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fac</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*fac(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fac</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>,product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(cnt = <span class="number">1</span>;cnt &lt;= n;cnt++)</span><br><span class="line">        product *= cnt;    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波拉切数列定义</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">fib0</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="comment">//时间复杂度来源于要重复计算 </span></span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	<span class="keyword">return</span> fib0(n<span class="number">-1</span>)+fib0(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指数阶化函数阶 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fib2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> first = <span class="number">0</span>,second = <span class="number">1</span>,third = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;++i)&#123;</span><br><span class="line">		third = first + second;</span><br><span class="line">		first = second;</span><br><span class="line">		second = third;</span><br><span class="line">	 &#125; </span><br><span class="line">	 <span class="keyword">return</span> third;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个递归函数的非递归运算"><a href="#一个递归函数的非递归运算" class="headerlink" title="一个递归函数的非递归运算"></a>一个递归函数的非递归运算</h5><script type="math/tex;mode=display">P_n(x) = 
\begin{cases} 
1 &,n=0 \\
2x &,n=1 \\
2xP_{n-1}(x)-2(n-1)P_{n-2}(x) &,n > 1
\end{cases}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> n,<span class="type">long</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>*x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*x*dp(n<span class="number">-1</span>,x)-x*(n<span class="number">-1</span>)*dp(n<span class="number">-2</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    ElemType *base;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> top;<span class="comment">//栈顶指针 </span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitStack</span><span class="params">(Stack &amp;S)</span>&#123;</span><br><span class="line">	S.base = (ElemType *)<span class="built_in">malloc</span>(MAXSIZE*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base)</span><br><span class="line">    	<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	S.size = <span class="number">0</span>;</span><br><span class="line">	S.top = <span class="number">-1</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span> n,<span class="type">long</span> x)</span>&#123;</span><br><span class="line">	<span class="type">long</span> fv1=<span class="number">1</span>,fv2 = <span class="number">2</span>*x;<span class="comment">//n=0,n=1的初始值</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> fv1;</span><br><span class="line">    Stack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">2</span>;--i)</span><br><span class="line">		S.base[++S.top].no = i;</span><br><span class="line">	<span class="keyword">while</span>(S.top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">		S.base[S.top].value </span><br><span class="line">            = <span class="number">2</span>*x*fv2<span class="number">-2</span>*(S.base[S.top].no<span class="number">-1</span>)*fv1;</span><br><span class="line">		fv1 = fv2;</span><br><span class="line">		fv2 = S.base[S.top].value;</span><br><span class="line">		S.top--;<span class="comment">//出栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-判断栈的操作序列是否合法"><a href="#5-判断栈的操作序列是否合法" class="headerlink" title="5. 判断栈的操作序列是否合法"></a>5. 判断栈的操作序列是否合法</h4><blockquote><p><em>I</em> 的数量是否等于 <em>O</em> 的数量，且过程中 <em>O</em> 的数量不能大于 <em>I</em> 的数量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Judge</span><span class="params">(Char A[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnti = <span class="number">0</span>,cnto = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(A[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(A[i])&#123;</span><br><span class="line">        	<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        		cnti++;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">	        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">    			cnto++;</span><br><span class="line">        		<span class="keyword">if</span>(cnto &gt; cnti)&#123;</span><br><span class="line">                	<span class="built_in">printf</span>(<span class="string">&quot;序列非法&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnti != cnto)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;序列非法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;序列非法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>I</em> 视为+1，<em>O</em> 视为-1，合法的栈操作序列过程中值不能小于0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Judge</span><span class="params">(<span class="type">char</span> A[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(A[i]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">switch</span>(A[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                sum++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                sum--;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;非法操作序列!&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;非法操作序列&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;合法操作序列&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="2-5-4-表达式表示与计算"><a href="#2-5-4-表达式表示与计算" class="headerlink" title="2.5.4 表达式表示与计算"></a>2.5.4 表达式表示与计算</h3><h4 id="1-中缀转后缀表达式"><a href="#1-中缀转后缀表达式" class="headerlink" title="1. 中缀转后缀表达式"></a>1. 中缀转后缀表达式</h4><p><strong>前提</strong></p><ul><li><p>优先级：</p><p>$*、\backslash&gt;+、-$，同级符号越靠左优先级越高</p><p>() 提高优先级</p></li></ul><h5 id="借助一个符号栈"><a href="#借助一个符号栈" class="headerlink" title="借助一个符号栈"></a>借助一个符号栈</h5><p><strong>例如</strong> a+b<em>c+(d\</em>e+f)*g $\Longrightarrow$ abc*+de*f+g*+</p><p><img src="/posts/3975030669/image-20220125222539554.png" alt></p><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><ol><li>找优先级最低的运算符作为根</li><li>分别对左右子树两部分表达式操作</li><li>重复1 2 直至表达式中只有数字</li></ol><p><img src="/posts/3975030669/image-20220125224019771.png" alt></p><p><img src="/posts/3975030669/image-20220125224111965.png" alt></p><ul><li>叶子结点都是操作数；非叶结点都是操作符</li><li>根结点运算符优先级最低</li></ul><h4 id="2-后缀表达式运算"><a href="#2-后缀表达式运算" class="headerlink" title="2. 后缀表达式运算"></a>2. 后缀表达式运算</h4><p>从左至右扫描后缀表达式</p><ul><li>若是数字，则压入数字栈</li><li>若是运算符，则弹出栈顶两元素，先读出的为右操作数，后读出的为左操作数，将运算结果压栈</li></ul><div style="page-break-after:always"></div><h4 id="3-中缀表达式运算"><a href="#3-中缀表达式运算" class="headerlink" title="3. 中缀表达式运算"></a>3. 中缀表达式运算</h4><p>从左到有扫描中缀表达式</p><p>若是数字，直接入数字栈</p><p>若是操作符</p><ol><li><p>‘(‘，直接入符号栈</p></li><li><p>‘)’，不停地把符号栈中 <code>top</code> 出栈，直至遇到 ‘(‘</p></li><li><p>‘* \\ + -‘ ，比较当前元素与符号栈顶 <code>top</code> 优先级比较</p><ul><li>若 <code>top &lt; current</code>，则压入符号栈</li><li>若 <code>top &gt;= current</code>，则栈顶符号出栈，直至满足 <code>top &lt; current</code></li></ul></li><li><p>符号栈每次出栈，需要从数字栈中连续出栈两次，将 <code>数字栈.top &lt;op&gt; 数字栈.top--</code> 压入数字栈</p></li><li><p>表达式扫描完后，若符号栈不空，则将数字栈中按照前四条运算。直至符号栈空</p></li></ol><p><img src="/posts/3975030669/image-20220125231352529.png" alt="image-20220125231352529"></p><div style="page-break-after:always"></div><h2 id="2-6-矩阵和广义表"><a href="#2-6-矩阵和广义表" class="headerlink" title="2.6 矩阵和广义表"></a>2.6 矩阵和广义表</h2><h3 id="2-6-1-数组"><a href="#2-6-1-数组" class="headerlink" title="2.6.1 数组"></a>2.6.1 数组</h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p>顺序存储线性表</p><ul><li>一维：线性表</li><li>多维：线性表的线性表</li></ul><p><strong>注</strong></p><ul><li>数组下标从0开始，矩阵下标从1开始</li></ul><h4 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h4><p>数组被定义后，维数与维界不再改变，只能存取和修改</p><h4 id="3-存储"><a href="#3-存储" class="headerlink" title="3. 存储"></a>3. 存储</h4><p>连续的内存空间</p><script type="math/tex;mode=display">Loc(a_i) = Loc(a_0)+i*L (0 \leq i < n)</script><p>多维数组的映射方式 行下标 $[0,h_1]$ ，列下标 $[0,h_2]$</p><ul><li><p>行优先</p><script type="math/tex;mode=display">Loc(a_{ij})=Loc(a_{0,0})+[i*(h_2+1)+j]*L</script></li><li><p>列优先</p><script type="math/tex;mode=display">Loc(a_{ij})=Loc(a_{0,0})+[j*(h_1+1)+i]*L</script></li></ul><div style="page-break-after:always"></div><h3 id="2-6-2-矩阵压缩存储"><a href="#2-6-2-矩阵压缩存储" class="headerlink" title="2.6.2 矩阵压缩存储"></a>2.6.2 矩阵压缩存储</h3><blockquote><p>矩阵压缩存储：将二维矩阵映射到一维数组，并将矩阵中元素按矩阵下标与一维数组下标间的某一种映射关系存储到数组中</p></blockquote><p><strong>注</strong></p><ul><li>A[1…n][1…n] 表示矩阵，下标从 (1,1) 开始</li><li>B表示存储数组，下标从 0 开始</li></ul><h4 id="1-对称矩阵"><a href="#1-对称矩阵" class="headerlink" title="1. 对称矩阵"></a>1. 对称矩阵</h4><p>目的：</p><script type="math/tex;mode=display">A[1...n][1...n]\Longrightarrow B[\frac{n(n+1)}{2}]</script><p>由于对称阵 <code>A[i][j]==A[j][i]</code> ，故对 <code>A[i][j]</code> 按 <em>按列优先存储</em> 与 <em>按行优先存储</em> 在一维存储数组中位置相同，即成立</p><script type="math/tex;mode=display">一维存储矩阵下标k=
\begin{cases}
\frac{i(i-1)}{2}+j-1 &,i \ge j\\
\frac{j(j-1)}{2}+i-1 &,i<j
\end{cases}</script><p><strong>理解</strong> ： 按行优先，<code>A[i][j]</code> 的下三角前 <code>i-1</code> 行全部存入到存储数组中，共占 $\frac{(1+i-1)(i-1)}{2}$ 个存储空间。第 <code>i</code> 行的前 <code>j-1</code> 个元素存入存储数组，故共占 $\frac{(1+i-1)(i-1)}{2}+j-1$ 个存储空间。</p><h4 id="2-三角矩阵"><a href="#2-三角矩阵" class="headerlink" title="2. 三角矩阵"></a>2. 三角矩阵</h4><h5 id="下三角"><a href="#下三角" class="headerlink" title="下三角"></a>下三角</h5><p>存完下三角区，再加相同的上三角区元素</p><script type="math/tex;mode=display">\begin{bmatrix}
a_{11} &c & \cdots &\cdots &c\\
a_{21} & a_{22} &c & \cdots  & c \\
a_{31} & a_{32} & a_{33} &\cdots & c\\
\vdots & \vdots & \vdots &\ddots  &\vdots \\
a_{n1} & a_{n2} & a_{n3} & \cdots & a_{nn}
\end{bmatrix}</script><p><strong>行优先</strong> ：矩阵下标 <code>A[i][j]</code> 与存储数组下标 <code>B[k]</code> 的对应关系为</p><script type="math/tex;mode=display">k=
\begin{cases}
\frac{i(i-1)}{2}+j-1 &,i \ge j(下三角区) \\
\frac{n(n+1)}{2} &,i < j(上三角区)
\end{cases}</script><p><img src="/posts/3975030669/image-20220126180218361.png" alt></p><h5 id="上三角"><a href="#上三角" class="headerlink" title="上三角"></a>上三角</h5><p>存完上三角区，再加相同的下三角区元素</p><script type="math/tex;mode=display">\begin{bmatrix}
a_{11} & a_{12} & a_{13} & \cdots & a_{1n} \\
c & a_{22} & a_{23} &\cdots & a_{2n}\\
c & c & a_{33} & \cdots  & a_{3n} \\
\vdots & \vdots & \vdots &\ddots  &\vdots \\
c &c & \cdots &\cdots &a_{nn}\\
\end{bmatrix}</script><p><strong>行优先</strong> ：矩阵下标 <code>A[i][j]</code> 与存储数组下标 <code>B[k]</code> 的对应关系为</p><script type="math/tex;mode=display">k=
\begin{cases}
\frac{(i-1)(2n-i+2)}{2}+j-i &,i \le j(上三角区) \\
\frac{n(n+1)}{2} &,i > j(下三角区)
\end{cases}</script><p><img src="/posts/3975030669/image-20220126182807378.png" alt></p><p><em>上三角矩阵行优先</em> 存储与 <em>下三角矩阵按列优先</em> 存储下标相同，故不再过多推导。</p><h4 id="3-三对角矩阵"><a href="#3-三对角矩阵" class="headerlink" title="3. 三对角矩阵"></a>3. 三对角矩阵</h4><script type="math/tex;mode=display">\begin{bmatrix}
a_{11} &a_{12}\\
a_{21} & a_{22} &a_{23} \\
 & a_{32} & a_{33} &a_{34}\\
&&\ddots&\ddots&\ddots   \\
&&&a_{n-1n-2}& a_{n-1n-1} & a_{n-1n} \\
&&&& a_{nn-1} & a_{nn}
\end{bmatrix}</script><div style="page-break-after:always"></div><p>除第一行和最后一行有两个元素，其余各行都有三个元素，故</p><script type="math/tex;mode=display">a_{i,j} \rightarrow b_{2+3(i-2)+j-i+1}</script><h3 id="2-6-3稀疏矩阵"><a href="#2-6-3稀疏矩阵" class="headerlink" title="2.6.3稀疏矩阵"></a>2.6.3稀疏矩阵</h3><h4 id="1-十字链表存储"><a href="#1-十字链表存储" class="headerlink" title="1. 十字链表存储"></a>1. 十字链表存储</h4><p><img src="/posts/3975030669/image-20220126192811630.png" alt></p><h4 id="2-三元组存储"><a href="#2-三元组存储" class="headerlink" title="2. 三元组存储"></a>2. 三元组存储</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">    datatype v;</span><br><span class="line">&#125;triple;<span class="comment">//三元组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	triple data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> m,n,t;<span class="comment">//存储矩阵的行、列——还原，t-三元组行数</span></span><br><span class="line">&#125;tripletable;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h5 id="三元组转置"><a href="#三元组转置" class="headerlink" title="三元组转置"></a>三元组转置</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transmatrix</span><span class="params">(tripletable A,tripletable &amp;AT)</span>&#123;</span><br><span class="line">    AT.m = A.m;</span><br><span class="line">    AT.n = A.n;</span><br><span class="line">    AT.t = A.t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(AT.t &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt;A.t;++p)&#123;</span><br><span class="line">        AT.data[p].i = A.data[p].j;</span><br><span class="line">        AT.data[p].j = A.data[p].i;</span><br><span class="line">        AT.data[p].v = A.data[p].v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但此时 <code>AT</code> 不是按 <code>i</code> 递增排序的</p><p>设置向量 <code>num</code> ，<code>num[copt]</code> 表示 <code>A</code> 中第 <code>col</code> 列中非零元的个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(col = <span class="number">1</span>;col &lt; A.n;++col)</span><br><span class="line">    num[col] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(p = <span class="number">1</span>;p &lt;= A;++p)<span class="comment">//计算A中每列非零元的个数</span></span><br><span class="line">    num[A.data[p].j]++;</span><br></pre></td></tr></table></figure><blockquote><p>设置向量 <code>cpot</code> ，<code>cpot[col]</code> 指示 <code>A</code> 中第 <code>col</code> 列的第一个非零元在转置矩阵 <code>AT.data</code> 中的位置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(col = <span class="number">2</span>;col &lt;= A.n;++col)</span><br><span class="line">    cpot[col] = cpot[col<span class="number">-1</span>]+num[col<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><blockquote><p>遍历 <code>A</code> 三元组表，<code>it</code> 表示 <code>A.data[p]</code> ，<code>it</code> 在 <code>AT</code> 中的位置由 <code>cpot[it]</code> 指示。 完成转置后，将该列的第一个空闲位置后移。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = <span class="number">1</span>;p &lt;= A.t;++p)&#123;<span class="comment">//转置</span></span><br><span class="line">    col = A.data[p].j;</span><br><span class="line">    q = copt[col];</span><br><span class="line">    AT.data[q].i = A.data[p].j;</span><br><span class="line">    AT.data[q].j = A.data[p].i;</span><br><span class="line">    cpot[col]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after:always"></div><h3 id="2-6-4-广义表"><a href="#2-6-4-广义表" class="headerlink" title="2.6.4 广义表"></a>2.6.4 广义表</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>任何一个非空广义表 $LS=(\alpha1,\alpha2,…\alpha_n)$ 可分解为表头和表尾两部分</p><p><strong>表头</strong> ：第一个 <strong>元素</strong></p><ul><li>$Head(LS) = \alpha1$</li></ul><p><strong>表尾</strong>：除第一个元素外其余元素构成的 <strong>表</strong></p><ul><li>$Tail(LS) = (\alpha2,…\alpha n)$</li></ul><blockquote><p>$D = (E,F) = ((a,(b,c),F)$</p><ul><li>Head(D) = E Tail(D) = (F)</li><li>Head(E) = a Tail(E) = ((b,c))</li><li>Head(((b,c))) = (b,c) Tail(((b,c))) = ()</li><li>Head((b,c)) = b Tail(b,c) = (c)</li></ul></blockquote><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul><li>广义表的 <em>长度</em> 为表中元素个数</li><li>广义表的 <em>深度</em> 为表的嵌套层数<ul><li><em>原子</em> 深度为0</li><li><em>空表</em> 深度为1</li></ul></li></ul><blockquote><ul><li>A = ()：A是一个空表，深度为1，长度为0</li><li>B = (e)：B中只有一个原子，深度为1，长度为1</li><li>C = (a,(b,c,d))：C中有一个原子和一个子表，深度为2，长度为2</li><li>D = (A,B,C)：D中有3个子表，深度为3，长度为3</li></ul></blockquote></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/3975030669/" title="2.线性表">https://amostian.github.io/posts/3975030669/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tags"></i> 计算机基础</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tags"></i> 数据结构</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2368499558/" rel="prev" title="0.绪论"><i class="fa fa-chevron-left"></i> 0.绪论</a></div><div class="post-nav-item"><a href="/posts/3274436167/" rel="next" title="4.图">4.图 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E7%89%B9%E7%82%B9"><span class="nav-text">2.1.1 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%98%AF%E4%B8%80%E7%A7%8D%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">2.1.2 线性表是一种逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">2.1.3 基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">2.2 线性表的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">2.2.1 线性表的顺序存储——顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%89%B9%E7%82%B9"><span class="nav-text">1. 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">2. 结点定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0"><span class="nav-text">3. 基本操作实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%BA%94%E7%94%A8"><span class="nav-text">4. 顺序表应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E8%A1%A8%E5%90%88%E5%B9%B6"><span class="nav-text">两表合并</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%90%88%E5%B9%B6%E8%BF%94%E5%9B%9E%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">顺序表合并返回顺序表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-text">快慢指针</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8E%BB%E9%87%8D"><span class="nav-text">有序顺序表去重</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0"><span class="nav-text">删除指定元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%85%83%E7%B4%A0"><span class="nav-text">删除有序表指定范围元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%85%83%E7%B4%A0"><span class="nav-text">删除无序表指定范围元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E8%A1%A8%E5%8E%BB%E9%87%8D"><span class="nav-text">无序表去重</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">删除最小值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8E%BB%E9%87%8D"><span class="nav-text">无序顺序表去重</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">折半查找</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE-1"><span class="nav-text">折半查找</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">2.2.2 线性表的链式存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%89%B9%E7%82%B9-1"><span class="nav-text">1. 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">2. 单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">结点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">单链表的创建</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-text">查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-text">插入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-text">删除</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B1%82%E9%95%BF%E5%BA%A6"><span class="nav-text">求长度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E5%BA%8F%E5%88%97"><span class="nav-text">公共序列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%BE%E5%85%AC%E5%85%B1-%E7%BB%93%E7%82%B9"><span class="nav-text">找公共 结点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%BE%E5%85%AC%E5%85%B1-%E5%BA%8F%E5%88%97"><span class="nav-text">找公共 序列</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6"><span class="nav-text">合并</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6"><span class="nav-text">归并</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B1%82%E4%B8%A4%E9%93%BE%E8%A1%A8%E4%BA%A4%E9%9B%86"><span class="nav-text">求两链表交集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%89%BE%E5%85%AC%E5%85%B1%E5%85%83%E7%B4%A0"><span class="nav-text">有序表找公共元素</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%80%9D%E8%B7%AF"><span class="nav-text">相关思路</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="nav-text">头插法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="nav-text">尾插法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-1"><span class="nav-text">快慢指针</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E6%8C%87%E9%92%88%E5%8F%8D%E8%BD%AC"><span class="nav-text">快慢指针实现指针反转</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="nav-text">空间换时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">3. 双链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89-1"><span class="nav-text">结点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1"><span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E9%AB%98%E9%A2%91%E8%AE%BF%E9%97%AE"><span class="nav-text">最近最高频访问</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-text">4. 循环链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">循环单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="nav-text">约瑟夫问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BF%9E%E6%8E%A5"><span class="nav-text">将两个循环单链表连接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">循环单链表选择排序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">循环双链表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0"><span class="nav-text">判断循环双链表是否对称</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">5. 静态链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E6%AF%94%E8%BE%83"><span class="nav-text">2.2.3 顺序表与链表比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">2.2.4 存储结构的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E4%B8%B2"><span class="nav-text">2.3 串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.3.1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">1. 基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%B2-amp-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">2. 串&amp;线性表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.3.2 存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E9%95%BF%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">1. 定长顺序存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A0%86%E5%88%86%E9%85%8D"><span class="nav-text">2. 堆分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">2.3.3 模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="nav-text">1. 暴力法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-KMP"><span class="nav-text">2. KMP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%8F%AF%E4%BC%98%E5%8C%96%E9%83%A8%E5%88%86"><span class="nav-text">暴力法模式匹配可优化部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#KMP%E8%BF%87%E7%A8%8B"><span class="nav-text">KMP过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#next-j-%E6%80%8E%E6%A0%B7%E5%BA%94%E7%94%A8%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">next[j] 怎样应用算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#KMP%E4%BC%98%E5%8C%96"><span class="nav-text">KMP优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E9%98%9F%E5%88%97"><span class="nav-text">2.4 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="nav-text">2.4.1 顺序队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2. 结构定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">3. 基本操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">2.4.2 循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2. 存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1"><span class="nav-text">3. 基本操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="nav-text">2.4.3 链式队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A4%B4%E7%BB%93%E7%82%B9%E5%AF%B9%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%85%A5%E9%98%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">1. 头结点对第一次入队的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-text">2. 出队操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%A4%E7%A9%BA%E6%9D%A1%E4%BB%B6"><span class="nav-text">3. 判空条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">4. 存储结构的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-text">2.4.4 双端队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-5-FIFO%E6%80%9D%E6%83%B3%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.4.5 FIFO思想的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">1. 层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BA%94%E7%94%A8%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">2. 应用于计算机系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E6%A0%88"><span class="nav-text">2.5 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.5.1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="nav-text">1. 卡特兰数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%81%E6%98%8E"><span class="nav-text">*证明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.5.2 栈的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-text">1. 顺序栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%93%BE%E6%A0%88"><span class="nav-text">2. 链栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.5.3 栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BF%9B%E5%88%B6%E8%BD%AC%E8%BD%AC%E6%8D%A2"><span class="nav-text">1. 进制转转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="nav-text">2. 括号匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%AD%E5%BF%83%E5%AF%B9%E7%A7%B0"><span class="nav-text">3. 判断字符串是否中心对称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-text">4. 递归与迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E4%B9%98"><span class="nav-text">阶乘</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">斐波那契数列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E8%BF%90%E7%AE%97"><span class="nav-text">一个递归函数的非递归运算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%88%A4%E6%96%AD%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="nav-text">5. 判断栈的操作序列是否合法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%AE%A1%E7%AE%97"><span class="nav-text">2.5.4 表达式表示与计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">1. 中缀转后缀表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%9F%E5%8A%A9%E4%B8%80%E4%B8%AA%E7%AC%A6%E5%8F%B7%E6%A0%88"><span class="nav-text">借助一个符号栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二叉树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97"><span class="nav-text">2. 后缀表达式运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97"><span class="nav-text">3. 中缀表达式运算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">2.6 矩阵和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E6%95%B0%E7%BB%84"><span class="nav-text">2.6.1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">2. 基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%98%E5%82%A8"><span class="nav-text">3. 存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E7%9F%A9%E9%98%B5%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">2.6.2 矩阵压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="nav-text">1. 对称矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="nav-text">2. 三角矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8B%E4%B8%89%E8%A7%92"><span class="nav-text">下三角</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E4%B8%89%E8%A7%92"><span class="nav-text">上三角</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="nav-text">3. 三对角矩阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="nav-text">2.6.3稀疏矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="nav-text">1. 十字链表存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%89%E5%85%83%E7%BB%84%E5%AD%98%E5%82%A8"><span class="nav-text">2. 三元组存储</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E8%BD%AC%E7%BD%AE"><span class="nav-text">三元组转置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-4-%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">2.6.4 广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%89%B9%E7%82%B9"><span class="nav-text">2. 特点</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">390</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">61</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">78</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1025.5k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">42:31</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>