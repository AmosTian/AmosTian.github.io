<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="为更好的支持多到程序执行，提高系统的资源利用率，需要对内存进行管理   对内存的访问以块为单位，对内存的分配由采用的分配方式决定   编址空间位数取决于硬件访存能力，地址总线宽度"><meta property="og:type" content="article"><meta property="og:title" content="3.内存管理"><meta property="og:url" content="https://amostian.github.io/posts/3792261443/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="为更好的支持多到程序执行，提高系统的资源利用率，需要对内存进行管理   对内存的访问以块为单位，对内存的分配由采用的分配方式决定   编址空间位数取决于硬件访存能力，地址总线宽度"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309152126995.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309153112340.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309160220613.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309162439562.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309165958532.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309175007779.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309183847986.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309191038121.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309194455543.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220310081424000.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309204157318.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309204814804.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309204839560.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309205448397.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309214629382.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309215132634.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309215158600.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309220221704.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309224302709.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220309225127053.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220310084541231.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220310091732273.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220310094428470.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220311085437866.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220311093229131.png"><meta property="og:image" content="https://amostian.github.io/posts/3792261443/image-20220311093015139.png"><meta property="article:published_time" content="2022-03-09T14:50:33.000Z"><meta property="article:modified_time" content="2022-03-11T01:53:08.000Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="计算机基础"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/3792261443/image-20220309152126995.png"><link rel="canonical" href="https://amostian.github.io/posts/3792261443/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>3.内存管理 | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">61</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">78</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">390</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/3792261443/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">3.内存管理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2022-03-09 22:50:33" itemprop="dateCreated datePublished" datetime="2022-03-09T22:50:33+08:00">2022-03-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2022-03-11 09:53:08" itemprop="dateModified" datetime="2022-03-11T09:53:08+08:00">2022-03-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">8.5k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>为更好的支持多到程序执行，提高系统的资源利用率，需要对内存进行管理</p><p>对内存的访问以块为单位，对内存的分配由采用的分配方式决定</p><p>编址空间位数取决于硬件访存能力，地址总线宽度</p></blockquote><span id="more"></span><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><blockquote><p>操作系统对内存的划分和分配</p></blockquote><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><h3 id="3-1-1-存储器的层次化结构"><a href="#3-1-1-存储器的层次化结构" class="headerlink" title="3.1.1 存储器的层次化结构"></a>3.1.1 存储器的层次化结构</h3><p><img src="/posts/3792261443/image-20220309152126995.png" alt></p><h4 id="a-主要思想"><a href="#a-主要思想" class="headerlink" title="a. 主要思想"></a>a. 主要思想</h4><blockquote><p>上一层是下一层的高速缓存，解决速度、容量、成本的矛盾</p></blockquote><p>速度越慢的设备，CPU访问频率越低</p><p>在辅存中的数据只有调入主存才可被CPU访问</p><h4 id="b-三级存储系统"><a href="#b-三级存储系统" class="headerlink" title="b. 三级存储系统"></a>b. 三级存储系统</h4><p>上一层存的是下一层数据的副本</p><p><img src="/posts/3792261443/image-20220309153112340.png" alt></p><h5 id="Cache-主存"><a href="#Cache-主存" class="headerlink" title="Cache-主存"></a>Cache-主存</h5><ul><li><strong>解决CPU和主存速度不匹配问题</strong></li><li><strong>全部由硬件自动完成</strong></li><li>速度接近Cache，容量和价位仅仅主存</li><li>对任何程序员透明</li></ul><h5 id="主存-辅存"><a href="#主存-辅存" class="headerlink" title="主存-辅存"></a>主存-辅存</h5><ul><li><strong>解决存储系统容量问题</strong></li><li><strong>将主存与辅存的一部分通过软/硬结合的技术形成虚拟存储器</strong></li><li>速度接近主存，容量和价位仅仅辅存</li><li>对应用程序员透明</li></ul><h3 id="3-1-2-内存管理功能"><a href="#3-1-2-内存管理功能" class="headerlink" title="3.1.2 内存管理功能"></a>3.1.2 内存管理功能</h3><ol><li><p>逻辑地址到物理地址的转换</p></li><li><p>内存的分配与回收</p><ul><li><p>连续分配管理方式</p><p>单一连续分配</p><p>固定分区分配</p><p>动态分区分配</p></li><li><p>非连续分配管理方式</p><p>基本分页存储管理</p><p>基本分段存储管理</p><p>段页管理方式</p></li></ul></li><li><p>内存的扩容</p><ul><li><p>覆盖技术</p></li><li><p>虚拟内存</p><p>请求分页存储管理</p></li></ul></li><li><p>存储保护</p></li></ol><h3 id="3-1-3-一段代码载入内存的过程"><a href="#3-1-3-一段代码载入内存的过程" class="headerlink" title="3.1.3 一段代码载入内存的过程"></a>3.1.3 一段代码载入内存的过程</h3><p><img src="/posts/3792261443/image-20220309160220613.png" alt="image-20220309160220613"></p><h4 id="1-预处理阶段"><a href="#1-预处理阶段" class="headerlink" title="1. 预处理阶段"></a>1. 预处理阶段</h4><p>主要完成 <code>#</code> 后的各项内容到源文件的替换</p><ul><li><code>#ifdef</code> 完成条件编译内容的替换</li><li><code>#include</code> ，将头文件内容拷贝到源文件</li><li><code>#define</code> ，替换宏定义</li></ul><p>完成后产生 <code>file1.i</code> 类型的文件</p><h4 id="2-编译阶段"><a href="#2-编译阶段" class="headerlink" title="2. 编译阶段"></a>2. 编译阶段</h4><p>编译：完成语法和语义分析，然后生成中间代码 <code>file.s</code> 类型的汇编代码文件</p><p>汇编：通过汇编器，将汇编代码翻译成机器指令，生成 <code>file.o</code> 类型的二进制文件</p><h4 id="3-链接阶段"><a href="#3-链接阶段" class="headerlink" title="3. 链接阶段"></a>3. 链接阶段</h4><blockquote><p>将文件中调用的各种函数跟静态库和动态库连接，一起打包并形成可执行文件</p></blockquote><h5 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h5><blockquote><p><strong>程序运行之前</strong>，将各 <code>.o</code>文件 及其所需的库函数链接成一个完整的装入模块</p></blockquote><h5 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h5><blockquote><p>边装入内存边链接</p></blockquote><h5 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h5><blockquote><p>需要的 <code>.o</code> 模块才进行链接</p></blockquote><p>便于修改和更新，实现<code>.o</code>模块的共享</p><p>动态链接与程序逻辑结构有关，<strong>段式内存分配</strong></p><h4 id="4-装入"><a href="#4-装入" class="headerlink" title="4. 装入"></a>4. 装入</h4><h5 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h5><p>目标模块中的地址是内存的物理地址</p><p>逻辑地址与实际地址完全相同，适用于单道程序设计</p><h5 id="可重定位装入-静态重定位"><a href="#可重定位装入-静态重定位" class="headerlink" title="可重定位装入(静态重定位)"></a>可重定位装入(静态重定位)</h5><blockquote><p>多个程序生成的多个目标模块，每个模块的地址单元从 <code>#0</code> 开始</p></blockquote><p>静态重定位：地址变换在装入时一次完成</p><ul><li>重定位：逻辑地址变为物理地址</li></ul><p>特点</p><ul><li>一次装入：<strong>必须分配连续的内存空间</strong></li><li><strong>装入后不可移动</strong></li></ul><h5 id="动态运行时装入-动态重定位"><a href="#动态运行时装入-动态重定位" class="headerlink" title="动态运行时装入(动态重定位)"></a>动态运行时装入(动态重定位)</h5><blockquote><p>地址转换在真正运行时才确定</p></blockquote><p>由于存在装入后换出，所以目标模块的物理地址也会相应改变</p><p>特点</p><ul><li><p>需要硬件支持（重定位寄存器）</p><p>存放进程在内存中的起始地址</p><p>整个系统只有一个重定位寄存器，处理器同一时刻只能执行一条指令</p></li><li><p>属于同一作业的目标模块可能分配到不连续的存储空间</p></li><li><p>只装入整个程序的部分代码即可运行，运行期间，根据需要动态申请内存</p></li><li><p>便于程序段的共享，提供远大于物理内存空间的逻辑地址空间</p></li></ul><h5 id="装入方式对应的内存分配方式"><a href="#装入方式对应的内存分配方式" class="headerlink" title="装入方式对应的内存分配方式"></a>装入方式对应的内存分配方式</h5><p><img src="/posts/3792261443/image-20220309162439562.png" alt></p><h3 id="3-1-4-交换技术提高程序道数"><a href="#3-1-4-交换技术提高程序道数" class="headerlink" title="3.1.4 交换技术提高程序道数"></a>3.1.4 交换技术提高程序道数</h3><p>交换技术：指中级调度</p><h4 id="a-调度时机"><a href="#a-调度时机" class="headerlink" title="a. 调度时机"></a>a. 调度时机</h4><p>多进程运行且内存不够时，发生中级调度</p><ul><li>指标：缺页率过大</li></ul><p>当系统符合低时，停止调度</p><h4 id="b-换入换出的对象"><a href="#b-换入换出的对象" class="headerlink" title="b. 换入换出的对象"></a>b. 换入换出的对象</h4><blockquote><p>换出：将处于 <strong>阻塞状态</strong> 或 <strong>在CPU调度中失去运行权利</strong> 的程序从内存移到外存</p></blockquote><ul><li>处于IO状态的进程不能换出，否则会造成IO区的数据被新换入的进程占用，导致错误</li></ul><blockquote><p>换入：将准备好竞争CPU运行的 <strong>挂起态</strong> 进程从辅存移动到内存</p></blockquote><h4 id="c-基本要求"><a href="#c-基本要求" class="headerlink" title="c. 基本要求"></a>c. 基本要求</h4><ul><li><p>交换需要备份，<strong>PCB常驻内存</strong></p></li><li><p>确保每个进程执行时间比交换时间长</p></li></ul><h4 id="d-空间支持"><a href="#d-空间支持" class="headerlink" title="d. 空间支持"></a>d. 空间支持</h4><p>文件系统划分为文件区和对换区</p><ul><li><p>文件区：追求存储密度，采用离散分配方式</p></li><li><p>对换区：追求交换速度，采用连续分配方式</p></li></ul><h2 id="3-2-地址转换"><a href="#3-2-地址转换" class="headerlink" title="3.2 地址转换"></a>3.2 地址转换</h2><p>地址：用于标记某一存储单元，如按字节编址，则地址标记的是某一字节</p><blockquote><p>将逻辑地址转换为物理地址</p></blockquote><p>系统编程人员才知道内存管理的具体机制</p><p>应用程序员只知道逻辑地址</p><h3 id="3-2-1-物理地址"><a href="#3-2-1-物理地址" class="headerlink" title="3.2.1 物理地址"></a>3.2.1 物理地址</h3><blockquote><p>内存中物理单元的集合</p></blockquote><p>运行时， 指令执行和数据访问 都要通过物理地址从主存存取</p><h3 id="3-2-2-逻辑地址"><a href="#3-2-2-逻辑地址" class="headerlink" title="3.2.2 逻辑地址"></a>3.2.2 逻辑地址</h3><blockquote><p>不同进程有独立的逻辑地址空间，映射到不同的内存物理地址</p></blockquote><h2 id="3-3-存储保护"><a href="#3-3-存储保护" class="headerlink" title="3.3 存储保护"></a>3.3 存储保护</h2><blockquote><p>保证各道作业在分配给各自的存储空间内运行，互不干扰</p><ul><li>保护操作系统进程不受用户进程影响</li><li>保护用户进程不收其他用户进程影响</li></ul></blockquote><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><p><img src="/posts/3792261443/image-20220309165958532.png" alt></p><h4 id="界地址寄存器"><a href="#界地址寄存器" class="headerlink" title="界地址寄存器"></a>界地址寄存器</h4><p>存的内容是当前进程的逻辑地址范围</p><p>主要运算是 <strong>比较</strong> ，判断是否越界</p><h4 id="重定位寄存器-基址寄存器"><a href="#重定位寄存器-基址寄存器" class="headerlink" title="重定位寄存器(基址寄存器)"></a>重定位寄存器(基址寄存器)</h4><p>存的内容是最小物理地址值</p><p>主要运算是 <strong>加</strong> ，通过与界地址寄存器相加得到物理地址</p><h2 id="3-4-内存分配与回收"><a href="#3-4-内存分配与回收" class="headerlink" title="3.4 内存分配与回收"></a>3.4 内存分配与回收</h2><p>内部碎片与外部碎片：</p><ul><li>分配了但没用完，就是内部碎片；</li><li>外部碎片，所有分区外没分配的内存空间</li></ul><p>只要存在 <em>固定</em> ，则一定会存在内部碎片，而 <em>动态</em> 的分配方式，会产生外部碎片</p><p>段页式——固定与动态同时存在，按固定处理</p><h3 id="3-4-1-连续内存分配方式"><a href="#3-4-1-连续内存分配方式" class="headerlink" title="3.4.1 连续内存分配方式"></a>3.4.1 连续内存分配方式</h3><blockquote><p>连续内存分配，不需要记录映射表，相应的系统代价小</p></blockquote><h4 id="a-单一连续分配"><a href="#a-单一连续分配" class="headerlink" title="a. 单一连续分配"></a>a. 单一连续分配</h4><p>分为系统区与用户区</p><ul><li>系统区：仅供操作系统使用，低地址部分</li></ul><p>特点</p><ul><li><p>无需内存保护：内存中永远只有一道程序</p></li><li><p>优点：</p><p>简单，无需额外技术支持；</p><p><strong>无外部碎片</strong>；</p><p><strong>可采用覆盖技术解决空间不足，交换技术提高作业道数</strong></p></li><li><p>缺点：只能用于单用户单任务操作系统；<strong>有内部碎片</strong>；存储器利用率低</p></li></ul><h5 id="硬件支持-1"><a href="#硬件支持-1" class="headerlink" title="硬件支持"></a>硬件支持</h5><ul><li>界地址寄存器、越界检查机构</li></ul><h4 id="b-固定分区分配"><a href="#b-固定分区分配" class="headerlink" title="b. 固定分区分配"></a>b. 固定分区分配</h4><blockquote><p>将内存划分为若干大小固定的分区，每个分区只能装入一道程序</p></blockquote><p>当分区大小相等时，适合一台计算机控制多个相同对象</p><h5 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h5><p>分区说明表：用于实现各个分区的分配与回收</p><p>每个表项对应一个分区，通常按分区大小排列。</p><p>每个表项包括 对应分区的大小、起始地址、状态（是否已分配）</p><p>当有一个程序请求装入时，查分区说明表，如果有大小合适的分区，则修改状态</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>优点：<strong>无外部碎片</strong></li><li>缺点：存在<strong>内部碎片</strong>；规定了分区大小，大程序无法装入，只能采用覆盖技术；</li></ul><h5 id="硬件支持-2"><a href="#硬件支持-2" class="headerlink" title="硬件支持"></a>硬件支持</h5><ul><li>界地址寄存器、越界检查机构</li><li>重定位寄存器</li><li>长度寄存器</li><li>动态地址转换机构</li></ul><h4 id="c-动态-可变-分区分配"><a href="#c-动态-可变-分区分配" class="headerlink" title="c. 动态(可变)分区分配"></a>c. 动态(可变)分区分配</h4><blockquote><p>根据待装入进程实际大小建立分区</p></blockquote><h5 id="相关数据结构-1"><a href="#相关数据结构-1" class="headerlink" title="相关数据结构"></a>相关数据结构</h5><ul><li>空闲分区表</li><li>空闲分区链</li></ul><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p><strong>存在外部碎片</strong> ，无内部碎片</p><p>解决方案：紧凑</p><ul><li>在重定位寄存器的支持下，OS不断进行进程的移动和整理</li></ul><h5 id="分区分配-分区选择算法"><a href="#分区分配-分区选择算法" class="headerlink" title="分区分配(分区选择算法)"></a>分区分配(分区选择算法)</h5><p>首次适应算法</p><blockquote><p>将空闲分区按地址递增连接，分配内存时尽可能使用低地址部分的空闲分区</p><p>高地址留下大的空闲分区</p></blockquote><p>优点：</p><ul><li>综合性能最好</li><li>算法开销小，回收分区后不需要对空闲分区队列重新排序</li></ul><p>缺点：低地址出现了较多的小空闲分区，增加查找开销</p><hr><p>循环首次适应算法(邻近适应)</p><blockquote><p>将空闲分区按地址递增连接，从上次查找结束的位置继续</p></blockquote><p>优点：不用每次从低地址的小分区开始检索</p><p>缺点：不利于大进程，导致在高地址的大分区也被用完，分裂为小碎片</p><hr><p>最佳适应算法</p><blockquote><p>将空闲分区按容量递增连接</p></blockquote><p>缺点：</p><ul><li>产生较多外部碎片：会产生太小的，难以利用的碎片</li><li>算法开销大：回收分区后可能需要对空闲分区队列重新排序</li></ul><hr><p>最坏适应(最大适应)</p><blockquote><p>将空闲分区按容量递减连接</p></blockquote><p>缺点：</p><ul><li>大内存块缺失，不利于大进程</li><li>算法开销大</li></ul><hr><p><strong>性能</strong>：</p><script type="math/tex;mode=display">首次适应\ge 最佳适应 > 最大适应</script><h5 id="分区的回收"><a href="#分区的回收" class="headerlink" title="分区的回收"></a>分区的回收</h5><p>相邻空闲空间合并</p><p>使用拼接技术合并空闲区</p><h3 id="3-4-2-动态内存分配"><a href="#3-4-2-动态内存分配" class="headerlink" title="3.4.2 动态内存分配"></a>3.4.2 动态内存分配</h3><blockquote><p>需要额外的空间存储索引，数据存储密度低于连续存储</p></blockquote><p><img src="/posts/3792261443/image-20220309175007779.png" alt></p><h4 id="A-基本分页存储管理"><a href="#A-基本分页存储管理" class="headerlink" title="A. 基本分页存储管理"></a>A. 基本分页存储管理</h4><h5 id="a-概念"><a href="#a-概念" class="headerlink" title="a. 概念"></a>a. 概念</h5><p>存储空间的单位：主存和进程划分为大小相等的块，作为主存的基本单位</p><ul><li>以块为单位逐个申请主存中的块</li><li>进程按与主存大小相同的块划分，运行按块申请空间</li></ul><p>页与页框</p><blockquote><p>进程中的块称为页</p><p>内存中的块称为页框</p></blockquote><ul><li>页框号=页号=物理页号=物理块号</li></ul><h6 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h6><p>页面大小应为2的整数次幂，便于硬件处理</p><p>页面大小划分应适中</p><ul><li><p>过小：</p><p>页表过长，占用大量内存，不能充分利用访存的空间局部性提高命中率</p><p>增加地址转换的开销，降低页面换入/换出的效率</p></li><li><p>过小</p><p>平均页内碎片较大，降低内存利用率</p><p>页面太大会使页面调入/调入时间较长</p></li></ul><h5 id="b-特点"><a href="#b-特点" class="headerlink" title="b. 特点"></a>b. 特点</h5><p>不会产生外部碎片</p><p>只有最后一个不完整的块申请内存时才会产生页内碎片</p><p>每个进程平均产生半个页的页内碎片</p><p>块相对于分区小很多</p><h5 id="c-支持机构"><a href="#c-支持机构" class="headerlink" title="c. 支持机构"></a>c. 支持机构</h5><h6 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h6><p><img src="/posts/3792261443/image-20220309183847986.png" alt></p><p>页表存放于内存中，本进程的PCB中</p><p>页表项连续存放，下标号对应的是逻辑空间的页号</p><p>页表项：页号与内存块号的映射</p><p>页表项大小的确定</p><ul><li>一个页面刚好存储整数个页表项</li><li>页表项顺序连续存放在内存</li></ul><p>页面大小：页面占用的存储空间 $=2^{页内地址位数}$</p><p>页表长度：页数 $=页号范围=2^{页号位数}$</p><p>页表项长度：一个页表项占用的存储空间 $=页号位数$</p><h6 id="寄存器支持"><a href="#寄存器支持" class="headerlink" title="寄存器支持"></a>寄存器支持</h6><p>页表始地址存放于<strong>页表基址寄存器中</strong>：<strong>页表功能</strong>由一组专门的存储器实现，<strong>较快的完成地址转换</strong></p><p>页表寄存器：<strong>系统中只设置一个页表寄存器</strong>，进程执行时，将页表始地址和页表长度放入页表寄存器</p><h5 id="d-逻辑地址结构"><a href="#d-逻辑地址结构" class="headerlink" title="d. 逻辑地址结构"></a>d. 逻辑地址结构</h5><p><img src="/posts/3792261443/image-20220309191038121.png" alt></p><p>逻辑地址从 <code>#0</code> 开始</p><p>页号：逻辑页号</p><p>页内偏移地址：距离该页始地址的偏移量。由于动态内存分配中，逻辑页面大小=内存块大小，所以页内偏移量与内存块的块内偏移量相等</p><h5 id="e-分页管理的基本地址变换机构"><a href="#e-分页管理的基本地址变换机构" class="headerlink" title="e. 分页管理的基本地址变换机构"></a>e. 分页管理的基本地址变换机构</h5><p><img src="/posts/3792261443/image-20220309194455543.png" alt></p><p>两次访存</p><ol><li>访问页表</li><li>根据物理地址访问数据或指令</li></ol><h5 id="f-具有快表的地址变换机构"><a href="#f-具有快表的地址变换机构" class="headerlink" title="f. 具有快表的地址变换机构"></a>f. 具有快表的地址变换机构</h5><p><img src="/posts/3792261443/image-20220310081424000.png" alt></p><p>快表中存放的是页表的一部分副本</p><p>若快表未命中，则通过访问页表获取该逻辑地址对应的页表项后，要将副本存入快表</p><p>查询快表的速度比查询页表的速度快很多，由于局部性原理，快表的命中率达90%以上。</p><p>如：如访问一次快表耗时 $1\mu s$，访问一次内存耗时 $100\mu s$，快表命中率90%</p><ul><li>未采用快表机制，访问一个逻辑地址需要 $100+100\mu s=200\mu s$</li><li>采用快表机制，访问一个逻辑地址 $(1+100)\times 0.9+(1+100+100)\times 0.1 = 111\mu s$</li><li>若支持快慢表同时查找，访问一个逻辑地址 $(1+100)\times 0.9 + (100+100)\times 0.1=110.9 \mu s$</li></ul><h5 id="g-多级页表映射机构"><a href="#g-多级页表映射机构" class="headerlink" title="g. 多级页表映射机构"></a>g. 多级页表映射机构</h5><h6 id="页表的问题与方案"><a href="#页表的问题与方案" class="headerlink" title="页表的问题与方案"></a>页表的问题与方案</h6><p>问题：页表连续顺序存储，占用空间大。若一次性调入内存，则对页表的访问显然不满足局部性原理</p><p>解决：对页表建立索引表——多级页表</p><ul><li>索引表指示某块页表的始地址，不用把所有页表都调入内存，只将有需要的部分调入</li></ul><p>新问题：几级索引表就会增加几次访存</p><h6 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h6><blockquote><p><strong>各级页表大小不能超过一个页面</strong></p></blockquote><p>如：按字节编制，40位逻辑地址，页面大小4KB，页表项大小4B，采用页式存储，需要几级页表，页面偏移量占几位？</p><p>$2^{页面偏移量位数}=页面大小\Rightarrow 页面偏移量位数=12位$</p><p>页号位数=40-12=28位</p><p>$总页面数=总页表项数=2^{页号位数}=2^{28}$</p><p>$一个页面可存放页表项个数=\frac{页面大小}{页表项大小}=\frac{2^{12}}{2^2}=2^{10}$</p><p>故需要3级页表</p><p><img src="/posts/3792261443/image-20220309204157318.png" alt></p><p>顶级页表最多占一个页面</p><h6 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h6><ol><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB中读出页目录表始地址，再根据一级页号查页目录表，找到下一级页表在内存中的位置</li><li>根据二级页表号查表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ol><p><img src="/posts/3792261443/image-20220309204814804.png" alt></p><p><img src="/posts/3792261443/image-20220309204839560.png" alt></p><h4 id="B-基本分段存储管理"><a href="#B-基本分段存储管理" class="headerlink" title="B. 基本分段存储管理"></a>B. 基本分段存储管理</h4><p>引入目的</p><ul><li>方便编程</li><li>分段保护和共享</li><li>动态增长和链接</li></ul><h5 id="a-基本概念"><a href="#a-基本概念" class="headerlink" title="a. 基本概念"></a>a. 基本概念</h5><blockquote><p>分段：按用户进程中的自然段划分逻辑空间</p></blockquote><ul><li><p><strong>每段的地址空间从 <code>#0</code> 开始</strong>，分配一段连续空间</p></li><li><p>段内地址连续，段间离散</p></li></ul><h5 id="b-分页与分段的对比"><a href="#b-分页与分段的对比" class="headerlink" title="b. 分页与分段的对比"></a>b. 分页与分段的对比</h5><p><img src="/posts/3792261443/image-20220309205448397.png" alt></p><h5 id="c-段表"><a href="#c-段表" class="headerlink" title="c. 段表"></a>c. 段表</h5><blockquote><p>逻辑空间与物理空间的映射表</p></blockquote><p>段表项：<code>&#123;段号|段长|本段在内存中的始地址&#125;</code></p><h5 id="d-逻辑地址的划分"><a href="#d-逻辑地址的划分" class="headerlink" title="d. 逻辑地址的划分"></a>d. 逻辑地址的划分</h5><p>段内地址：长度不定，可以知道每段的最大长度</p><p>段号：通过段号可以知道最多允许有多少个分段</p><h5 id="e-地址映射"><a href="#e-地址映射" class="headerlink" title="e. 地址映射"></a>e. 地址映射</h5><p><img src="/posts/3792261443/image-20220309214629382.png" alt></p><p>物理地址的计算：</p><p>由于每段逻辑地址都是从#0开始，所以段基址向后偏移段内地址，就是物理存储单元</p><p>而页式中，每增加一个页号，地址空间会跳过一个页面空间的大小，所以物理页号需要乘页面大小</p><p>如：</p><p><img src="/posts/3792261443/image-20220309215132634.png" alt></p><p><img src="/posts/3792261443/image-20220309215158600.png" alt></p><h5 id="f-段的共享"><a href="#f-段的共享" class="headerlink" title="f. 段的共享"></a>f. 段的共享</h5><blockquote><p>多个作业段指向共享段的同一块物理空间实现</p><ul><li>共享同一块存储空间，或通过动态链接方式 将所需的程序段映射到相关进程中</li></ul></blockquote><ul><li><p>当一个作业正在从共享段读取时，必须防止另一个作业对共享段的修改</p></li><li><p>只有确保当前共享段没有任何进程使用时，才可释放本段</p></li><li>通过段的共享，可以减少程序段的调入/调出</li></ul><h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>设置共享段表，所有可共享的分段都由共享段表统一管理</p><p><img src="/posts/3792261443/image-20220309220221704.png" alt></p><ul><li>共享进程计数器：当前共享段被几个进程共享</li><li>同一共享段在不同的进程中有不同的段号</li><li>同一共享段只有一个表项</li></ul><h6 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h6><p>对于第一个请求该共享段的进程，系统为该共享段分配一块内存区，将该共享段调入</p><p>同时将该块的始地址填入请求进程的段表</p><p>在共享段表中对相应该表项填写相关信息，并将count置1</p><h6 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h6><p>释放该共享段占用的内存，将count减1</p><ul><li>若count表项变为0，则需要系统回收共享段的物理内存及相关表项</li></ul><h5 id="g-保护"><a href="#g-保护" class="headerlink" title="g. 保护"></a>g. 保护</h5><h6 id="存取控制保护"><a href="#存取控制保护" class="headerlink" title="存取控制保护"></a>存取控制保护</h6><h6 id="地址越界保护"><a href="#地址越界保护" class="headerlink" title="地址越界保护"></a>地址越界保护</h6><p>段寄存器中段表长度&gt;逻辑地址<strong>段号</strong>，发生越界中断</p><p>段表项中的段长&gt; 逻辑地址中的<strong>段内偏移</strong>，发生越界中断</p><h4 id="C-段页管理方式"><a href="#C-段页管理方式" class="headerlink" title="C. 段页管理方式"></a>C. 段页管理方式</h4><blockquote><p>先分段再分页，所以回显访问段表，在访问页表</p></blockquote><ul><li><p>调入调出以页为基本传送单位</p></li><li><p>段长必须是页长的整数倍，段起点必须是某页起点</p></li></ul><h5 id="分段分页优缺点"><a href="#分段分页优缺点" class="headerlink" title="分段分页优缺点"></a>分段分页优缺点</h5><div class="table-container"><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，<strong>不会产生外部碎片，有少量的内部碎片</strong></td><td>不方便按照逻辑对模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>段分界与程序的自然分界对应，具有逻辑独立性<br>便于多道程序共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。<br>另外，<strong>段式管理会产生外部碎片</strong></td></tr><tr><td>段页式管理</td><td>兼具页式和段式内存管理的优点，可以实现共享和保护</td><td>地址映射至少需要两次查表才能访问数据存储单元</td></tr></tbody></table></div><h5 id="段页式地址结构"><a href="#段页式地址结构" class="headerlink" title="段页式地址结构"></a>段页式地址结构</h5><p><code>&#123;段号S|页号P|页内偏移量W&#125;</code></p><h5 id="支持机构"><a href="#支持机构" class="headerlink" title="支持机构"></a>支持机构</h5><h6 id="段表和页表"><a href="#段表和页表" class="headerlink" title="段表和页表"></a>段表和页表</h6><p>一个进程只能有一个段表，可以有多个页表</p><p>段表项：<code>&#123;段号|页表始地址|页表长度&#125;</code></p><p>页表项：<code>&#123;页号|块号&#125;</code></p><h6 id="段表-页表-寄存器"><a href="#段表-页表-寄存器" class="headerlink" title="段表(页表)寄存器"></a>段表(页表)寄存器</h6><blockquote><p>指出段始地址+段表长度</p></blockquote><ul><li>在段表(页表)寻址时，作为重定位寄存器</li><li>判断是否越界，作为界寄存器</li></ul><h5 id="地址映射机制"><a href="#地址映射机制" class="headerlink" title="地址映射机制"></a>地址映射机制</h5><p><img src="/posts/3792261443/image-20220309224302709.png" alt></p><h2 id="3-5-内存空间的扩充"><a href="#3-5-内存空间的扩充" class="headerlink" title="3.5 内存空间的扩充"></a>3.5 内存空间的扩充</h2><blockquote><p>利用虚拟化技术或者自动覆盖技术</p></blockquote><h3 id="3-5-1-覆盖技术"><a href="#3-5-1-覆盖技术" class="headerlink" title="3.5.1 覆盖技术"></a>3.5.1 覆盖技术</h3><blockquote><p>将用户空间划分成一个固定区和若干覆盖区，将活跃部分放入固定区，其余部分按调用关系分段，依次顺序调用</p></blockquote><p>更新只涉及覆盖区，固定去会常驻内存</p><p>特点</p><ul><li>允许部分装入即可运行</li></ul><p>缺点</p><ul><li>同时运行量大于主存容量时，不能运行</li></ul><p><img src="/posts/3792261443/image-20220309225127053.png" alt></p><h3 id="3-5-2-虚存"><a href="#3-5-2-虚存" class="headerlink" title="3.5.2 虚存"></a>3.5.2 虚存</h3><h4 id="A-基本概念"><a href="#A-基本概念" class="headerlink" title="A. 基本概念"></a>A. 基本概念</h4><h5 id="a-传统存储管理方式的缺点"><a href="#a-传统存储管理方式的缺点" class="headerlink" title="a. 传统存储管理方式的缺点"></a>a. 传统存储管理方式的缺点</h5><p>一次性：一个程序相关的进程必须全部装入内存才能运行</p><ul><li>导致大作业无法装入内存</li><li>只有少数作业先运行，导致多道程序度下降</li></ul><p>驻留性：作业装入内存，直至运行结束才会被换出</p><h5 id="b-虚存的概念-amp-引入目的"><a href="#b-虚存的概念-amp-引入目的" class="headerlink" title="b. 虚存的概念&amp;引入目的"></a>b. 虚存的概念&amp;引入目的</h5><blockquote><p>程序不用全部装入即可运行，运行时动态调入数据，内存不够用时，换出数据</p></blockquote><h5 id="c-虚存的特点"><a href="#c-虚存的特点" class="headerlink" title="c. 虚存的特点"></a>c. 虚存的特点</h5><ul><li>多次性：一个作业程序分多次调入内存</li><li>对换性：作业无需常驻内存，允许运行过程中，将作业换入，换出</li><li>虚拟性：从逻辑上扩充内存容量，使用户可使用容量大于实际容量</li></ul><h5 id="e-原理"><a href="#e-原理" class="headerlink" title="e. 原理"></a>e. 原理</h5><h6 id="程序文本-gt-装入内存"><a href="#程序文本-gt-装入内存" class="headerlink" title="程序文本-&gt;装入内存"></a>程序文本-&gt;装入内存</h6><blockquote><p>在物理层面，应用程序员提交的程序和数据在操作系统管理下，先送入磁盘。当需要该作业时，由操作系统将当前运行所需部分调入主存</p></blockquote><h6 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h6><blockquote><p>时间局部性原理：由于程序中循环结构的存在，某条指令被执行后，一段时间又会被执行；某条数据被访问后，一段时间后又被访问</p></blockquote><p>故采用高速缓存层次结构，将最近使用的指令和数据副本保存在高速缓存器(Cache)中</p><blockquote><p>空间局部性原理：指令大部分按顺序存放、顺序执行，所以程序在一段时间内访问的地址集中在一定范围内</p></blockquote><p>故采用较大的高速缓存，将预取机制集成到高速缓存的控制逻辑中</p><blockquote><p>局部性原理的应用：快表；虚存</p></blockquote><h5 id="f-虚存的功能"><a href="#f-虚存的功能" class="headerlink" title="f. 虚存的功能"></a>f. 虚存的功能</h5><ul><li>请求调页/段功能：当要访问的数据不在内存中，操作系统将需要部分所在页/段调入内存</li><li>页面置换功能：操作系统将暂时不用的内容换出到外存</li></ul><h5 id="g-内存管理方式"><a href="#g-内存管理方式" class="headerlink" title="g. 内存管理方式"></a>g. 内存管理方式</h5><blockquote><p>建立在非连续内存分配方式上</p></blockquote><h5 id="h-虚存的硬件支持"><a href="#h-虚存的硬件支持" class="headerlink" title="h. 虚存的硬件支持"></a>h. 虚存的硬件支持</h5><ul><li>一定量的内存和外存</li><li>地址变换机构</li><li>页表机制</li><li>中断机构，产生缺页中断</li></ul><h5 id="i-虚存的技术支持"><a href="#i-虚存的技术支持" class="headerlink" title="i. 虚存的技术支持"></a>i. 虚存的技术支持</h5><h6 id="调入调出"><a href="#调入调出" class="headerlink" title="调入调出"></a>调入调出</h6><p>交换与调入&amp;调出都是在内存与外存间的信息交换</p><p>但交换</p><ul><li>目的是为了提高多道程序度，</li><li>交换的是进程，</li><li>受内存物理容量的限制</li></ul><p>调入调出的</p><ul><li>目的是扩充内存空间，</li><li>调入调出的是页面或分段，</li><li>进程的地址映射不受内存的物理容量限制</li></ul><h6 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h6><blockquote><p>覆盖程序段最大长度受内存容量限制</p></blockquote><p>虚存最大长度不受内存物理容量限制，只受计算机地址结构限制（地址总线个数）</p><h5 id="j-虚存与Cache的异同"><a href="#j-虚存与Cache的异同" class="headerlink" title="j. 虚存与Cache的异同"></a>j. 虚存与Cache的异同</h5><p>相同处</p><ul><li>有容量、速度、价格梯度，提高系统性能</li><li>把数据分为小信息块，作为基本传递单位</li><li>都有地址映射，替换算法，更新策略</li><li>都依据局部性原理，将活跃数据存放在相对高速的部件中</li></ul><p><img src="/posts/3792261443/image-20220310084541231.png" alt></p><h4 id="B-请求分页内存管理"><a href="#B-请求分页内存管理" class="headerlink" title="B. 请求分页内存管理"></a>B. 请求分页内存管理</h4><h5 id="a-基本概念-1"><a href="#a-基本概念-1" class="headerlink" title="a. 基本概念"></a>a. 基本概念</h5><h6 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h6><blockquote><p>一个程序(进程)在逻辑上被分为大小相等的 <strong>页面</strong></p></blockquote><p>分散的存放在主存的物理存储单元</p><h6 id="逻辑地址-虚地址"><a href="#逻辑地址-虚地址" class="headerlink" title="逻辑地址(虚地址)"></a>逻辑地址(虚地址)</h6><blockquote><p><code>&#123;逻辑页号|页内地址&#125;</code></p></blockquote><ul><li>逻辑页号：程序中的逻辑页号数</li><li>页内偏移：距离页面的始地址偏移量</li></ul><blockquote><p>每个程序的逻辑地址从 <code>#0</code> 开始</p></blockquote><h6 id="物理地址-实地址"><a href="#物理地址-实地址" class="headerlink" title="物理地址(实地址)"></a>物理地址(实地址)</h6><blockquote><p><code>实页号|页内地址</code></p></blockquote><h5 id="b-存储空间"><a href="#b-存储空间" class="headerlink" title="b. 存储空间"></a>b. 存储空间</h5><ul><li>主存基本单位为块</li><li>进程基本单位为逻辑页</li></ul><h5 id="c-进程需要的最小物理块数"><a href="#c-进程需要的最小物理块数" class="headerlink" title="c. 进程需要的最小物理块数"></a>c. 进程需要的最小物理块数</h5><p>由执行一条指令所涉及的页面数确定</p><h5 id="d-支持机构"><a href="#d-支持机构" class="headerlink" title="d. 支持机构"></a>d. 支持机构</h5><h6 id="数据与程序的存放需要内存外存支持"><a href="#数据与程序的存放需要内存外存支持" class="headerlink" title="数据与程序的存放需要内存外存支持"></a>数据与程序的存放需要内存外存支持</h6><h6 id="虚地址位数"><a href="#虚地址位数" class="headerlink" title="虚地址位数"></a>虚地址位数</h6><blockquote><p>虚存大小&lt;内存容量+外存容量，虚存的容量变现为虚存地址位数</p></blockquote><h6 id="页表-1"><a href="#页表-1" class="headerlink" title="页表"></a>页表</h6><blockquote><p>存储逻辑页号与主存块号的映射关系</p></blockquote><p>在一个作业获得作业调度后，有了运行可能，则其页表始地址会存在根进程的PCB中，在该进程调度过程中，会将此页表始地址放入页表基址寄存器</p><p><img src="/posts/3792261443/image-20220310091732273.png" alt></p><p>页表项：<code>页号&#123;内存块号|状态位|访问字段|修改位|外存地址&#125;</code></p><ul><li>状态位：是否已调入内存</li><li>访问字段：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择页面换出</li><li>修改位：页面调入内存后是否修改过</li><li>外存地址：页面在外存的存放位置</li></ul><h6 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h6><blockquote><p>映射：将逻辑地址变为物理地址</p></blockquote><hr><blockquote><p>快表(TLB)：块表中存放页表项的副本</p><p>Cache中存储的是主存块的数据副本：加快对数据的访问</p></blockquote><p>减少页表访问带来的访存次数，加快地址变换</p><ul><li>快表存放于Cache中(SRAM)，页表存放于主存中(DRAM)</li><li>快表相联存储器，可以按地址访问</li></ul><hr><p><img src="/posts/3792261443/image-20220310094428470.png" alt></p><h6 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h6><p>一条指令的执行过程可能发生多次缺页中断</p><ul><li>上限：页面访问序列长度</li><li>下限：页数（页面访问序列去重）</li></ul><hr><p>缺页中断属于 <strong>内部中断</strong></p><ul><li><p>内部中断(CPU内)</p><p><strong>故障</strong>：错误条件引起，可被修复</p><p>陷入：主动放弃CPU，系统调用</p><p>终止：不可回复，终止处理程序</p></li><li><p>外部中断(CPU外)</p><p>I/O中断请求</p><p>人工干预</p></li></ul><hr><p>中断过程</p><ul><li><p>进程访问的页不再内存中，产生缺页中断</p></li><li><p>将缺页进程阻塞</p></li><li><p>操作系统缺页中断处理程度将所缺页调入内存</p><p>若内存中没有空闲块，用置换算法换出某页</p><p>若换出页被修改过，将其写回外存</p></li><li><p>恢复现场，将PC指向引起中断的指令，重新执行</p></li><li><p>从TLB中获取的物理地址访存相应页面，获取数据信息或指令</p></li></ul><p>时间计算：一次TLB访问时间+一次内存访问时间+中断处理时间+调入后TLB访问时间+访存取数据或指令</p><h5 id="e-带TLB的访存过程"><a href="#e-带TLB的访存过程" class="headerlink" title="e. 带TLB的访存过程"></a>e. 带TLB的访存过程</h5><p><img src="/posts/3792261443/未命名文件.jpg" alt></p><p>当页表项标记的某一页换出，则TLB中相应项也要删除</p><h5 id="f-页面分配"><a href="#f-页面分配" class="headerlink" title="f. 页面分配"></a>f. 页面分配</h5><h6 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h6><blockquote><p>请求分页存储管理中给进程分配的物理块的集合</p></blockquote><ul><li>在采用了 <strong>虚拟存储技术</strong> 的系统中，驻留集大小一般 <strong>小于</strong> 进程的总大小</li><li>若驻留集太小，会导致缺页频繁，系统花费大量时间处理缺页，造成进程执行时间减少</li><li>若主流级太大，会使多道程序并发度下降，资源利用率降低，所以要选择合适的驻留集大小</li></ul><h6 id="分配方式与置换方式"><a href="#分配方式与置换方式" class="headerlink" title="分配方式与置换方式"></a>分配方式与置换方式</h6><p>固定分配（驻留集大小不变）：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变</p><p>可变分配（驻留集大小可变）：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少</p><hr><p>局部置换：发生缺页时，在自己的驻留集中选择进程置换</p><ul><li>局部置换一定是固定分配，单个进程的驻留集不会发生改变</li></ul><p>全局置换：将操作系统保留的空闲物理块分配给缺页的进程；也可将别的进程持有的物理块置换到外存，在分配给缺页进程</p><ul><li>全局置换可以是可变分配也可以是固定分配</li></ul><hr><p>固定分配局部置换</p><blockquote><p>单个进程物理块不变，从本进程的驻留集置换</p></blockquote><p>缺点：</p><p>难以确定应为每个进程分配的物理块数</p><ul><li>少则缺页频繁</li><li>多则降低多道程序度，系统资源利用率低</li></ul><hr><p>可变分配全局置换</p><blockquote><p>先为每个进程分配一定数量的物理块，操作系统保持一个空闲物理块队列。</p><p>当某进程发生缺页时，从空闲物理块中分配一块给该进程</p><p>若无空闲物理块，则选择一个未锁定的页面换出到外存</p></blockquote><ul><li>换出的页面可能是任何进程，造成缺页率的增加</li></ul><hr><p>可变分配局部置换</p><blockquote><p>刚开始为每个进程分配一定数量的物理块。当进程发生缺页时，只允许从该进程的驻留集中选择一个物理块</p></blockquote><ul><li>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率适当</li><li>如果进程缺页率极地，则适当减少为该进程分配的物理块</li></ul><h5 id="g-页面置换算法"><a href="#g-页面置换算法" class="headerlink" title="g. 页面置换算法"></a>g. 页面置换算法</h5><p>分为局部置换（本进程中的页）和全局置换（系统中的页）</p><script type="math/tex;mode=display">缺页中断次数 \neq 页面置换次数</script><h6 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h6><blockquote><p>将来最长时间不会用</p><p>由于无法预判进程的访问序列，仅具有理论意义</p></blockquote><p><img src="/posts/3792261443/image-20220311085437866.png" alt></p><h6 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h6><blockquote><p>选择调入主存最长时间的页面——队列类算法</p></blockquote><p>若增加页框数，缺页中断次数不一定增加，可能会减少</p><p>可能会产生Belady异常：所分配的物理块数增大而故障不减反增</p><h6 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h6><blockquote><p>每次淘汰的页面是最近最久未访问的页面——堆栈类算法</p></blockquote><p>实现方法：页表中增加 <code>访问位</code> ，记录该页面距离上次访问经历的时间，每当要淘汰一个页面，选择该字段最大的页面</p><p>一个页表项：<code>&#123;页号|内存块号|状态位|访问位|修改位|外存地址&#125;</code></p><p>特点：</p><ul><li><p>算法性能好</p></li><li><p>需要寄存器和栈等硬件支持</p></li><li>需要硬件支持原因：需要对所有的页排序</li><li>当进程的访问序列没有重复时，变为FIFO算法</li></ul><h6 id="时钟置换算法-Clock、NRU"><a href="#时钟置换算法-Clock、NRU" class="headerlink" title="时钟置换算法(Clock、NRU)"></a>时钟置换算法(Clock、NRU)</h6><blockquote><p>将页面设置成循环队列</p></blockquote><p>一个页表项：<code>&#123;页号|内存块号|状态位|访问位|修改位|外存地址&#125;</code></p><p>做法：</p><ul><li><p>页表中增加 <code>访问位</code> ，若某个页面被访问。置1 <code>访问位=1</code></p></li><li><p>当需要淘汰某个页面时，循环扫描各页面</p><p>第一轮淘汰 <code>访问位=0</code> 的，并将扫描过的页面内 <code>访问位=0</code></p><p>若第一轮没选中页面，则进行第二轮扫描</p></li></ul><p>特点</p><ul><li>实现简单</li><li>算法开销小，未考虑页面是否被修改</li></ul><h6 id="改进Clock"><a href="#改进Clock" class="headerlink" title="改进Clock"></a>改进Clock</h6><blockquote><p>在简单Clock基础上，优先淘汰未被修改的页面</p><ul><li>未被修改的页面不需要写回外存，减少IO次数</li></ul></blockquote><p>访问标记</p><div class="table-container"><table><thead><tr><th></th><th>修改位m=0</th><th>修改位m=1</th></tr></thead><tbody><tr><td>访问位u=0</td><td>(0,0)最近未被访问，未被修改</td><td>(0,1)最近没有访问，但修改过</td></tr><tr><td>访问位u=1</td><td>(1,0)最近被访问过，但未修改</td><td>(1,1)最近访问过，且修改过</td></tr></tbody></table></div><p>过程</p><p>将所有可能被置换的页面排成一个循环队列</p><ol><li><p>第一轮：从当前位置开始扫描到第一个 (0,0) 的页面用于置换。——未访问，未修改</p></li><li><p>第二轮：第一轮扫描失败，则查找第一个 (0,1) 的页面置换。——未访问，被修改</p><p>本轮将所有扫描过的页面访问位置0</p></li><li><p>第三轮：查找第一个(0,0) 的页面用于置换。——被访问，未修改</p></li><li><p>第四轮：查找第一个(0,0)的页面用于置换——被访问，被修改</p></li></ol><h5 id="h-调页策略"><a href="#h-调页策略" class="headerlink" title="h. 调页策略"></a>h. 调页策略</h5><h6 id="调页时机"><a href="#调页时机" class="headerlink" title="调页时机"></a>调页时机</h6><p>预调页策略：根据空间局部性原理，一次调入若干相邻页面比调入一个页面更高效</p><ul><li>但如果调入的页面大多没有被访问，则很低效</li><li>主要<strong>用于进程的首次调入</strong>（运行前调入），由程序员指定调入部分</li></ul><hr><p>请求调页策略：进程在运行期间发现缺页，将所缺页面调入（运行时调入）</p><ul><li>每次只能调入一页，而每次调页都需要磁盘的IO操作，造成较大的系统开销</li></ul><h5 id="i-调查出页放哪"><a href="#i-调查出页放哪" class="headerlink" title="i. 调查出页放哪"></a>i. 调查出页放哪</h5><h6 id="系统有足够对换区"><a href="#系统有足够对换区" class="headerlink" title="系统有足够对换区"></a>系统有足够对换区</h6><blockquote><p>页面调入调出在对换区进行</p></blockquote><p>OS将相关文件复制到对换区</p><p><img src="/posts/3792261443/image-20220311093229131.png" alt></p><h6 id="系统缺少对换区"><a href="#系统缺少对换区" class="headerlink" title="系统缺少对换区"></a>系统缺少对换区</h6><blockquote><p>不会被修改的文件直接从文件区调入，不接收换出</p><p>可能被修改的，换出到对换区，从对换区换入</p></blockquote><p><img src="/posts/3792261443/image-20220311093015139.png" alt></p><h6 id="UNIX换页区间"><a href="#UNIX换页区间" class="headerlink" title="UNIX换页区间"></a>UNIX换页区间</h6><p>第一次调入的页面都从外存调入</p><p>曾经运行过但未被换出的页面，存放于对换区</p><h5 id="j-性能分析"><a href="#j-性能分析" class="headerlink" title="j. 性能分析"></a>j. 性能分析</h5><h6 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h6><blockquote><p>访问页面所需的平均时间</p></blockquote><ol><li><p>若访问页面在快表中，则只需访存一次——取数据</p></li><li><p>若产生产生缺页中断</p><p>快表命中率为p，内存读写周期为m，缺页率为f，缺页中断处理时间为t，则有效访问时间为</p><script type="math/tex;mode=display">EAT=p\times m + (1-p-f)\times 2m + f\times(2m+t+m)</script></li></ol><p>缺页中断处理时间</p><ul><li>页面传输时间</li><li>进程现场恢复时间</li><li>仅考虑页面传送时间</li></ul><p>影响缺页率的因素</p><ul><li>分配给进程的物理块</li><li>页面本身大小</li><li>程序编址方法</li><li>页面置换算法</li></ul><h6 id="抖动现象"><a href="#抖动现象" class="headerlink" title="抖动现象"></a>抖动现象</h6><blockquote><p>频繁的页面调入调出行为：刚刚换入的页面马上要换出内存。刚刚换出的页面马上换入内存</p></blockquote><p>主要原因：进程分配到的物理块太少</p><hr><p>驻留集与工作集</p><p>驻留集：请求分页存储管理中给进程分配的内存块的集合</p><ul><li>驻留集不能小于工作集大小，否则会出现抖动现象</li></ul><p>工作集：某段时间间隔里，进程实际访问的页面集合</p><ul><li>工作集可能小于驻留集大小</li><li>OS统计进程的工作集大小，根据工作集，根据工作集大小给进程分配若干物理块</li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/3792261443/" title="3.内存管理">https://amostian.github.io/posts/3792261443/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tags"></i> 计算机基础</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tags"></i> 操作系统</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1989371375/" rel="prev" title="4.网络层"><i class="fa fa-chevron-left"></i> 4.网络层</a></div><div class="post-nav-item"><a href="/posts/3967146657/" rel="next" title="5.传输层">5.传输层 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">3. 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84"><span class="nav-text">3.1.1 存储器的层次化结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E4%B8%BB%E8%A6%81%E6%80%9D%E6%83%B3"><span class="nav-text">a. 主要思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E4%B8%89%E7%BA%A7%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">b. 三级存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache-%E4%B8%BB%E5%AD%98"><span class="nav-text">Cache-主存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98"><span class="nav-text">主存-辅存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-text">3.1.2 内存管理功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">3.1.3 一段代码载入内存的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="nav-text">1. 预处理阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="nav-text">2. 编译阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="nav-text">3. 链接阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="nav-text">静态连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">装入时动态链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">运行时动态链接</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%A3%85%E5%85%A5"><span class="nav-text">4. 装入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="nav-text">绝对装入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5-%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-text">可重定位装入(静态重定位)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A3%85%E5%85%A5-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-text">动态运行时装入(动态重定位)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">装入方式对应的内存分配方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E9%81%93%E6%95%B0"><span class="nav-text">3.1.4 交换技术提高程序道数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="nav-text">a. 调度时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">b. 换入换出的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="nav-text">c. 基本要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-%E7%A9%BA%E9%97%B4%E6%94%AF%E6%8C%81"><span class="nav-text">d. 空间支持</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.2 地址转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-text">3.2.1 物理地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="nav-text">3.2.2 逻辑地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"><span class="nav-text">3.3 存储保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="nav-text">硬件支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">界地址寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8-%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">重定位寄存器(基址寄存器)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-text">3.4 内存分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">3.4.1 连续内存分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-text">a. 单一连续分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81-1"><span class="nav-text">硬件支持</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-text">b. 固定分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">相关数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81-2"><span class="nav-text">硬件支持</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E5%8A%A8%E6%80%81-%E5%8F%AF%E5%8F%98-%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-text">c. 动态(可变)分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-text">相关数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-text">分区分配(分区选择算法)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-text">分区的回收</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">3.4.2 动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">A. 基本分页存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E6%A6%82%E5%BF%B5"><span class="nav-text">a. 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F"><span class="nav-text">页面大小</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E7%89%B9%E7%82%B9"><span class="nav-text">b. 特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E6%94%AF%E6%8C%81%E6%9C%BA%E6%9E%84"><span class="nav-text">c. 支持机构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-text">页表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%94%AF%E6%8C%81"><span class="nav-text">寄存器支持</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-text">d. 逻辑地址结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#e-%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="nav-text">e. 分页管理的基本地址变换机构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#f-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="nav-text">f. 具有快表的地址变换机构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#g-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E6%9C%BA%E6%9E%84"><span class="nav-text">g. 多级页表映射机构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%96%B9%E6%A1%88"><span class="nav-text">页表的问题与方案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-text">地址结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="nav-text">地址变换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">B. 基本分段存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">a. 基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">b. 分页与分段的对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E6%AE%B5%E8%A1%A8"><span class="nav-text">c. 段表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-text">d. 逻辑地址的划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#e-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-text">e. 地址映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#f-%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="nav-text">f. 段的共享</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D"><span class="nav-text">分配</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6"><span class="nav-text">回收</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#g-%E4%BF%9D%E6%8A%A4"><span class="nav-text">g. 保护</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E4%BF%9D%E6%8A%A4"><span class="nav-text">存取控制保护</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%B6%8A%E7%95%8C%E4%BF%9D%E6%8A%A4"><span class="nav-text">地址越界保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%AE%B5%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">C. 段页管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%88%86%E9%A1%B5%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">分段分页优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-text">段页式地址结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E6%9C%BA%E6%9E%84"><span class="nav-text">支持机构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8%E5%92%8C%E9%A1%B5%E8%A1%A8"><span class="nav-text">段表和页表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8-%E9%A1%B5%E8%A1%A8-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">段表(页表)寄存器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-text">地址映射机制</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"><span class="nav-text">3.5 内存空间的扩充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="nav-text">3.5.1 覆盖技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E8%99%9A%E5%AD%98"><span class="nav-text">3.5.2 虚存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">A. 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">a. 传统存储管理方式的缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E8%99%9A%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5-amp-%E5%BC%95%E5%85%A5%E7%9B%AE%E7%9A%84"><span class="nav-text">b. 虚存的概念&amp;引入目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E8%99%9A%E5%AD%98%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">c. 虚存的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#e-%E5%8E%9F%E7%90%86"><span class="nav-text">e. 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%96%87%E6%9C%AC-gt-%E8%A3%85%E5%85%A5%E5%86%85%E5%AD%98"><span class="nav-text">程序文本-&gt;装入内存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-text">局部性原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#f-%E8%99%9A%E5%AD%98%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">f. 虚存的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#g-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">g. 内存管理方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#h-%E8%99%9A%E5%AD%98%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="nav-text">h. 虚存的硬件支持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i-%E8%99%9A%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81"><span class="nav-text">i. 虚存的技术支持</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B0%83%E5%85%A5%E8%B0%83%E5%87%BA"><span class="nav-text">调入调出</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="nav-text">覆盖技术</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#j-%E8%99%9A%E5%AD%98%E4%B8%8ECache%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-text">j. 虚存与Cache的异同</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">B. 请求分页内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">a. 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2"><span class="nav-text">页面</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E8%99%9A%E5%9C%B0%E5%9D%80"><span class="nav-text">逻辑地址(虚地址)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E5%AE%9E%E5%9C%B0%E5%9D%80"><span class="nav-text">物理地址(实地址)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="nav-text">b. 存储空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E7%89%A9%E7%90%86%E5%9D%97%E6%95%B0"><span class="nav-text">c. 进程需要的最小物理块数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-%E6%94%AF%E6%8C%81%E6%9C%BA%E6%9E%84"><span class="nav-text">d. 支持机构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E6%94%BE%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%A4%96%E5%AD%98%E6%94%AF%E6%8C%81"><span class="nav-text">数据与程序的存放需要内存外存支持</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%99%9A%E5%9C%B0%E5%9D%80%E4%BD%8D%E6%95%B0"><span class="nav-text">虚地址位数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8-1"><span class="nav-text">页表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="nav-text">地址变换机构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="nav-text">缺页中断机构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#e-%E5%B8%A6TLB%E7%9A%84%E8%AE%BF%E5%AD%98%E8%BF%87%E7%A8%8B"><span class="nav-text">e. 带TLB的访存过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#f-%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D"><span class="nav-text">f. 页面分配</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86"><span class="nav-text">驻留集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E7%BD%AE%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="nav-text">分配方式与置换方式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#g-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">g. 页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-OPT"><span class="nav-text">最佳置换算法(OPT)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95-FIFO"><span class="nav-text">先进先出算法(FIFO)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-LRU"><span class="nav-text">最近最久未使用算法(LRU)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-Clock%E3%80%81NRU"><span class="nav-text">时钟置换算法(Clock、NRU)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%B9%E8%BF%9BClock"><span class="nav-text">改进Clock</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#h-%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="nav-text">h. 调页策略</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B0%83%E9%A1%B5%E6%97%B6%E6%9C%BA"><span class="nav-text">调页时机</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i-%E8%B0%83%E6%9F%A5%E5%87%BA%E9%A1%B5%E6%94%BE%E5%93%AA"><span class="nav-text">i. 调查出页放哪</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%89%E8%B6%B3%E5%A4%9F%E5%AF%B9%E6%8D%A2%E5%8C%BA"><span class="nav-text">系统有足够对换区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%BC%BA%E5%B0%91%E5%AF%B9%E6%8D%A2%E5%8C%BA"><span class="nav-text">系统缺少对换区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#UNIX%E6%8D%A2%E9%A1%B5%E5%8C%BA%E9%97%B4"><span class="nav-text">UNIX换页区间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#j-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">j. 性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4"><span class="nav-text">有效访问时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E7%8E%B0%E8%B1%A1"><span class="nav-text">抖动现象</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">390</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">61</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">78</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1025.5k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">42:31</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>