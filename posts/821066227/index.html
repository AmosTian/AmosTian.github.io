<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa:300,300italic,400,400italic,700,700italic|Ma Shan Zheng:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"amostian.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="[TOC]  介绍Filebench是文件系统的压测工具，能够生成多种工作负载。它及其灵活，允许使用Workload Model Language(WML)来模拟真实应用对文件系统的I&#x2F;O行为，不仅可以仿真文件系统微操作（如 copyfiles, createfiles, randomread, randomwrite ），而且可以仿真复杂的应用程序（如 varmail, fileserver,"><meta property="og:type" content="article"><meta property="og:title" content="Filebench"><meta property="og:url" content="https://amostian.github.io/posts/821066227/index.html"><meta property="og:site_name" content="AmosTian"><meta property="og:description" content="[TOC]  介绍Filebench是文件系统的压测工具，能够生成多种工作负载。它及其灵活，允许使用Workload Model Language(WML)来模拟真实应用对文件系统的I&#x2F;O行为，不仅可以仿真文件系统微操作（如 copyfiles, createfiles, randomread, randomwrite ），而且可以仿真复杂的应用程序（如 varmail, fileserver,"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://amostian.github.io/posts/821066227/image-20250211100111866.png"><meta property="og:image" content="https://amostian.github.io/posts/821066227/image-20250211144915378.png"><meta property="og:image" content="https://amostian.github.io/posts/821066227/image-20250211145102390.png"><meta property="og:image" content="https://amostian.github.io/posts/821066227/image-20250211145220093.png"><meta property="article:published_time" content="2025-02-25T01:41:50.000Z"><meta property="article:modified_time" content="2025-02-27T02:15:32.519Z"><meta property="article:author" content="AmosTian"><meta property="article:tag" content="存储"><meta property="article:tag" content="分布式存储"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://amostian.github.io/posts/821066227/image-20250211100111866.png"><link rel="canonical" href="https://amostian.github.io/posts/821066227/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Filebench | AmosTian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">AmosTian</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">66</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">83</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">224</span></a></li><li class="menu-item menu-item-essay"><a href="/categories/%E9%9A%8F%E7%AC%94/" rel="section"><i class="fa fa-fw fa-pied-piper"></i>随笔</a></li><li class="menu-item menu-item-dynamic-resume"><a href="/dynamic-resume/" rel="section"><i class="fa fa-fw fa-cog"></i>动态简历</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AmosTian" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://amostian.github.io/posts/821066227/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="AmosTian"><meta itemprop="description" content="知道的越多，不知道的越多"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AmosTian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Filebench</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间 2025-02-25 09:41:50" itemprop="dateCreated datePublished" datetime="2025-02-25T09:41:50+08:00">2025-02-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间 2025-02-27 10:15:32" itemprop="dateModified" datetime="2025-02-27T10:15:32+08:00">2025-02-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">存储</span></a> </span>> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数 </span><span title="本文字数">12.3k字 </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>[TOC]</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Filebench是文件系统的压测工具，能够生成多种工作负载。它及其灵活，允许使用Workload Model Language(WML)来模拟真实应用对文件系统的I/O行为，不仅可以仿真文件系统微操作（如 copyfiles, createfiles, randomread, randomwrite ），而且可以仿真复杂的应用程序（如 varmail, fileserver, oltp, dss, webserver, webproxy ）。</p><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p>文件总大小相同，看带宽</p><p>文件总数量相同，看IOPS</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Filebench包括许多功能，便于文件系统基准测试：</p><ul><li>提供了40多个预定义的个性，包括描述邮件、web、文件和数据库服务器行为的个性</li><li>使用reach Workload Model Language （WML）可以轻松添加新的个性</li><li>多进程和多线程工作负载支持</li><li>可配置的目录层次结构，深度、宽度和文件大小设置为给定的统计分布</li><li>支持异步I/O和进程同步原语</li><li>吞吐量和延迟分布测量</li><li>适用于任何兼容posix的操作系统（Linux、FreeBSD、Solaris）</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>Step 1：生成负载配置文件</strong></p><p>Filebench的负载配置文件使用WML创建负载描述，保存在以 .f 为后缀的文件中</p><p>示例中，描述一个简单的负载：2个进程，每个进程有3个线程，每个线程循环执行操作（选择一个文件，读文件，关闭文件）</p><p><img src="/posts/821066227/image-20250211100111866.png" alt="image-20250211100111866"></p><p>Filebench中四个主要的条目是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第1行：定义了一个文件集，在/tmp目录中，包含10000个16KiB的文件，在执行实际工作负载前预先创建文件集中的所有文件</span><br><span class="line">第3,4行：定义两个进程，每个进程包含3个线程。每个线程会循环执行其中定义的flowops(不同类型的操作)</span><br><span class="line">第5-7行：描述了每个线程内的flowops（从fileset中打开一个文件，将文件内容完整读入内存，然后关闭）</span><br><span class="line">第11行：指出负载运行60s</span><br></pre></td></tr></table></figure><p><strong>Step 2: 禁用进程地址空间随机化</strong></p><p>启用终端命令行运行以下命令： <code>sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code></p><p><strong>Step 3：执行</strong></p><p>假设上述负载配置文件命名为 <code>readfiles.f</code> ，可以通过指令 <code>filebench -f readfiles.f</code> 生成相应的负载</p><hr><p>每个flowop都会有一个类型，Filbench将操作类型分为以下几类：</p><ul><li><strong>I/O</strong>: <code>write</code>, <code>read</code>, <code>openfile</code>, <code>createfile</code>, <code>closefile</code>, <code>makedir</code>, <code>removedir</code>, <code>listdir</code>, <code>fsync</code>, <code>fsyncset</code>, <code>statfile</code>, <code>readwholefile</code>, <code>appendfile</code>, <code>appendfilerand</code>, <code>deletefile</code>, <code>writewholefile</code>;</li><li><strong>Async I/O</strong>: <code>aiowrite</code>, <code>aiowait</code>;</li><li><strong>Events</strong>: <code>block</code>, <code>wakeup</code>, <code>semblock</code>, <code>sempost</code>;</li><li><strong>Composite</strong>: (XXX: link to the composite flowops description);</li><li><strong>Other</strong>: <code>hog</code>, <code>delay</code>, <code>eventlimit</code>, <code>bwlimit</code>, <code>iopslimit</code>, <code>opslimit</code>, <code>finishoncount</code>, <code>finishonbytes</code>;</li></ul><p>每个flowop实例有多种属性，write、writewholefile、appendfile 和 appendfilerand 类型的 Flowop 实例标有 WRITE 属性，而 read 和 readwholefile 实例标有 READ 属性。其他flowop类型不包含 READ和WRITE属性</p><blockquote><p>在更复杂的负载场景，我们能使用一系列flowops和属性，来定义更多的filesets、多种进程和线程的组合</p><p>完整的WML描述<a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language">https://github.com/filebench/filebench/wiki/Workload-model-language</a></p></blockquote><h3 id="宏负载"><a href="#宏负载" class="headerlink" title="宏负载"></a>宏负载</h3><p>Filebench预定义了许多宏和宏负载（WebServer，FileServer，mailserver），同样也是WML描述。</p><blockquote><p>源码中在 <em>workloads/</em> 目录下，安装完成后在 <em>/usr/local/share/filebench/workloads/</em> 下</p></blockquote><p>不建议直接使用这些负载，因为文件大小与实际的系统可能不匹配，如：webserver中，负载仅略大于16MiB，可能不是待测的GB级负载</p><p>因此，建议复制后修改，</p><p><code>cp /usr/local/share/filebench/workloads/webserver.f mywebserver.f</code></p><p>然后编辑复制的文件，通过将文件数量（文件集的“entries”属性）设置为适当的值来增加数据集大小。最后，运行工作负载：</p><blockquote><p>有关如何扩展 Filebench 工作负载的详细讨论，请参阅<a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Scaling-Filebench-workloads">https://github.com/filebench/filebench/wiki/Scaling-Filebench-workloads</a></p></blockquote><ul><li><a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/login/articles/login_spring16_02_tarasov.pdf">Filebench: A Flexible Framework for File System Benchmarking</a> article in ;login; magazine, Spring 2016, Vol. 41, No. 1 is a gentle but sufficiently detailed introduction to Filebench.</li></ul><h2 id="指标采集"><a href="#指标采集" class="headerlink" title="指标采集"></a>指标采集</h2><p>在基准测试执行期间，Filebench 的配置文件中定义的每个 flowop，都对应多个正在运行的线程。例如，在以下工作负载中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define process name=&quot;readerP&quot;,instances=2 &#123;</span><br><span class="line">  thread name=&quot;readerT&quot;,instances=3 &#123;</span><br><span class="line">    flowop openfile name=&quot;openOP&quot;,filesetname=&quot;testF&quot;</span><br><span class="line">    flowop readwholefile name=&quot;readOP&quot;,filesetname=&quot;testF&quot;</span><br><span class="line">    flowop closefile name=&quot;closeOP&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 openOP，readOP，closeOP都有6个运行中线程（2进程*3线程）。</p><h3 id="统计指标"><a href="#统计指标" class="headerlink" title="统计指标"></a>统计指标</h3><p>在运行时，Filebench为每个正在运行的Flowop采集多个指标，这样做是为了避免多个线程更新同一指标并因此需要同步锁的情况。每个flowop实例收集一下指标：</p><ul><li><p>当前flowop实例的执行时长 <code>fs_count</code></p></li><li><p>read-操作数，只要是 <code>READ</code> 标记的flowop都会被统计——<code>fs_rcount</code></p></li><li><p>write-操作数，只要是 <code>WRITE</code> 标记的flowop都会被统计——<code>fs_wcount</code></p></li><li><p>flowop实例读取和写入的字节数——<code>fs_bytes</code></p></li><li><p>read-操作的字节数——<code>fs_rbytes</code></p></li><li><p>write-操作的字节数——<code>fs_wbytes</code></p></li><li><p>以纳秒为单位的flowop总累计延迟——<code>fs_total_lat</code></p><p>在flowop执行之前和执行后记录时间戳，将差值累加到 <code>fs_total_lat</code> 指标。</p></li><li><p>flowop的最大时延——<code>fs_maxlat</code></p></li><li><p>flowop的最小时延——<code>fs_minlat</code></p></li></ul><h3 id="启动指令"><a href="#启动指令" class="headerlink" title="启动指令"></a>启动指令</h3><p>fliebench可通过3种指令启动：</p><ul><li><code>run [runtime]</code> ：运行工作负载 runtime 秒。如果未指定运行时间且 Filebench 在超时模式下运行，则运行时间设置为 60 秒。性能指标在执行结束时仅打印一次。</li><li><code>psrun [period] [runtime]</code> ：运行工作负载 runtime 秒，每 [period] 秒打印一次指标。指标在运行期间不会重置，因此会随着时间的推移而累积。</li><li><code>psrun -[period] [runtime]</code> ：运行工作负载 runtime 秒，打印指标并每 [period] 秒重置一次。因此，打印的指标仅代表最后 [period] 秒。</li></ul><h3 id="输出解释"><a href="#输出解释" class="headerlink" title="输出解释"></a>输出解释</h3><p>在这种情况下，每个 flowop 实例的指标在整个运行过程中都会收集，永远不会重置，并且仅在运行结束时打印一次（以聚合形式）。fileserver负载的输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">01| 61.853: Run took 60 seconds...</span><br><span class="line">02| 61.855: Per-Operation Breakdown</span><br><span class="line">03| statfile1            403700ops     6728ops/s   0.0mb/s    0.002ms/op [0.001ms - 2.320ms]</span><br><span class="line">04| deletefile1          403700ops     6728ops/s   0.0mb/s    0.866ms/op [0.021ms - 244.148ms]</span><br><span class="line">05| closefile3           403702ops     6728ops/s   0.0mb/s    0.664ms/op [0.001ms - 10.680ms]</span><br><span class="line">06| readfile1            403705ops     6728ops/s 888.0mb/s    0.041ms/op [0.001ms - 7.077ms]</span><br><span class="line">07| openfile2            403706ops     6728ops/s   0.0mb/s    1.238ms/op [0.005ms - 19.114ms]</span><br><span class="line">08| closefile2           403715ops     6728ops/s   0.0mb/s    0.585ms/op [0.001ms - 13.162ms]</span><br><span class="line">09| appendfilerand1      403723ops     6728ops/s  52.5mb/s    0.605ms/op [0.000ms - 10.248ms]</span><br><span class="line">10| openfile1            403728ops     6728ops/s   0.0mb/s    1.210ms/op [0.007ms - 16.119ms]</span><br><span class="line">11| closefile1           403738ops     6729ops/s   0.0mb/s    0.636ms/op [0.001ms - 13.222ms]</span><br><span class="line">12| wrtfile1             403745ops     6729ops/s 834.3mb/s    0.808ms/op [0.012ms - 16.785ms]</span><br><span class="line">13| createfile1          403748ops     6729ops/s   0.0mb/s    0.754ms/op [0.012ms - 16.790ms]</span><br><span class="line">14| 61.855: IO Summary: 4440910 ops 74010.535 ops/s 6728/13457 rd/wr 1774.9mb/s 0.673ms/op</span><br><span class="line">15| 61.855: Shutting down processes</span><br></pre></td></tr></table></figure><p>尽管配置了50个线程（为每个flowop创建50个flowop实例），但不会为每个flowop打印50行。相反，将每个flowop实例指标聚合到输出中的每个flowop中，如：<code>readfile1</code> flowop跨50个线程的总数是403 728。</p><ul><li>第一列：flowop名</li><li>第二列：所有线程中flowop的执行总数 fs_count的和，不同flowop间数字略有差异，因为不同的线程在运行结束时在不同的flowop处停止执行</li><li>第三列：每秒操作数，=将所有线程中的流操作执行总数（第1列）除以压测运行的持续时间</li><li>第四列：flowop的平均吞吐量（MB/S）。仅统计含 <code>READ</code> 和 <code>WRITE</code> 属性的值。=字节数 <code>fs_bytes</code> 除以压测时长</li><li>第五列：flowop执行的平均延迟。=总flowop执行时长/flowop总数。fs_total_lat/fs_count</li><li>第六列：方括号中的数字表示所有线程中 flowop 的所有执行中的最大延迟（fs_maxlat）和最小延迟（fs_minlat）。</li></ul><h4 id="I-O-Summary"><a href="#I-O-Summary" class="headerlink" title="I/O Summary"></a>I/O Summary</h4><p>仅包含I/O和异步I/O操作的总结</p><ul><li><p><code>4,440,910 ops</code>：是所有I/O和异步I/O flowop操作的总和。在文件服务器中，所有流操作都属于I/O类别，因此是第一列的总和</p></li><li><p><code>74,010.535 ops/s</code>：是所有操作的IOPS，将所有I/O类型操作总数/运行时间</p></li><li><p><code>6728/13457 rd/wr</code>：是I/O和异步I/O类别中，含READ/WRITE标记的op次数除以总时长</p><p>在这个例子中，readfile1 是唯一的 READ 标记的 flowop (6,728 = 40,370 / 60)，而 appendfilerand1 和 wrtfile1 是 WRITE 标记的 flowops (13,457 = (403,723 + 403,745) / 60)。</p></li><li><p><code>1774.9mb/sec</code>：是所有 I/O 和异步 I/O 流操作的总吞吐量（以兆字节/秒为单位）。含READ/WRITE标记的op读取/写入的总字节数（fs_bytes）除以总时长。</p><p>该指标等于第 03-13 行吞吐量字段的总和：888.0 + 52.5 + 834.3 = 1774.9mb/s。</p></li><li><p><code>0.673mb/op</code> 是I/O和异步I/O流操作的平均延迟，计算方式将 I/O总时延与op数 加权均值 fs_count</p><p>在此示例中，由于所有 flowops 的执行次数几乎相同，因此指标大致等于各个 flowops 的平均延迟：</p><p>(0.002+0.866+0.664+0.041+1.238+0.585+0.605+1.210+0.636+0.808+0.754) / 11 = 0.673ms/op</p></li></ul><p><strong>filemicro_writefsync</strong> 具体来说，filemicro_writefsync 是一个单线程工作负载，它以 8KB I/O 大小为单位顺序写入单个文件，直到文件达到 1GB 大小。每 1024 次写入（8MB），线程就会将文件同步到磁盘。以下是示例输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">9.009: Run took 8 seconds...</span><br><span class="line">9.009: Per-Operation Breakdown</span><br><span class="line">finish               128ops       16ops/s   0.0mb/s    0.000ms/op [0.000ms - 0.001ms]</span><br><span class="line">sync-file            128ops       16ops/s   0.0mb/s   33.065ms/op [21.598ms - 221.742ms]</span><br><span class="line">append-file          131073ops    16382ops/s 128.0mb/s    0.021ms/op [0.004ms - 8.966ms]</span><br><span class="line">9.009: IO Summary: 131201 ops 16397.770 ops/s 0/16382 rd/wr 128.0mb/s 0.053ms/op</span><br><span class="line">9.009: Shutting down processes</span><br></pre></td></tr></table></figure><p>So, <code>33.065ms/op</code> is the average of latencies of <code>131201</code> <code>append-file</code> and <code>128</code> <code>sync-file</code> operation - (131,201 <em>0.021 + 128 </em>33.065) / (131,201 + 128) = 0.053ms/op)</p><h2 id="文件大小分布"><a href="#文件大小分布" class="headerlink" title="文件大小分布"></a>文件大小分布</h2><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Custom-variables">https://github.com/filebench/filebench/wiki/Custom-variables</a></p><p>在 1.5 版本之前，Filebench 实现了随机变量的概念。仅支持三种随机变量分布：均匀、伽马和表格。要向 Filebench 添加新的发行版，用户必须修改 WML 语法和 Filebench 内部结构</p><p>Filebench 自定义变量（从 1.5 版开始支持）旨在简化向 Filebench 添加新分布的过程。每个自定义变量分布都在单独的动态加载库中实现。要添加新分布，用户只需实现一个由 2 到 8 个函数组成的定义良好的接口。</p><h3 id="支持的随机变量"><a href="#支持的随机变量" class="headerlink" title="支持的随机变量"></a>支持的随机变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">filebench -c</span></span><br><span class="line">0.000: Allocated 173MB of shared memory</span><br><span class="line">Custom variable types supported:</span><br><span class="line">  cvar-gamma</span><br><span class="line">  cvar-erlang</span><br><span class="line">  cvar-weibull</span><br><span class="line">  cvar-lognormal</span><br><span class="line">  cvar-exponential</span><br><span class="line">  cvar-normal</span><br><span class="line">  cvar-triangular</span><br><span class="line">  cvar-uniform</span><br></pre></td></tr></table></figure><p>列出特定自定义变量类型的版本和参数（及其默认值）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">filebench -c cvar-gamma</span></span><br><span class="line">0.000: Allocated 173MB of shared memory</span><br><span class="line">Custom variable type: cvar-gamma</span><br><span class="line">Supporting library: /usr/local/lib/filebench/libcvar-gamma.so</span><br><span class="line">Version: 0.1.1 (alpha)</span><br><span class="line">Usage:</span><br><span class="line">	parameter	default</span><br><span class="line">	---------	-------</span><br><span class="line">	mean		4096.0</span><br><span class="line">	gamma		1.5</span><br><span class="line">Use &#x27;;&#x27; to delimit parameters and &#x27;:&#x27; to delimit key-value pairs.</span><br><span class="line">Example: &#x27;mean:4096.0;gamma:1.5&#x27;</span><br></pre></td></tr></table></figure><h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><script type="math/tex;mode=display">f(x;a,b)=\frac{1}{b-a}\\
F(x;a,b)=\frac{x-a}{b-a}\\
E[a,b]=\frac{b-a}{2}</script><p><img src="/posts/821066227/image-20250211144915378.png" alt="image-20250211144915378"></p><h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><script type="math/tex;mode=display">f(x;\lambda)=\lambda e^{-\lambda x}\\
F(x;\lambda)=1-e^{-\lambda x}\\
E(\lambda)=\frac{1}{\lambda}</script><p><img src="/posts/821066227/image-20250211145102390.png" alt="image-20250211145102390"></p><h4 id="gamma分布"><a href="#gamma分布" class="headerlink" title="gamma分布"></a>gamma分布</h4><p><img src="/posts/821066227/image-20250211145220093.png" alt="image-20250211145220093"></p><h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><h4 id="log-正态分布"><a href="#log-正态分布" class="headerlink" title="log-正态分布"></a>log-正态分布</h4><h2 id="定制预定义负载"><a href="#定制预定义负载" class="headerlink" title="定制预定义负载"></a>定制预定义负载</h2><p>定制工作负载定义了要应用于系统的工作负载。定制内容通常包括 <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Scaling-workload-personalities">scaling workloads for specific systems</a>的可调参数。在加载个性化设置后，可将可调参数设置为适当的值。定制化配置存储在扩展名为 .f 的文件中，可以从 Filebench 命令行界面或通过编辑文件本身（或文件副本）轻松进行定制。Filebench负载一个预定义工作负载库，如表所示</p><div class="table-container"><table><thead><tr><th>Micro-workload</th><th></th></tr></thead><tbody><tr><td>Personality</td><td>Description</td></tr><tr><td><code>singlestreamread</code></td><td>顺序读大文件（默认5GB，1MB块大小）</td></tr><tr><td><code>singlestreamreaddirect</code></td><td>与 <code>singlestreamread</code> 想通，但使用 direct I/O</td></tr><tr><td><code>fivestreamread</code></td><td>顺序读5个大文件（1GB）每个线程执行1个读操作（块大小为1MB）</td></tr><tr><td><code>fivestreamreaddirect</code></td><td>与 <code>5streamread</code>相同，direct I/O</td></tr><tr><td><code>singlestreamwrite</code></td><td>顺序写文件，一直持续到压测停止，默认写1MB块大小</td></tr><tr><td><code>singlestreamwritedirect</code></td><td>与 <code>singlestreamwrite</code> 相同， direct I/O</td></tr><tr><td><code>fivestreamwrite</code></td><td>顺序读5个大文件（1GB）每个线程执行1个读操作（块大小为1MB），直至压测停止</td></tr><tr><td><code>fivestreamwritedirect</code></td><td>与 <code>5streamwrite</code> 相同，direct I/O</td></tr><tr><td><code>randomread</code></td><td>随机读一个大文件（默认5GB/8KB），默认单线程，由 <code>nthreads</code> 调整；默认非direct I/O，由 <code>directio</code> 调整</td></tr><tr><td><code>randomwrite</code></td><td>随机写一个大文件（5GB/8KB），文件在压测开始就被预分配，默认单线程8KB</td></tr><tr><td><code>randomrw</code></td><td>两个线程，操作同样大小的文件（5GB/8KiB）。一个线程随机读，另一个随机写。压测开始预分配文件。</td></tr><tr><td><code>createfiles</code></td><td>在目录中创建50000个文件。文件大小服从gamma分布，$size\sim\gamma(16K,1.5)$。默认16个线程，可调整，当所有文件创建完成后结束</td></tr><tr><td><code>copyfiles</code></td><td>将文件从源目录复制到目标目录。预先创建源路径（1000个文件）。单线程。复制完成后停止。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Application emulations</th><th></th><th></th></tr></thead><tbody><tr><td>Personality</td><td>Description</td><td></td></tr><tr><td><code>webserver</code></td><td>模拟简单的web-server的I/O行为。Web服务器接受并处理网站的静态资源，将响应结果以文件形式返回，同时将本次请求记录到日志文件。</td><td>默认100线程，每线程依次对10个文件进行“打开-完全读取-关闭”操作流，最后对日志文件执行追加写行为。两种文件大小均值为16KB，压测前生成完整文件。</td></tr><tr><td><code>fileserver</code></td><td>模拟file-server的I/O行为。类似于SPECsfs</td><td>默认50线程，每线程执行文件创建、写入、关闭、打开、随机追加写、读取、元数据查看和删除操作。文件大小均值128KB，预分配80%，压测过程中存在新写入/创建文件</td></tr><tr><td><code>varmail</code></td><td>模拟简单邮件服务器的I/O行为，每个邮件存储为一个单独的文件。与postmark类似。收到邮件后，执行文件的创建、写入和fsync落盘；读取邮件时，执行文件打开、读取、标记已读、fsync落盘</td><td>工作负载由一组多线程的文件操作组成（create-append-sync, read-append-sync, read and delete），这些操作在一个单独的目录中。默认使用16个线程。<br>负载的workflow为：<br>- 删除文件（模拟删除邮件/预留一个创建文件的空位）<br>- 创建邮件文件，写入邮件数据，落盘后关闭文件<br>- 打开一个未读邮件，读取内容后追加写入已读mark，落盘后关闭<br>- 读取一个已读文件，读取内容后关闭</td></tr><tr><td><code>webproxy</code></td><td>模拟Web代理服务器的I/O行为，用户通过代理服务器访问网站，代理服务器会将网站的内容缓存到本地，当用户再次访问时，代理服务器会直接返回缓存的内容。</td><td>在一个目录树中的多个文件操作，包括 “create-write-close, open-read-close,delete”，以及模拟代理日志文件的追加写。该负载预先分配80%的缓存文件，使用100个线程操作10000个文件。<br>- 删除文件（预留一个创建文件的空位）<br>- 读取一个已经缓存的文件（重复5次）<br>该负载还通过opslimit来限制短时间内的操作次数，避免负载过早结束，同时还可以控制系统的资源。</td></tr><tr><td><code>videoserver</code></td><td>模拟视频服务器的I/O行为。两个文件集 active视频集(正在播放的文件)与inactive视频集(可用但未播放的文件)。</td><td>两个线程，48个vidreaders 线程模拟对active集中视频文件的读取操作；1个vidwriter线程服务于inactive集，将新视频文件写入inactive集，替换不再被观看的文件。eventrate参数限制读取线程的读取速率，计算公式为nthreads*Rate，这里的Rate就是每个线程读取的带宽大小，为2mb/s。视频文件替换间隔为10s。paralloc是通过多线程（32个）预分配文件，因为预分配的文件较大，需要提高效率。</td></tr><tr><td><code>oltp</code></td><td>数据库模拟器。使用Oracle 9i I/O模型执行文件系统操作。测试小文件随机读写性能，并对中等大小的日志文件（128K）同步写入的延迟敏感。默认启动200个reader进程，10个异步写入进程和一个日志写入进程。模拟Oracle、Sysbase等的ISM共享内存<br>通过对日志文件和数据文件的操作，模拟了数据库OLTP事务的处理过程。对日志文件写入和数据文件读写操作采用随机I/O方式，通过信号量机制控制线程间的同步。</td><td>日志文件写入线程(lgwr)：<br>- 异步写入（iosize=256K,filesize=10MB），directio和同步写<br>-等待：aiowait<br>-信号量操作：semblock-lg阻塞线程，等待shadow线程的sempost-lg信号量<br>数据文件写入线程(dbwr)：<br>-异步写入(filesize=10MB,iosize=2KB)，随机写，directio和同步写<br>-hog：模拟写入操作完成后线程对 CPU 的占用<br>-信号量：semblock-dbwr<br>aiowait<br>数据读线程(shadow)：<br>-读：随机读,direction<br><br>-hog：模拟数据库读取线程在处理数据时对 CPU 的占用<br>-信号量操作：sempost-dbwr,sempost-lg<br>-eventlimit：限流</td></tr></tbody></table></div><h3 id="oltp"><a href="#oltp" class="headerlink" title="oltp"></a>oltp</h3><p><a target="_blank" rel="noopener" href="https://www.xnip.cn/ruanjian/anli/103119.html">https://www.xnip.cn/ruanjian/anli/103119.html</a></p><p>oltp.F工作负载定义了两个文件集：datafiles和 logfile 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Define a datafile and logfile</span></span><br><span class="line">define fileset name=datafiles,path=$dir,size=$filesize,entries=$nfiles,dirwidth=1024,prealloc=100,reuse</span><br><span class="line">define fileset name=logfile,path=$dir,size=$logfilesize,entries=$nlogfiles,dirwidth=1024,prealloc=100,reuse</span><br></pre></td></tr></table></figure><p>定义了三种进程：日志写入进程(“ ‘lgwr “ ‘)、数据库写入进程(“ ‘dbwr “ ‘)和数据库读取进程(“ ‘shadow “ ‘)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Define database writer processes</span></span><br><span class="line">define process name=dbwr,instances=$ndbwriters</span><br><span class="line">&#123;</span><br><span class="line">  thread name=dbwr,memsize=$memperthread,useism</span><br><span class="line">  &#123;</span><br><span class="line">    flowop aiowrite name=dbwrite-a,filesetname=datafiles, iosize=$iosize,workingset=$workingset,random,iters=100,opennext,directio=$directio,dsync</span><br><span class="line">    flowop hog name=dbwr-hog,value=10000</span><br><span class="line">    flowop semblock name=dbwr-block,value=1000,highwater=2000</span><br><span class="line">    flowop aiowait name=dbwr-aiowait</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">hog 指令用于模拟线程对 CPU 和内存资源的占用。具体来说，hog 指令可以让线程执行一定数量的内存拷贝操作，从而模拟真实应用程序中线程对 CPU 和内存的消耗情况</span><br></pre></td></tr></table></figure><ul><li><p>“ dbwr “进程和线程通过” aiowrite “和” aiowait “ “ flowops “演示了异步写入的使用，通过” hog “ “ flowop “演示了cpu周期消耗，通过” semblock “ “ flowop “演示了信号量操作。</p><ul><li>“aiowrite”流获得与其他读写操作相同的属性，将向文件系统发出异步写，然后继续到下一个流，即“hog”流。</li><li>“hog”流为“value”迭代执行字节写循环，因此每次调用消耗大约固定数量的cpu周期。</li><li>其后是“semblock”流，它通过阻塞其信号量来同步“dbwr”线程和“shadow”线程，直到“shadow”线程中的“sempost”流发出足够多的消息。</li><li>当线程的flowop继续执行时，它将调用” ‘aiowait’’ flowop，它将暂停，直到一个或多个未完成的异步写操作完成。通过使用“aiowrite”和“aiowait”操作，工作负载模型模拟了典型oltp软件中发生的I/O与cpu处理的重叠。如果I/O快速完成，循环的进程将受到“hog”和“semblock”的flowops的限制，而如果I/O很慢，“aiowait”的flowop将限制循环的进程。</li></ul></li><li><p>shadow”进程和线程则使用“opennext”属性在文件集中循环，并使用“sempost”流程进行信号量操作的其他方面。</p><p>虽然每个“shadow”进程只有一个线程实例，但在默认配置中有200个进程实例，因此总共有200个线程。</p><ul><li><p>第一个流是“read”，然后是一个“hog”流，两个“sempost”流和一个“eventlimit”流。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;sempost flowop&#x27;</span>：</span><br><span class="line">	- value 每个post添加到信号量计数的数量，在这个工作负载中，两者都被设置为1。</span><br><span class="line">	- target 这篇文章将作用于其信号量的semblock流的名称。</span><br><span class="line">		一个流以lgwr中的semblock流为目标，命名为lgwr-block，</span><br><span class="line">		另一个流以dbwr中的semblock流为目标，命名为dbwr-block</span><br><span class="line">	- blocking 当指定时，表示包含该sempost流的线程必须阻塞，如果它比包含目标semblock流的线程超前太多的话。</span><br></pre></td></tr></table></figure></li><li><p>“shadow”线程的流列表的最大执行速率受到“eventlimit”流的限制，类似于随机读工作负载的最大执行速率。</p><p>只有一个源的事件,所以每个200影子进程的线程共享一个事件生成器,平均将为1/200的指定利率循环,当然,仍然导致了每秒循环总数等于事件生成器。另外，“read”、“hog”和“sempost”流可能会进一步限制执行速度。例如，如果“读”“流访问延迟”和“猪”“流cpu延迟”的组合超过事件周期的200倍，它们将成为限制因素。正如下面将要描述的，“sempost”flowops还可以限制“阴影”线程的执行速度。</p></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define process name=shadow,instances=$nshadows</span><br><span class="line">&#123;</span><br><span class="line">  thread name=shadow,memsize=$memperthread,useism</span><br><span class="line">  &#123;</span><br><span class="line">    flowop read name=shadowread,filesetname=datafiles,</span><br><span class="line">      iosize=$iosize,workingset=$workingset,random,opennext,directio=$directio</span><br><span class="line">    flowop hog name=shadowhog,value=$usermode</span><br><span class="line">    flowop sempost name=shadow-post-lg,value=1,target=lg-block,blocking</span><br><span class="line">    flowop sempost name=shadow-post-dbwr,value=1,target=dbwr-block,blocking</span><br><span class="line">    flowop eventlimit name=random-rate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在oltp. f在工作负载下，计数信号量用于将两个写进程的执行速率限制为读进程速率的特定分数。这是通过在每个操作中对信号量进行加减的值进行适当设置来实现的。“影子”线程中的“sempost”和“flowops”都会在每次调用时为各自的计数信号量增加1，这意味着每秒钟增加的总数等于事件生成器的速率。更有趣的是，通过在其他两个线程中每次调用“semblock”从信号量中减去的量。“lgwr”线程中的“semblock”将会阻塞，除非信号量计数至少为3200，此时它会减去3200并继续。类似地，“dbwr”线程中的“semblock”将阻塞，除非信号量计数至少为1000，此时它将继续，但减去1000。总的效果是，“lgwr”每3200经过“shadow”一次通过它的流列表，而“dbwr”每1000经过“shadow”一次通过。<br>虽然信号量通常被认为是一种防止落后进程超过领先进程的机制(例如，消费者超过生产者)，FileBench信号量flowops还可以防止领先进程超过落后进程太远。这是通过在内部创建第二个操作系统信号量来完成的，它的计数被初始化为“highwater”值，并且它的post和block操作被交换，因此“sempost”实际上对第二个信号量执行一个block操作，而它的“semblock”实际上执行一个post操作。因此，如果信号量的计数小于“sempost”属性的值，“sempost”流程将阻塞前导进程，并且“semblock”流程将在每次执行时将其值提交给计数。因为sempost flowops配置与价值观之一,1000年的“水位最高点”设置为“lgwr”将允许阴影得到1000 flowop循环迭代之前阻止之前,和“水位最高点”设置为“2000”dbwr影子可以得到2000 flowop循环迭代之前提前阻止。因此，通过一组flowops，工作负载语言能够建模通常的情况，即由于其他依赖关系或资源限制，生产者无法真正领先消费者太远。</p><h2 id="WML"><a href="#WML" class="headerlink" title="WML"></a>WML</h2><p>本页包含 Filebench 工作负载模型语言 (WML) 的完整而枯燥的定义。</p><p>分为四大类：</p><ul><li>commands</li><li>entities<ul><li>flowop</li></ul></li><li>attributes</li></ul><p><em>command</em> 定义<em>entities</em> 并控制运行 。在Filebench中有四个 entities ：1) <em>processes</em>, 2) <em>threads</em>, 3) <em>flowops</em> (operations), and 4) <em>variables</em> 。每个进程包含一个或多个线程，每个线程在循环中执行一个或多个flowop。</p><p>可以使用 <em>variables</em> 向 <em>entities</em> 和 flowops 传递参数。</p><p><strong>commands的索引</strong></p><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#create-files">create files</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#debug">debug</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#define-file">define file</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#define-fileset">define fileset</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#define-process">define process</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#echo">echo</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#enable">enable</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#eventgen">eventgen</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#list">list</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#psrun">psrun</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#quit">quit</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#run">run</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#set">set</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#set-mode">set mode</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#">sleep</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#system">system</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#version">version</a> |</p><p><strong>Flowops的索引</strong></p><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#read">read</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#readwholefile">readwholefile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#write">write</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#writewholefile">writewholefile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#appendfile">appendfile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#appendfilerand">appendfilerand</a> |</p><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#createfile">createfile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#openfile">openfile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#closefile">closefile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#statfile">statfile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#deletefile">deletefile</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#fsync">fsync</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#fsyncset">fsyncset</a> |</p><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#makedir">MakeDir</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#removedir">RemoveDir</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#listdir">ListDir</a> |</p><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#aiowrite">aiowrite</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#aiowait">aiowait</a> |</p><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#block">block</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#wakeup">wakeup</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#semblock">semblock</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#sempost">sempost</a> |</p><p><a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#eventlimit">eventlimit</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#delay">delay</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#hog">hog</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#finishonbytes">finishonbytes</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#finishoncount">finishoncount</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#opslimit">opslimit</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#iopslimit">iopslimit</a> | <a target="_blank" rel="noopener" href="https://github.com/filebench/filebench/wiki/Workload-model-language#bwlimit">bwlimit</a> |</p><h3 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h3><h4 id="create-files"><a href="#create-files" class="headerlink" title="create files"></a>create files</h4><p>创建所有之前定义的files和fileset。通过 <code>run</code> 和 <code>psrun</code> 自动完成。但有时将文件创建阶段分开很方便。例如：Filebench仅用于生成文件目录树，或想在文件创建后执行系统命令（删除文件系统特定的缓存）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create files</span><br></pre></td></tr></table></figure><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>echo 命令将文本打印到标准输出。文本应该用引号括起来，并且可以包含变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Number of files in workload is $files&quot;</span><br></pre></td></tr></table></figure><h4 id="enable-多节点模式"><a href="#enable-多节点模式" class="headerlink" title="enable(多节点模式)"></a>enable(多节点模式)</h4><blockquote><p>启用默认禁用的其他Filebench特性。</p></blockquote><p>目前可以启用lathist和multi功能。</p><ul><li>lathist告诉Filebench收集每个流的延迟直方图，而multi启用启用多节点模式。</li></ul><p>对于多节点模式，必须指定主节点的主机名和客户端的主机名。多节点特性正在开发中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enable lathist </span><br><span class="line">enable multi master=&lt;hostname&gt;,client=&lt;clientname&gt;</span><br><span class="line">enable multi master=&quot;master.domain.org&quot;,client=&quot;slave.domain.org&quot;</span><br></pre></td></tr></table></figure><h4 id="eventgen"><a href="#eventgen" class="headerlink" title="eventgen"></a>eventgen</h4><p>eventgen命令控制Filebench内部事件生成器的属性。</p><p>rate属性设置每秒产生的事件数，事件随后被eventlimit、iopslimit、opslimit和bwlimit flowops使用。</p><p>如果在执行流操作时没有可用的事件，那么流操作将阻塞，直到新的事件被提交。所有线程中的所有流都使用一个通用的事件池。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eventgen [rate = &lt;events_per_second&gt;]</span><br><span class="line">eventgen rate = 100</span><br><span class="line">表示每秒产生100个事件</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>启动filbench运行：</p><ul><li>自动创建所有定义的fileset，fork定义的进程和线程。</li><li>当运行完成时（因为时间超过或其他原因），Filebench会打印运行的统计信息，例如ops/sec。</li></ul><p>一般情况，该指令放在最后</p><p>以 runtime 为参数，默认的运行时长为60s</p><p><strong>Syntax</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run [&lt;runtime&gt;]</span><br></pre></td></tr></table></figure></blockquote><p><strong>Example</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run 300</span><br></pre></td></tr></table></figure></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义变量，所有变量都由一个以美元符号“$”开头的字符串标识。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">user_defined_varname</span></span><br></pre></td></tr></table></figure><p>可以通过在大括号中指定对应的变量名来访问内部变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;stats | rate | <span class="built_in">date</span> |scriptname | hostname&#125;</span></span><br></pre></td></tr></table></figure><p>变量可以用来设置文件、文件集、进程、线程和流的属性。</p><h5 id="常规变量"><a href="#常规变量" class="headerlink" title="常规变量"></a>常规变量</h5><p>使用“set”命令创建并分配布尔值、整数、double、字符串值、null 或 $varname</p><p>常规的、用户自定义的变量可以用“set”命令设置一个值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set $&lt;user_defined_varname&gt; = [true | false | | | ]</span><br><span class="line">set $&lt;varname&gt; = [ true | false | &lt;integer&gt; | &lt;double&gt; | &quot;&lt;string&gt;&quot; | $&lt;othervarname&gt;</span><br></pre></td></tr></table></figure><h5 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h5><p>随机变量是用户定义的实体，它定义了一个随机分布，用于在每次使用时选择一个随机值并返回。</p><p>用“define randvar”命令创建的，并且可以用“set”命令设置单个参数。和普通变量一样使用，但每次访问都会返回不同的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define randvar name = $&lt;user_defined_varname&gt;, [type=[uniform | gamma | table]] [, seed=] [, mean=] [, gamma=] [, min=] [, round=] [, randsrc=[urandom | rand48] [, randtable=&#123;&#123;&lt;%&gt;,,&#125;, ...&#125;</span><br><span class="line"></span><br><span class="line">set $&lt;random varname&gt;.type = [ uniform | gamma | tabular ]</span><br><span class="line">set $&lt;random varname&gt;.randsrc = [ urandom | rand48 ]</span><br><span class="line">set $&lt;random varname&gt;.[ gamma | mean | min | round | seed ] = &lt;value&gt;</span><br><span class="line">set $&lt;random varname&gt;.randtable = &#123;&#123; &lt;%&gt;, &lt;min value&gt;, &lt;max value&gt;&#125;, ...&#125;</span><br><span class="line">set $&lt;custom varname&gt; = cvar(type=&quot;cvar-type&quot;,paramters=mean)</span><br></pre></td></tr></table></figure><h4 id="set-mode"><a href="#set-mode" class="headerlink" title="set mode"></a>set mode</h4><p>用于将Filebench设置为各种特殊的运行模式。quit是目前唯一定义的命令</p><p>默认值是quit timeout，当run命令中指定的运行时超时或遇到经过积极评估的finishon* flowop时结束运行。</p><p>如果期望工作负载在资源耗尽时结束，例如要删除的文件，那么使用quit alldone在所有线程因资源耗尽而退出时完成运行，或者使用quit firstdone在第一个线程检测到资源耗尽时立即退出。</p><p><strong>Syntax</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set mode quit [ timeout | alldone | firstdone ]</span><br></pre></td></tr></table></figure></blockquote><p><strong>Example</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set mode quit alldone</span><br></pre></td></tr></table></figure></blockquote><ul><li>finishoncount：用于终止一个线程，执行了<strong>指定次数</strong>的flowop操作（read/write）</li><li>finishonbytes：用于终止一个线程，执行了<strong>指定数据量</strong>的flowop操作（read/write）</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop finishoncount name=&lt;name&gt;,value=&lt;ops/s&gt;,[target=&lt;any-flowop]</span><br></pre></td></tr></table></figure></blockquote><h4 id="define-fileset"><a href="#define-fileset" class="headerlink" title="define fileset"></a>define fileset</h4><p>一组相关文件的信息（例如，由web服务器访问的所有html文件）包含在一个fileset实体中。</p><p>Fileset实体使用define Fileset命令指定。</p><p>define fileset命令必须提供文件集的名称和文件所在目录的路径。</p><p>此外，还接受几个可选的fileset属性。</p><ul><li><p><code>name =</code> 强制性的。文件集的名称。</p></li><li><p><code>path =</code> 强制性的。创建文件的目录路径。</p></li><li><p><code>entries =</code> 可选的。文件集中的文件数。在fileset中可以创建的最大文件数。并不是fileset中的所有文件都是在Filebench运行一开始就创建的。<code>prealloc</code>属性来控制初始化创建文件的比例。</p><p><code>entries</code>属性用于设置此类文件的数量。如果未指定<code>entries</code>属性，则只会创建一个文件。</p></li><li><p><code>filesize =</code> <code>size =</code> ：可选的。文件集中每个文件的大小。默认为1KiB。</p><p>文件的<code>filesize</code>属性指定了要创建的文件的大小。如果指定的fileset和filegamma不是0，那么filesize属性实际上指定的是平均文件大小，每个文件的实际大小是基于gamma分布和基于filegamma属性的alpha分布。、</p><p><code>size</code>属性与define file和define fileset命令一起使用。对于 <code>define file</code> ，它设置文件的大小。对于<code>define fileset</code>，它设置文件的平均大小，实际大小由文件集指定的伽马随机分布设置。</p></li><li><p><code>prealloc =</code></p><p>可选的。</p><p>在Filebench工作负载开始之前，默认不会直接创建文件，只预分配文件所需要的空间。</p><p>若想在工作负载开始前，实际创建文件，则使用该属性指定fileset的创建百分比。</p><p>如果未指定<code>prealloc</code>，默认值为0。</p><p>如果指定<code>prealloc</code>时没有指定数值，则值为100。</p><p>file或fileset实体定义的文件可以作为潜在文件存在，也可以作为实际文件存在。</p><ul><li><p>作为潜在的，它们的信息由file或fileset实体保存，但不占用磁盘空间或存在于目录中。如果它们不存在，可以稍后使用<code>creatfile</code>流程创建它们。</p></li><li><p>当与file一起使用时，<code>prealloc</code>属性指定该文件应该实际存在。</p><p>在与fileset一起使用时，它指定了实际存在的文件的百分比，默认值为100%。</p></li></ul></li><li><p><code>reuse</code></p><ul><li><p>对于文件集：</p><p>如果文件系统中存在文件集，则重用该文件集。如果文件系统中存在标记为existing的fileset条目对应的文件，取决于<code>trusttree</code>属性，这样的文件将不会被调整为适当的大小。根据<code>trusttree</code>属性，zd如果文件系统中不存在文件，则会或不会创建它。</p><p>如果没有设置<code>reuse</code>并且文件集存在，它将在从头重新创建之前被完全删除。</p></li><li><p>对于文件：</p><p>如果文件已经存在，是重用它还是重新创建它。<code>reuse</code>属性允许重用与指定文件或文件集具有相同名称的现有文件或文件集。如果文件太大，它将被截断，如果文件太小，它将被重写。具有匹配名称的文件集也将被重用，单个文件将被调整以匹配它们新的指定大小。</p></li></ul></li><li><p><code>trusttree</code></p><p>是否完全信任现有的文件集。暗示了<code>reuse</code>属性，并且省略了文件的存在性和大小检查。</p></li><li><p><code>paralloc</code></p><p>可选的。使用32个线程以parallel方式在文件系统上分配文件。默认使用单线程。</p><p>使用这个属性可以通过并行创建和写入文件，加快文件的预分配。但目前它只能处理文件，不能处理文件集。</p></li><li><p><code>readonly</code></p><p>可选的。用O_RDONLY打开所有文件。同样适用于新创建的文件。默认情况下使用O_RDWR标志。</p></li><li><p><code>writeonly</code></p><p>可选的。用O_WRONLY打开所有文件。同样适用于新创建的文件。默认情况下使用O_RDWR标志。</p></li><li><p><code>dirwidth</code></p><p>可选的。每个目录要创建多少个文件。</p><p>fileset的<code>dirwidth</code>属性指定了，每个目录中条目的平均数量。</p><p>Filebench还将其与fileset中的文件总数结合使用，以计算fileset目录树所需的平均深度。</p><p>默认值是dirwidth为0，指定包含fileset中所有文件的单层目录。</p></li><li><p><code>dirgamma</code></p><p>可选的。Gamma表示dirwidth文件的伽马分布。</p><p>fileset的<code>dirgamma</code>属性指定gamma分布的alpha参数，该参数将用于决定给定的子目录包含文件还是额外的子目录。如果没有指定dirgamma属性，默认值为1500。取值范围为100 ~ 10000，对应的gamma值为0.1 ~ 10。</p></li><li><p><code>didepthrv</code></p><p>Optional. XXX. Default value is XXX.</p></li><li><p><code>leafdirs</code></p><p>Optional. XXX. Default value is XXX.</p></li></ul><p><strong>Syntax</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define fileset name=&lt;name&gt;,path=&lt;pathname&gt;[,entries=&lt;files&gt;][,filesize=&lt;filesize&gt;][,dirwidth=&lt;width&gt;][,dirgamma=&lt;dirgamma&gt;][,dirdepthrv=&lt;$rv&gt;][,leafdirs=&lt;leafdirs][,prealloc | prealloc = &lt;percent&gt;],[,writeonly][,readonly][,paralloc][,reuse][,trusttree]</span><br></pre></td></tr></table></figure></blockquote><p><strong>Examples</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define fileset name=&quot;myfilesetF&quot;,path=&quot;/tmp&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define fileset name=&quot;myfilesetF&quot;,path=&quot;/tmp&quot;,entries=10000,filesize=16384,prealloc=80</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define fileset name=&quot;myfilesetF&quot;,path=&quot;/tmp&quot;,entries=1000,filesize=16384,dirwidth=1000,prealloc</span><br></pre></td></tr></table></figure></blockquote><h4 id="define-file"><a href="#define-file" class="headerlink" title="define file"></a>define file</h4><p>定义单个文件。文件的强制属性是name、path（文件所在的目录）和size。可选属性是prealloc（用数据创建并填充文件）、paralloc（与其他文件并行分配）和reuse（如果存在则重用文件）。</p><p><strong>Syntax</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define file name=&lt;name&gt;,path=&lt;pathname&gt;,size=&lt;size&gt;[,paralloc][,prealloc][,reuse][,trusttree][,readonly][,writeonly]</span><br></pre></td></tr></table></figure></blockquote><p><strong>Example</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define file name=myfile,path=/tmp,size=100mb,prealloc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define file name=myfile,path=/tmp,size=100mb,reuse,readonly</span><br></pre></td></tr></table></figure></blockquote><h4 id="define-process"><a href="#define-process" class="headerlink" title="define process"></a>define process</h4><p>Filebench进程表示一个操作系统进程，包含一个或多个线程。每个Filebench线程代表一个操作系统控制线程，并包含一个flowops集合。</p><ul><li>进程实体对应操作系统进程。define process命令用于实例化一个给定的进程实体，它可以产生一个或多个相同的进程副本。每个进程由一个或多个线程组成。反过来，线程由一组定义线程应该做什么的流（操作）组成。</li><li>线程还可以分配一个内存区域，某些流将使用该区域作为I/O的缓冲空间。该区域通过设置memsize属性的值来创建。如果设置了“useism”属性，则使用IPC共享内存，否则使用线程本地内存。</li></ul><p>如果没有包含实例flowop，则创建进程或线程的一个实例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define process name=filewriter,instances=1 &#123; </span><br><span class="line">	thread name=filewriterthread,memsize=10m,instances=1 &#123; </span><br><span class="line">		flowop appendfile name=write-file, filesetname=bigfileset, iosize=1m, fd=1, iters=20</span><br><span class="line">		flowop closefile name=close,fd=1 </span><br><span class="line">		flowop finishoncount name=finish,value=1 </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Process attributes</strong></p><ul><li><p><code>name =</code></p></li><li><p><code>instances</code> ：生成该进程的实例数。相应数量的操作系统进程将被创建，每个进程都有自己定义的线程和flowop副本<br>缺省则创建进程的单个实例</p></li><li><p>nice</p><p><code>nice</code>属性允许您将进程的优先级低于其他情况下的优先级（或者如果请求多个实例，则将一组进程的优先级降低）。注意，所有进程都会自动设置为比控制运行的主进程低的优先级。</p><p>但是如果你希望某个特定进程的优先级低于其他进程，可以用整数指定<code>nice</code>来实现这一点。</p></li></ul><p><strong>Thread attributes</strong></p><ul><li><code>name =</code></li><li><code>memsize =</code><br>强制性的。在线程开始时，分配该线程的私有内存量。线程会在运行之前将该区域置零，并为该区域的读写流分配缓冲区。</li><li><code>instances =</code> 生成该数量的线程。</li><li><code>useism</code> 所有线程使用共享内存，而不是每个线程的内存。 <code>useism</code>属性告诉线程将共享内存用作其线程内存区域。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define process name=&lt;process name&gt;[,instances=&lt;number of instances&gt;][,nice=&lt;additional niceness&gt;][,useism]&#123;</span><br><span class="line">   thread name =&lt;thread name&gt;,memsize=&lt;memory size&gt;[,instances=&lt;number of instances&gt;][,nice=&lt;additional niceness&gt;] &#123;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>打印定义项的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list fileset|flowop</span><br><span class="line"></span><br><span class="line">list fileset</span><br><span class="line">list flowop</span><br></pre></td></tr></table></figure><h4 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h4><p>终止filebench的执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>使Filebench休眠指定秒数。注意，这不是worker执行的flowop，而是Filebench主进程执行的命令。</p><h3 id="Flowops"><a href="#Flowops" class="headerlink" title="Flowops"></a>Flowops</h3><p>flowop子句确定线程实际做什么。flowop分为基本I/O、异步I/O、同步I/O和各种其他操作。</p><ul><li>filebench提供的操作指令，对应文件系统的系统调用</li></ul><p>有些flowop语法对所有的flowop都是通用的。它们在线程定义中使用flowop关键字定义。</p><p>紧跟在flowop关键字之后的是要执行的特定操作的名称。接下来是属性列表，其中的name和iter属性对所有流都是通用的。</p><p>name属性是强制的，它为特定的流实例提供了一个名称，可以在其他地方和结果中引用该实例。name必须是全局唯一的。</p><p>iters属性是可选的，但如果指定，则允许在每次调用flowop时多次执行流指定的操作。</p><h4 id="文件Flowop"><a href="#文件Flowop" class="headerlink" title="文件Flowop"></a>文件Flowop</h4><p>读写文件和文件集。</p><p>在打开或创建文件时，可以指定一个文件描述符编号。</p><ul><li>然后，对已经打开的文件的操作可以通过文件描述符编号引用。</li><li>如果提供的文件名或文件集名称没有提供文件描述符编号，则其他读写流将隐式地打开一个文件。</li></ul><p>对于文件集，可以通过向flowop传递文件索引号来访问特定的文件，索引号可以从一个随机变量中获得，以提供随机文件访问。否则，文件将按轮询方式访问。</p><h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><p>模拟posix读或读。</p><p>flowop必须包含filesetname或filename属性。</p><p>如果提供了filesetname属性，就会从fileset读取文件。否则，它将读取由filename属性指定的文件。</p><p>如果在fd属性中指定了一个文件集，那么将读取引用的文件。否则将使用默认的fd=0，或者，如果设置了opennext属性，flowop将按顺序选择下一个文件来读取。</p><p>实际的读取是对线程流的线程内存中的一个随机偏移量进行的，大小由iosize属性设置，如果设置了random属性，则在工作集大小内的一个随机磁盘偏移量，或者在下一个顺序位置进行读取。workingset属性指定了用于选择随机磁盘偏移量的偏移范围</p><ul><li><p><code>name =</code> 强制性的。名称在entity中必须是全局唯一的。因此，如果你有两个进程，每个进程都有一个读类型flowop，你必须确保两个读流都有唯一的名称，例如name=read1 name=read2。</p></li><li><p><code>filesetname =</code> <code>filename =</code> 其中一个属性是强制性的。<code>filename</code>属性指定了文件的名称。它与I/O flowop 一起用于指定要访问的特定文件。<code>filesetname</code>属性指定了一个文件集的名称。它与I/O flowop 一起使用，用于指定要访问的特定文件集。</p></li><li><p><code>iosize =</code> <code>iosize</code>属性用于指定I/O操作的大小。</p></li><li><p><code>directio</code> 指定以直接而不是缓冲的I/O模式打开文件。</p><p>本质上绕过了文件系统缓存，因此每个I/O请求都会导致对所连接设备的实际I/O操作。需要指定打开文件的流程，通常是openfile，但也可以是其他I/O流程之一。</p></li><li><p><code>dsync</code> 指定使用同步写，在连接的设备将数据写入非易失存储器之前，同步写不会完成。这不仅会禁用文件系统的回写缓存，还应该阻止设备（例如连接的磁盘驱动器）进行回写缓存。所有可能打开文件的flowops 都需要指定此属性，因为文件必须以同步文件的方式打开，才能使此属性生效。虽然openfile经常用于此目的，但任何其他流都会在文件尚未打开时打开该文件，因此它们可能也需要定义该属性。</p></li><li><p><code>fd =</code> 用于显式设置打开文件的文件描述符。当脚本模拟一个应用程序时，这很有用，该应用程序使用不同的描述符打开多个文件，或者使用有限或扩展的描述符范围打开/关闭文件。</p></li><li><p><code>opennext</code> <code>opennext</code>属性与I/O flowops一起使用，表示flowop每次调用都应该打开不同的文件。</p></li><li><p><code>iters =</code> 通过将<code>iter</code>属性设置为所需的执行次数，每次调用单个流时可能会执行多次。如果没有指定，那么每次调用flowop时只会执行一次。</p></li><li><p><code>random</code> 指定在文件中选择一个随机的位置进行访问。如果没有这个属性，接下来的连续文件块将被读取或写入。</p></li><li><p><code>workingset =</code> <code>workingset</code>属性被一些I/O流用来指定实际读取或写入文件的<strong>最大字节范围</strong>。这个值可以小于实际的文件大小，对于写操作，也可以大于当前的大小，用于设置文件可以增长到的最大大小。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop read name=&lt;name&gt;,filesetname|filename=&lt;fname&gt;,iosize=&lt;size&gt;[,directio][,dsync][,iters=&lt;count&gt;][,random][,opennext][,workingset=&lt;size&gt;][,fd=&lt;file-desc-number&gt;][,index=&lt;file-index&gt;]</span><br></pre></td></tr></table></figure><h5 id="readwholefile"><a href="#readwholefile" class="headerlink" title="readwholefile"></a>readwholefile</h5><p>模拟整个文件的读取。来自提供的fileset filesetname的文件，</p><ol><li><p>打开文件</p><ul><li><p>由fd属性引用（如果提供了），或者默认情况下fd=0。</p></li><li><p>如果文件描述符（0或非0）没有打开，readwholefile会在读取文件之前打开文件。</p></li></ul></li><li><p>读取文件</p><p>然后，readwholefile流从文件的开头读到末尾，使用0次或多次iosize读取，然后读取小于iosize的剩余内容。</p><p>如果iosize没有定义或设置为0，那么读取文件只需要读取一次filesize字节（在fileset中定义）。</p></li></ol><ul><li><code>name</code> Name of the flowop</li><li><code>fd =</code></li><li><code>opennext</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iosize =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop readwholefile name=,filesetname=,iosize=,[,iters=][,fd=] [,index=]</span><br></pre></td></tr></table></figure><h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><p>模拟写入文件。写入操作的大小由iosize属性指定。</p><ul><li><p>如果指定了一个文件集，它会从fd属性引用的文件集（如果提供了该文件集）写入到默认的fd=0文件，如果设置了opennext属性，则写入到序列中的下一个文件。</p></li><li><p>如果提供了filename属性，它会写入指定的文件。</p><p>如果文件还没有打开，这个flowop将使用openfile flowop 中描述的directio和dsync属性来打开它。</p><p>如果非零，flowop的workingset属性将用于设置最大文件大小，否则将使用整个文件大小。</p></li></ul><p>实际的写操作是在线程流的线程内存中的一个随机偏移量中进行的，iosize属性设置了大小，如果设置了random属性，则在工作集大小内的一个随机磁盘偏移量中进行，或者在下一个顺序位置进行写操作。</p><ul><li><code>name =</code></li><li><code>iters =</code></li><li><code>directio</code></li><li><code>dsync</code></li><li><code>fd =</code></li><li><code>opennext</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iosize =</code></li><li><code>random</code></li><li><code>workingset =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop write name=,filesetname|filename=,iosize=[,directio][,dsync][,iters=][,random][,opennext][,workingset=][,fd=][,index=]</span><br></pre></td></tr></table></figure><h5 id="writewholefile"><a href="#writewholefile" class="headerlink" title="writewholefile"></a>writewholefile</h5><p>模拟整个文件的写入。</p><p>文件的大小取自srcfd属性标识的文件集，而用于写入的文件由fd属性标识。二者的默认值都为0。</p><p>多次写入长度为iosize的文件，直至写入整个文件。</p><p>如果未定义iosize或将其设置为0，则完成对源文件大小的一次写入。</p><ul><li><code>name</code></li><li><code>dsync</code></li><li><code>fd =</code></li><li><code>srcfd =</code> <code>srcfd</code>属性指定了在调用writewholefile流时用作<code>filesize</code>信息来源的文件描述符。在下面的示例中，代码模拟了一个复制文件的操作，在这个操作中，文件被读入，然后写入到一个新文件中，当然，这个新文件最终的大小与原始文件相同。</li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iosize =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop writewholefile name=,filesetname=,iosize=[,dsync][,iters=][,srfd=][,fd=][,index=]</span><br></pre></td></tr></table></figure><h5 id="appendfile"><a href="#appendfile" class="headerlink" title="appendfile"></a>appendfile</h5><p>模拟一个固定大小的附加到一个文件。</p><p>如果文件集是用filesetname属性指定的，或者fd属性非零且与文件描述符关联的文件是打开的，则将数据附加到从文件集中选择的文件。</p><p>如果指定了文件集，但引用的文件没有打开，appendfile会打开它。</p><p>如果没有指定fileset或非零的fd属性，那么将使用由“filename”属性命名的文件。</p><p>如果找不到合适的文件，Filebench将终止。</p><p>因此，对给定文件的流的重复调用将导致文件任意增大。每次追加操作的大小由iosize属性设置。</p><ul><li><code>name =</code></li><li><code>directio</code></li><li><code>dsync</code></li><li><code>fd =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iosize =</code></li><li><code>iters =</code></li><li><code>workingset =</code> <code>workingset</code>属性被一些I/O流用来指定实际读取或写入文件的最大字节范围。这个值可以小于实际的文件大小，对于写操作，也可以大于当前的大小，用于设置文件可以增长到的最大大小。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop appendfile name=, filename|fileset=, iosize=\ [,dsync] [,iters=] [,workingset=] [,fd=][,index=]</span><br></pre></td></tr></table></figure><h5 id="appendfilerand"><a href="#appendfilerand" class="headerlink" title="appendfilerand"></a>appendfilerand</h5><p>模拟附加到文件的随机大小。向文件当前末尾写入一个随机传输大小不超过“iosize”字节的数据。</p><p>如果用fileset属性指定了文件集，或者fd属性非零且与文件描述符关联的文件是打开的，则将数据附加到从文件集中选择的文件。如果指定了文件集，但引用的文件没有打开，appendfile会打开它。</p><p>如果没有指定filesetname或非零的fd属性，那么将使用由filename属性命名的文件。如果找不到合适的文件，Filebench将终止。</p><p>重复调用给定文件的流操作会导致文件变得任意大。</p><ul><li><code>name=</code></li><li><code>directio</code></li><li><code>dsync</code></li><li><code>fd=</code></li><li><code>filesetname=</code> <code>filename=</code></li><li><code>iosize=</code></li><li><code>iters=</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop appendfilerand name=, filename|filesetname=, iosize=\ [,dsync] [,iters=] [,workingset=] [,fd=] [,index=]</span><br></pre></td></tr></table></figure><h4 id="文件元数据flowop"><a href="#文件元数据flowop" class="headerlink" title="文件元数据flowop"></a>文件元数据flowop</h4><p>打开、关闭和说明文件和文件集。</p><p>文件</p><ul><li>在打开或创建文件时，可以指定文件描述符编号。</li><li>然后，对已经打开的文件的操作可以通过文件描述符编号引用它。</li></ul><p>对于文件集，可以通过向flowop传递文件索引号来打开或创建特定的文件，索引号可以从一个随机变量中获得，以提供随机文件访问。否则，文件将按轮询方式访问。</p><h5 id="createfile"><a href="#createfile" class="headerlink" title="createfile"></a>createfile</h5><p>模拟文件的创建。</p><p>将createfile的fd属性（如果提供）与创建的文件的操作系统特定的文件描述符关联起来，以便其他文件操作可以引用它。</p><p>从文件集中选择当前不存在用于文件创建操作的文件条目。接下来对文件执行打开操作，并设置O_CREATE标志，以创建文件。</p><p>通过包含directio属性，可以用直接I/O创建（即打开）文件，通过设置dsync属性，可以强制写入行为按照同步I/O数据完整性约束的定义进行。</p><ul><li><code>name =</code></li><li><code>directio</code></li><li><code>dsync</code></li><li><code>fd =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop createfile name=,filesetname=[,fd=][,directio][,dsync][,index=]</span><br></pre></td></tr></table></figure><h5 id="openfile"><a href="#openfile" class="headerlink" title="openfile"></a>openfile</h5><p>模拟文件打开操作。</p><p>将openfile的fd属性（如果提供）与打开文件的操作系统特定的文件描述符关联起来，以便其他文件操作可以引用它。但是，如果提供的fd属性已经关联到一个打开的文件，openfile就会失败。</p><p>从文件集中选择一个文件条目，该文件存在，用于文件打开操作。然后对文件条目的关联文件执行文件打开操作。</p><p>通过设置directio属性，可以用直接I/O打开文件，通过设置dsync属性，可以强制写操作按照同步I/O数据完整性约束的定义进行。</p><ul><li><code>name =</code></li><li><code>directio</code></li><li><code>dsync</code></li><li><code>fd =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop openfile name=,filesetname=[,fd=][,directio][,dsync][,index=]</span><br></pre></td></tr></table></figure><h5 id="closefile"><a href="#closefile" class="headerlink" title="closefile"></a>closefile</h5><p>模拟一个文件的关闭。fd属性引用的文件（如果提供了）或默认情况下fd=0，必须是打开的文件。只是对引用的文件执行关闭操作。</p><ul><li><code>name =</code></li><li><code>fd =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop closefile name= [,fd=]</span><br></pre></td></tr></table></figure><h5 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h5><p>发起fsync系统调用，强制落盘</p><p>fd属性引用的文件（如果提供了）或默认情况下fd=0，必须是打开的文件。</p><ul><li><code>name =</code></li><li><code>fd =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop fsync name=[,fd=]</span><br></pre></td></tr></table></figure><h5 id="fsyncset"><a href="#fsyncset" class="headerlink" title="fsyncset"></a>fsyncset</h5><p>模拟整个文件集的fsync。对fileset中的每个打开（XX）的文件执行<code>fsync</code>操作。</p><ul><li><code>name =</code> Mandatory. Name of the flowop. XXX</li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop fsyncset name=,fileset=</span><br></pre></td></tr></table></figure><h5 id="statfile"><a href="#statfile" class="headerlink" title="statfile"></a>statfile</h5><p>模拟一个文件的统计。</p><p>从filesetname指定的文件集中选择一个包含现有文件的任意文件集项，然后发起<code>stat()</code>系统调用，获取文件信息（<code>ino_t</code>,<code>nlink_t</code>,<code>off_t</code>…）</p><ul><li><code>name =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop statfile name=,filesetname=[,fd=file-desc-number][,index=]</span><br></pre></td></tr></table></figure><h5 id="deletefile"><a href="#deletefile" class="headerlink" title="deletefile"></a>deletefile</h5><p>模拟文件的删除。从filesetname属性指定的文件集中选择一个任意的、指定索引或指定file-descriptor-number的filesetentry，然后删除它。</p><ul><li><code>name =</code></li><li><code>fd =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop deletefile name=,fileset=[,fd=][,index=]</span><br></pre></td></tr></table></figure><h4 id="目录flowop"><a href="#目录flowop" class="headerlink" title="目录flowop"></a>目录flowop</h4><p>创建、列出和删除目录。文件集必须定义为除了文件之外，还包括空的目录项（leafdirs）。可以通过向flowop传递目录索引号来访问特定的目录，该索引号可以从一个随机变量中获得，以提供随机目录访问。否则，将以轮询方式访问目录。</p><h5 id="MakeDir"><a href="#MakeDir" class="headerlink" title="MakeDir"></a>MakeDir</h5><p>模拟mkdir命令。从filesetname属性指定的文件集中，为文件系统中不存在的目录选择一个任意的或索引指定的文件集项，并创建它。</p><ul><li><code>name =</code></li><li><code>fd =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop makedir name=,fileset=[,fd=][,index=]</span><br></pre></td></tr></table></figure><h5 id="ListDir"><a href="#ListDir" class="headerlink" title="ListDir"></a>ListDir</h5><p>模拟目录的ls。从filesetname属性指定的文件集中，为文件系统中存在的目录选择一个任意的或索引指定的filesetentry，并列出它。</p><ul><li><code>name =</code></li><li><code>fd =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop listdir name=,fileset=[,fd=][,index=]</span><br></pre></td></tr></table></figure><h5 id="RemoveDir"><a href="#RemoveDir" class="headerlink" title="RemoveDir"></a>RemoveDir</h5><p>模拟一个rmdir。从filesetname属性指定的文件集中选择文件系统中存在的某个目录的任意文件集项或索引指定的文件集项，然后删除它。</p><ul><li><code>name =</code></li><li><code>fd =</code></li><li><code>filesetname =</code> <code>filename =</code></li><li><code>iters =</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowop removedir name=,fileset=[,fd=][,index=]</span><br></pre></td></tr></table></figure><h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h4><h4 id="flowop同步操作"><a href="#flowop同步操作" class="headerlink" title="flowop同步操作"></a>flowop同步操作</h4><h4 id="flowop-misc-操作"><a href="#flowop-misc-操作" class="headerlink" title="flowop misc 操作"></a>flowop misc 操作</h4></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-hand-peace-o"></i>本文结束-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者 </strong>AmosTian</li><li class="post-copyright-link"><strong>本文链接 </strong><a href="https://amostian.github.io/posts/821066227/" title="Filebench">https://amostian.github.io/posts/821066227/</a></li><li class="post-copyright-license"><strong>版权声明 </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 存储</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tags"></i> 分布式存储</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/181607087/" rel="prev" title="5.BlueStore"><i class="fa fa-chevron-left"></i> 5.BlueStore</a></div><div class="post-nav-item"><a href="/posts/3064011220/" rel="next" title="论文伪代码">论文伪代码 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E6%A0%87"><span class="nav-text">指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E8%B4%9F%E8%BD%BD"><span class="nav-text">宏负载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86"><span class="nav-text">指标采集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E6%8C%87%E6%A0%87"><span class="nav-text">统计指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">启动指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%A7%A3%E9%87%8A"><span class="nav-text">输出解释</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-Summary"><span class="nav-text">I&#x2F;O Summary</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%88%86%E5%B8%83"><span class="nav-text">文件大小分布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F"><span class="nav-text">支持的随机变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83"><span class="nav-text">均匀分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83"><span class="nav-text">指数分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gamma%E5%88%86%E5%B8%83"><span class="nav-text">gamma分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83"><span class="nav-text">正态分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#log-%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83"><span class="nav-text">log-正态分布</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E9%A2%84%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD"><span class="nav-text">定制预定义负载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#oltp"><span class="nav-text">oltp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WML"><span class="nav-text">WML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#commands"><span class="nav-text">commands</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#create-files"><span class="nav-text">create files</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#echo"><span class="nav-text">echo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enable-%E5%A4%9A%E8%8A%82%E7%82%B9%E6%A8%A1%E5%BC%8F"><span class="nav-text">enable(多节点模式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eventgen"><span class="nav-text">eventgen</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#run"><span class="nav-text">run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set"><span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E5%8F%98%E9%87%8F"><span class="nav-text">常规变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F"><span class="nav-text">随机变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-mode"><span class="nav-text">set mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#define-fileset"><span class="nav-text">define fileset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#define-file"><span class="nav-text">define file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#define-process"><span class="nav-text">define process</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list"><span class="nav-text">list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#quit"><span class="nav-text">quit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep"><span class="nav-text">sleep</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flowops"><span class="nav-text">Flowops</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6Flowop"><span class="nav-text">文件Flowop</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#read"><span class="nav-text">read</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#readwholefile"><span class="nav-text">readwholefile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#write"><span class="nav-text">write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#writewholefile"><span class="nav-text">writewholefile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#appendfile"><span class="nav-text">appendfile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#appendfilerand"><span class="nav-text">appendfilerand</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AEflowop"><span class="nav-text">文件元数据flowop</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#createfile"><span class="nav-text">createfile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#openfile"><span class="nav-text">openfile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#closefile"><span class="nav-text">closefile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fsync"><span class="nav-text">fsync</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fsyncset"><span class="nav-text">fsyncset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#statfile"><span class="nav-text">statfile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deletefile"><span class="nav-text">deletefile</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95flowop"><span class="nav-text">目录flowop</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MakeDir"><span class="nav-text">MakeDir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ListDir"><span class="nav-text">ListDir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RemoveDir"><span class="nav-text">RemoveDir</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5I-O"><span class="nav-text">异步I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flowop%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">flowop同步操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flowop-misc-%E6%93%8D%E4%BD%9C"><span class="nav-text">flowop misc 操作</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="AmosTian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">AmosTian</p><div class="site-description" itemprop="description">知道的越多，不知道的越多</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">224</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AmosTian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AmosTian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_40479037?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40479037?type&#x3D;blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:17636679561@163.com" title="E-Mail → mailto:17636679561@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/27/2022 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-grav"></i> </span><span class="author" itemprop="copyrightHolder">AmosTian</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数 </span><span title="站点总字数">1201.1k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">48:40</span></div></div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script async src="/js/cursor/fireworks.js"></script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,document.body.addEventListener("input",POWERMODE)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"live2d-widget-model-hijiki"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>